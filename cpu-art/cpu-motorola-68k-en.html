<head>
<meta charset=utf-8>
<title>Emotional stories about processors for first computers: part 3 (Motorola 68k)</title>
<meta name=keywords content="CPU,processor,computer,history,Intel,DEC,PDP-11,VAX-11,8086,x86,hardware,GNU">
<style type=text/css>
code {
    border-width: 1px;
    border-style: solid;
    border-color: lightgreen;
    border-radius: 2px;
    padding: 1px;
}
p {
    display: block;
    margin-top: 0px;
    margin-bottom: 1em;
    margin-left: 0;
    margin-right: 0;
}
</style>
</head>

<body>
<h2>Motorola: from 68000 to 68040</h2>

<p>Motorola is the only company that could successfully compete with Intel processors in the field of production of processors for personal computers for some time.

<p>The 68000 was released in 1979 and at the first glance looked much more impressive than the 8086.  It could address 16 MB of memory directly, which did not create any restrictions, for example, for large arrays.  However, careful analysis of features of the 68000 shows that not everything is as good as it seems.  In those years, to have a memory of more than 1 MB is an unattainable luxury even for medium-sized organizations.  The 68000 code density is worse than for 8086, which means that 68000 code with the same functionality occupies more space.  The latter is also due to the fact that a program for the 68k should be multiples of 2 bytes in length, and for the x86 &ndash; 1.  But the information about the code density is controversial &ndash; there are some points showing that in some cases the 68000 could have the better code density.  Out of 16 registers there are 8 address registers, in some respect they are slightly more advanced analogues of the x86 segment registers.  The ALU and data bus are 16-bit, so operations with 32-bit data are slower than someone could expect.  The execution time of register-register operations is 4 cycles, and for the 8086 is only 2.

<p>As always, with products from Motorola, the architecture of the 68000 shows a few clumsiness and contrived oddities.  For example, there are two stacks and two carry flags (one for condition checks and another for operations).  Some operations are irritated by their non-optimization, for example, the CLR instruction of writing zero to memory is slower than writing a constant 0 to memory with the MOVE instruction or shift to the left is slower than adding an operand to itself.  There are some almost unnecessary commands, for example, there are both arithmetic and logical shifts to the left.  Even the address registers, while seemingly superior to the 8086 segment registers, have a number of annoying disadvantages.  For example, they needed to load as much as 4 bytes instead of two for 8086 and of these four, one was extra.

<p>The codes for Motorola look somewhat more cumbersome and clumsy compared to the x86 or ARM. On the other hand, the 68000 is faster than the 8086, according to my estimates by about 20-30%.  The 680x0's code, however, is inherent some special beauty and elegance, less mechanicality, than the x86's.  Additionally, as shown by <a href="http://eab.abime.net/">eab.abime.net</a> experts, the code density of the 68k is often better than that of the x86.

<p>Overall, the 68000 is a good processor, with a large instruction set.  It was used in many of the now legendary personal computers: the first Apple Macintosh computers that were produced before the early 90's, the first Commodore Amiga multimedia computers, in relatively inexpensive and high-quality Atari ST computers.  The 68000 was also used in relatively inexpensive computers working with Unix variants, in particular, in the rather popular Tandy 16B.  Interestingly, IBM simultaneously with the development of the PC led the development of the System 9000 computer based on the 68000, which was released less than a year after the PC.

<p>The 68010 appeared clearly belatedly, only in 1982, at the same time Intel released the 80286, which put personal computers on the level of a mini-computer.  The 68010 is compatible with the plug with the 68000, but the system of its instructions is slightly different, so the replacement of the 68000 by 68010 has not become popular.  The incompatibility was caused by a contrived reason to bring the 68000 into more correspondence with the ideal theory of virtualization.  The 68010 is only slightly, no more than 10% faster than the 68000.  Obviously, the the 68010 was badly losing the 80286 and was even weaker than the 80186 that appeared in the same year.  Like the 80186, the 68010 almost never found a use in personal computers.

<p>The 68008 was also released in 1982, probably with a hope of repeating the success of the 8088. It's the 68000, but with an 8-bit data bus, which allowed it to be used in cheaper systems.  But the 68008, like the 68000, does not have an instruction queue, which makes it about 50% slower than the 68000.  Thus, the 68008 may even be a little slower than the 8088, which is only about 20% slower than the 8086 due to the presence of the instruction queue.

<p>Based on it, Sir Clive Sinclair made the Spectrum QL &ndash; a very interesting computer that, because of the lower price, could compete with the Atari ST and similar computers.  But Clive, in parallel and clearly prematurely, began to invest a lot in the development of electric vehicles, leaving the QL (Quantum Leap) rather as a secondary task, which, in the presence of some unsuccessful constructive decisions, led the computer and the whole company to premature closure (the company became part of Amstrad, which refused to produce QL).

<p>It would be interesting to calculate the bit index for the 68000, it seems to me, clearly higher than 16, although rather not higher than 24.

<p>Appearing in 1984, the 68020 again returned Motorola to the first positions. In this processor, many very interesting and promising innovations were realized.  The strongest effect is certainly the instruction pipeline, which sometimes allows you to execute up to three instructions at a time!  The 32-bit address bus looked a little premature in those years, and therefore a cheaper version of the processor (68020EC) with a 24-bit bus was available.  But the 32-bit data bus looked quite appropriate and allowed to significantly speed up the processor.  The built-in cache appeared to be an innovation even though it was a small 256 bytes of capacity, which allowed to significantly improve the performance because the main dynamic memory could not keep up with the processor.  Quick enough operations for division (64/32 = 32,32) and multiplication (32*32 = 64), for approximately 80 and up to 45 cycles, respectively, were added.  The timings of the instructions were generally improved, for example, the division (32/16 = 16,16) began to be performed for approximately 45 cycles (more than 140 cycles in the 68000).  Some instructions in the most favorable cases can be performed without occupying clocks at all!  New address modes were added, in particular, with scaling &ndash; in the x86 this mode appeared only in the next year with the 80386.  Another new address modes allow the use of double indirect addressing, using several offsets, &ndash; the PDP-11 has been remarkably outdone here.

<p>But some new instructions, for example, bulky operations with bit fields or new operations with decimal numbers that have become little needed in the presence of rapid division and multiplication, looked more like a fifth wheel of a bus than something essentially useful.  Address modes with double indirect addressing theoretically look interesting, but practically are needed quite rarely and are executed very slowly.  Unlike the 80286, the 68020 takes time to compute the address of the operand, the so-called effective address.  The division at the 68020 is still almost twice as slow as the fantastic division at the 80286.  Multiplication and some operations are also slower.  The 68020 doesn't have a built-in memory management unit and rather the exotic ability to connect up to eight coprocessors couldn't fix this.

<p>The 68020 was widely used in mass computers the Apple Macintosh II, Macintosh LC and Commodore Amiga 1200.  It was also used in several Unix systems.

<p>The appearance of the 80386 with a built-in and very well-made MMU and 32-bit buses and registers, again put Motorola in position number 2.  The 68030, appearing in 1987, for the last time, briefly returned the leadership to Motorola.  The 68030 has a built-in memory management unit and a doubled cache, divided into a cache for instructions and data &ndash; it was a very prospective novelty.  In addition, the 68030 could use a faster memory access interface, which can speed up memory operations by almost a third.  Despite all the innovations, the 68030 turned out to be somewhat slower than the 80386 at the same frequency. However, the 68030 was available at frequencies up to 50 MHz, and the 80386 only up to 40 MHz, which made top systems based on the 68030 slightly faster.

<p>The 68030 was used in computers of the Apple Macintosh II series, Commodore Amiga 3000, Atari TT, Atari Falcon and some others.

<p>With the 68040 Motorola once again tried to outperform Intel.  This processor appeared a year later after the 80486, but on a set of useful qualities, it was never able to surpass it.  In fact, Motorola, having a more overloaded system of instructions, was not able to support it and in a sense has disappeared from the race.  In the 68040, only a very truncated coprocessor could be placed to work with real numbers, and the chip itself was heated significantly more than the 80486.  The 68040 almost did not find applications in popular computers.  Some noticeable use was found only by its cheaper version &ndash; the 68LC040, which does not have a built-in coprocessor.  However, the first versions of this chip had a serious hardware defect, which did not allow using even the software emulation of the coprocessor!

<p>Motorola always had problems with mathematical coprocessors.  As was mentioned above Motorola never released such a coprocessor for the 68000/68010, while Intel released its very successful 8087 since 1980.  But to get a significant performance boost, the code for the 68882 needs to be compiled differently than for the 68881.

<p>It is appropriate to say that Intel still has problems with the mathematical coprocessor &ndash; the accuracy of calculations of some functions, for example, the sine of some arguments is very small, sometimes no more than 4 digits.  Therefore, modern compilers often calculate such functions without using the services of the coprocessor.

</body>

