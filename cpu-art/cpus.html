<head>
<meta charset=utf-8>
<title>Эмоциональная история процессоров для первых компьютеров с 70-х до начала 90-х</title>
<meta name=keywords content="CPU,processor,computer,history,Intel,MOS Technology,Motorola,Zilog,DEC,IBM,PDP-11,VAX-11,WDC,Commodore,Amiga,Rockwell,National Semiconductor,Acorn,8080,8085,6502,z80,6800,6809,6309,32016,65816,TMS9900,ARM,Texas Instrument,8086,8088,80186,80286,80386,80486,68000,68008,68010,68020,68030,68040">
<link rel=stylesheet type=text/css href=style.css>
</head>
<body>
<h1 id=first>Эмоциональная история процессоров для первых компьютеров с 70-х до начала 90-х</h1>

<p>Мне довелось программировать на ассемблерах разных процессоров. Последний в списке &ndash; это Xilinx MicroBlaze. Решил выложить некоторые свои наблюдения за особенностями этих почти волшебных железок, которые как волшебный ключик Буратино открыли нам двери в волшебную страну виртуальной реальности и массовой креативности. Об особенностях современных систем x86, x86-64, ARM, ARM-64 и т.п. писать не буду, может быть в другой раз &ndash; тема очень большая и сложная. Поэтому планирую закончить на Intel 80486 и Motorola 68040. Хотелось ещё включить в обзор IBM/370, с которыми имел дело. Эти системы были довольно далеки от широких масс пользователей, но оказали при этом огромное влияние на компьютерные технологии. На них просто не хватило выделенного на тему времени, они не использовали процессоры-чипы и самих их вроде бы почему-то не осталось совсем. Очень надеюсь, что мои материалы привлекут внимание и знатоков, которые смогут добавить что-нибудь из того, о чем не подумал или не знал.

<p>В качестве иллюстративного материала прикрепляю свой небольшой <a href=https://github.com/litwr2/rosetta-pi-spigot>камень из Розетты</a> &ndash; программки для расчета числа &#x3c0; на разных процессорах и системах по <a href=https://ru.wikipedia.org/wiki/Spigot_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC>алгоритму-затвору</a>, претендующие на звание самых быстрых его реализаций.


<h2 id=i8080>Intel 8080 и 8085</h2>

<p>Первый настоящий процессор на чипе, сделанный в первой половине 1974 года, он до сих пор производится и находит себе применение. Многократно клонировался по всему миру, в СССР имел обозначение КР580ВМ80А. Современные процессоры Intel для РС до сих пор легко обнаруживают свою родственность этому уже в каком-то смысле реликтовому изделию. Сам для этого процессора кодов не писал, но будучи хорошо знакомым с архитектурой z80, рискну привести некоторые свои замечания.

<p>Систему команд 8080, как и других процессоров Intel для РС, трудно назвать идеальной, но она универсальная, достаточно гибкая и имеет несколько очень привлекательных особенностей. От своих конкурентов, Motorola 6800 и MOS Technology 6502, 8080 выгодно отличался большим количеством пусть и несколько неуклюжих регистров, предоставляя пользователю один 8-битный аккумулятор А, один 16-битный полуаккуммулятор и по совместительству быстрый индексный регистр HL, 16-разрядный указатель стека SP, а также ещё два 16-битных регистра ВС и DE. Регистры BC, DE и HL можно было использовать и как 6 байтовых регистров. Кроме того, 8080 имел поддержку почти полного набора флагов состояния: переноса, знака, нуля и даже чётности и полупереноса. Некоторые инструкции из набора команд 8080 долгое время были чемпионами по быстродействию. Например, команда XCHG делает обмен содержимым 16-битных регистров DE и HL всего за 4 такта &ndash; это было исключительно быстро! Ряд других команд хотя и не ставили столь яркие рекорды, но также долгое время были одними из лучших:

<ul>
<li>XTHL &ndash; обмен содержимым регистра HL и данных на вершине стека, 18 тактов &ndash; вроде бы много, на даже на настоящем 16-битном 8086 эквивалент такой команды занимает не менее 26 тактов, а для 6800 или 6502 такую команду даже трудно представить;

<li>DAD &ndash; добавить к полуаккуммулятору HL значение другого 16-битного регистра (BC, DE или даже SP), 10 тактов. Это настоящее 16-битное сложение с установкой флага переноса. Если складывать HL самим с собой, то будет получаться быстрый 16-разрядный сдвиг влево или умножение на 2, ключевая операция как для реализации полного умножения, так и деления;

<li>PUSH и POP &ndash; положить в стек и вынуть из стека 16-разрядное значение соответственно из регистра или в регистр. Выполняются за 11 и 10 тактов. Это самые быстрые операции 8080 для работы с памятью и при их выполнении происходит автоматическая инкрементация или декрементация SP. PUSH можно использовать, например, для быстрого заполнения памяти паттерном со значениями из 3 регистров (BC, DE, HL). Команд для работы с 8-битными величинами со стеком нет вообще;

<li>LXI &ndash; загрузка 16-битной константы в регистр (HL, DE, BC, SP) за 10 тактов;

<li>RNZ, RZ, RNC, RC, RPO, RPE, RP, RM &ndash; условные возвраты из подпрограммы, позволяли делать код чище, избавляя от необходимости писать лишние условные переходы. От этих команд отказались в архитектуре x86, возможно, что и зря, код с ним получается симпатичнее. 8080 также может использовать и соответствующие условные вызовы подпрограмм (CNZ, CZ, CNC, ...), хотя пользы от них обычно почти нет, так как при вызове подпрограммы в неё как правило нужно передавать параметры.
</ul>

<p>Этот процессор был использован в первом персональном компьютере Altair 8800, ставшим весьма популярным после журнальной публикации в начале 1975. К слову, в СССР похожая публикация случилась только в 1983, а соответствующая ей по актуальности только в 1986.

<div align=center>
<p><img src=https://upload.wikimedia.org/wikipedia/commons/0/01/Altair_8800_Computer.jpg style=width:50%>
<p style=font-size:90%>Первый почти ПК
</div>

<p>Intel 8080 стал основой для разработки когда-то первой массовой профессиональной операционной системы CP/M, занимавшей доминирующие позиции среди микрокомпьютеров для профессиональной работы до середины 1980-х.

<p>Теперь о недостатках. 8080 требовалось три напряжения питания -5, 5 и 12 вольт. Работа с прерываниями скорее неуклюжая: нужен специализированный контроллер и немаскируемые прерывания не поддерживались. И в целом 8080 скорее нетороплив, если сравнить его с вскоре появившимися конкурентами. 6502 мог быть до 3-х раз быстрее при работе на той же частоте, что и 8080. В системе команд несколько раздражает наличие 6 бессмысленных инструкция типа <code class=code>MOV A,A</code> &ndash; их могли бы не документировать, сохраняя пространство кодов для новых операций. Команду десятичной коррекции можно использовать только после сложения, а после вычитания для десятичной коррекции нужно использовать специальный код, обычно состоящий из 4 инструкций. Нет команд нециклических сдвигов.

<p>Но в архитектуре 8080 было заложено, как оказалось, правильное видение будущего, а именно того неизвестного в 70-х факта, что процессоры будут быстрее памяти. Регистры 8080 DE и BC &ndash; это скорее прообраз современных кэшей, с ручным управлением, чем регистры общего назначения. 8080 начал с частоты 2 МГц, а конкуренты только с 1, что сглаживало разницу в производительности.

<p>Первое время 8080 продавался по весьма высокой цене $360, но это была своеобразная ссылка на большие компьютеры IBM/360. Intel как бы сообщала, что если купить 8080, то можно получить что-то похожее на очень дорогой мейнфрейм.

<p>Трудно назвать 8080 8-битным процессором на все 100%. Конечно, АЛУ у него на 8 бит, но есть много 16 разрядных команд, работающих быстрее, чем если использовать только 8-битные аналоги вместо них. А для некоторых команд 8-битных аналогов нет вообще. Команда XCHG по сути и таймингам 100% 16-битная. Есть реальные 16-разрядные регистры. Поэтому рискну назвать 8080 частично 16-битным. Было бы интересно по совокупности признаков вычислять индекс разрядности процессора, но, насколько известно автору, пока такой работы никто не проделал.

<p>Автор не знает причины, почему Intel отказалась от прямой поддержки развития 8-битных персоналок своими процессорами. Intel всегда отличaла сложность и неоднозначность политики. Её связь с политикой, в частности, иллюстрирует тот факт, что долгое время у Intel функционируют заводы в Израиле и до конца 90-х это было тайным. Intel практически не пыталась улучшить 8080, была лишь до 3 с небольшим МГц поднята тактовая частота. Фактически 8-битный рынок был передан фирме Zilog с родственным 8080 процессором z80, который смог довольно успешно противостоять главному конкуренту, "терминатору" 6502. А Zilog к концу 70-х была компанией с огромными возможностями, имея почти неограниченное финансирование от Exxon и даже две новейшие фабрики по производству чипов, что было реально много &ndash; Motorola, имея миллиардный бизнес, имела в то время также только две фабрики. В начале 80-х значение 6502 стало уже незначительным и Zilog тоже стремительно потерял свой вес &ndash; странное совпадение. Кроме того, 8080 и 8085 использовались обычно как контроллеры и в этом качестве могли успешно продаваться по более высокой цене. Наличие z80 позволяло Intel устраниться от конкуренции 8-битных процессоров для компьютеров, где 6502 сильно обвалил цены.

<p>В СССР и России отечественный клон 8080 стал основой многих массовых компьютеров, сохранявших популярность до начала 90-х. Это, конечно, Радио-86РК, Микроша, многоцветные Орион-128, Вектор и Корвет. Однако в войне клонов победили дешёвые и улучшенные клоны ZX Spectrum на основе z80.

<div align=center>
<p><img src=https://www.old-games.ru/forum/attachments/d64acd00877a00143c992eeffc16e35d-jpg.75531 style=width:50%>
<p style=font-size:90%>Это уже настоящий ПК
</div>

<p>В начале 1976 Intel был представлен процессор 8085, совместимый с 8080, но значительно превосходивший своего предшественника. В нём уже стало ненужным питание -5 и 12 вольт, использовалась тактовая частота от 3 до весьма солидных 6 МГц, система команд была расширена несколькими полезными инструкциями: 16-разрядным вычитанием, 16-разрядным сдвигом вправо всего за 7 тактов (это очень быстро), 16-разрядным вращением влево через флаг переноса, загрузкой 16-разрядного регистра с 8-разрядным смещением (эту команду можно использовать и с указателем стека SP), запись регистра HL по адресу в регистре DE, аналогичное чтение HL через DE. Все упомянутые инструкции кроме сдвига вправо выполняются за 10 тактов &ndash; это иногда существенно быстрее, чем их аналоги или эмуляция на z80. Были добавлены ещё несколько инструкций и даже два новых флага признаков: флаг переполнения и флаг, двоично суммирующий переполнение и знак. Работа с новыми флагами, особенно вторым практически не поддерживалась. Точное назначение второго флага, типичного для знаковой арифметики, стало известным только в 2013, спустя 37 лет после появления 8085! Этот флаг позволяет за раз проверить выполнение отношений "больше или равно" или "меньше", но проверки для парных им отношений потребуют ещё работы с флагом нуля. Были ускорены на такт многие инструкции для работы байтовыми данными. Это было очень существенно, так как на многих системах с 8080 или z80 вводились такты задержки, которые из-за наличия лишних тактов на 8080 могли вытянуть время исполнения почти в два раза. Например, в отечественном компьютере Вектор инструкции типа регистр-регистр выполнялись 8 тактов, а если бы там стоял 8085 или z80, то эти же инструкции выполнялись бы только за 4 такта. Инструкция XTHL стала быстрее на два такта, а инструкции переходов даже на 3. С новыми инструкциями можно написать код для копирования блока памяти, который работает быстрее команд LDI/LDD процессора Z80! Однако, некоторые инструкции, например, вызов подпрограммы, 16-битный инкремент и декремент, PUSH, загрузка SP и условные возвраты стали на такт медленнее.

<p>8085 имеет встроенный последовательный порт ввода-вывода и улучшенную поддержку работы с прерываниями: в добавок к зависящему от внешнего контроллера способу, унаследованному от 8080, добавлена подддержка трех маскируемых и одного немаскируемого прерывания &ndash; это позволяет, при необходимости, обходиться без отдельного контроллера прерываний в системе. Работа с портом и с управлением прерываниями реализуется через инструкции SIM и RIM &ndash; только эти две новые инструкции были официально документированы. Однако, само обслуживание прерываний осталось таким же как и 8080 &ndash; очень минималистическим: при прерывании процессор не сохраняет даже слово состояния, это сохранение нужно явно прописывать в коде. Как уже отмечалось, в 8085 работа со знаковой арифметикой так осталась несколько недореализованной. 16-битная арифметика также не получила поддержки некоторых очень желательных команд: сложения с переносом и вычитания. Такие команды были добавлены в Z80. В 8085 при сложении, например, 32-битных целых нужно использовать условный переход для учета переноса &ndash; это, кстати, тоже похоже на мейнфреймы IBM.

<p>Однако, могу опять повторить формулу "по неизвестным автору причинам" Intel отказалась продвигать 8085 в качестве главного процессора. Только в 80-е появилось несколько довольно успешных систем на базе 8085. Первым в 1981 появился предшественник и почти конкурент IBM PC &ndash; IBM System/23 Datamaster. Затем в 1982 был выпущен очень быстрый компьютер с превосходной графикой Zenith Z-100, в котором 8085 работал на 5 Мгц. В 1983 в японской фирме Kyotronic был создан очень удачный наколенник KC-85, варианты которого производились и другими фирмами: Tandy производила TRS-80 model 100, NEC &ndash; PC-8201a, Olivetti &ndash; M-10. Всего их было выпущено возможно более 10 миллионов таких компьютеров! В СССР/РФ в начале 90-х на основе отечественного клона ИМ1821ВМ85А были попытки усовершенствовать некоторые системы, например, компьютер Вектор. Удивительно, что главным процессором марсохода Sojourner, достигшем поверхности Марса в 1997, был 8085 с частотой 2МГц! Такой успех 8085 в 80-е во многом связан с тем, что в 1979 был готов 80C85, вариант 8085 с низким энергопотреблением. Упомянутый первый реально карманный компьютер Tandy 100 мог работать до 20 часов на одной зарядке! Возможно, что если бы не ARM, то 80C85 активно использовали бы в мобильных компьютерах и в 90-е.

<p>Фактически фирма Intel дала z80 "зеленый цвет". Спустя несколько лет в битве за 16-битный рынок Intel повела себя совершенно иначе, начав тяжбу по запрещению продаж процессоров v20 и v30 в США. Интересно, что упомянутые процессоры японской фирмы NEC могли переключаться в режим полной бинарной совместимости с 8080, что сделало их самыми быстрыми процессорами архитектуры 8080.

<p>Другая тайна фирмы Intel &ndash; в отказе от публикации расширенной системы команд, включая поддержку новых флагов. Впервые она была опубликована в журнале в 1979, а затем и некоторыми из производителей этого процессора. Однако опубликованная информация о новых флагах была весьма неполной. Каковы причины такого странного отказа? Можно лишь гадать. Может Zilog тогда играл роль, подобную которую когда-то возможно играл AMD, и создавал видимость конкуренции, а 8085 мог обрушить Zilog? Может дело в желании сохранять систему команд поближе к проектируемому тогда 8086? Последнее кажется сомнительным. Intel 8086 был выпущен спустя более 2 лет после выпуска 8085 и трудно поверить, что в 1975 уже была известна система его команд. И в любом случае, совместимость как с 8080, так и с 8085 на 8086 достижима только с использованием макропроцессора, заменяя иногда одну команду 8080/8085 (POP/PUSH PSW, Jcc, Ccc, Rcc, XTHL) на несколько своих. Причем две опубликованные новые инструкции 8085 (SIM, RIM) в 8086 не реализуемы вообще. Есть мнение, что отказ произошел только из-за сложностей в поддержке переноса на код 8086 новых флагов 8085. Действительно, такой перенос с поддержкой побитовой работы со словом состояния процессора получается крайне громоздким. Но 7 из 10 новых инструкций прямого отношения к использованию новых флагов не имеют и их можно было бы публиковать без создания сложностей по совместимости с 8086. Можно ещё предположить, что в Intel остались недовольны реализацией знаковой арифметики на 8085 и решили, что лучше скрыть, чем создать почву для постоянной критики. Хотя и в этом случае, семь новых инструкций можно было публиковать, а скрыть только флаги и три инструкции.

<p>Особенно трудно объяснить, почему Intel не опубликовала информацию о новых командах уже после выпуска 8086. Можно только ещё предположить, что скорее всего дело было в маркетинге. Искусственно ухудшив спецификации 8085, получали на этом фоне более эффектный 8086.

<p>Рискну предположить ещё одну версию. 8085 было очень трудно, почти невозможно расширить до реально 16-разрядного процессора. А 6502, имея незадействованными почти половину опкодов, мог легко быть расширен до 16-бит. Поэтому для Intel было важно создать тренд на переход к 16-битной архитектуре, без совместимости с 8-битной. Отказываясь от новой полезной функциональности 8085, как бы сообщали, что 8-битки это плохо и уже неважно, надо переходить на 16-бит. Что-то похожее происходило и вокруг 32-битной архитектуры, когда Intel создала ложный тренд на разработку сложного и бесперспективного Intel 8800 или iAPX 432.


<h2 id=m680x>Motorola 6800 и близкие родственники</h2>

<p>Процессоры Motorola всегда отличались наличием нескольких очень привлекательных "изюминок" при одновременном наличие каких-то несуразных по абстрактности и малопрактичности архитектурных решений. Главная "изюминка" всех рассматриваемых процессоров &ndash; это второй полноценный и очень быстрый регистр-аккумулятор.

<p>6800 был первым в мире процессором, которому требовалось только один источник питания (5 вольт) &ndash; это было очень полезное новшество. Кроме того, на 6800 была также впервые реализована поддержка немаскируемых прерываний. Но 6800 из-за единственности громоздкого для 8-битной архитектуры 16-битного индексного регистра получился неудобным для программирования и использования изделием. Он был выпущен ещё в 1974, ненамного позже 8080, но так и не стал основой для какой-либо известной компьютерной системы. Интересно, что разработчики 6502, Чак Педдл (Chuck Peddle) и Бил Менш, называли 6800 неправильным, "слишком большим". Однако, он и его варианты широко использовались как микроконтроллеры. Возможно тут стоит заметить, что Intel производила процессоры с 1971, что поставило Motorola в положение догоняющей стороны, для которой 6800 был самым первым процессором. И если сравнить 6800 не с 8080, а с его предшественником 8008, то 6800 окажется значительно предпочтительнее. Motorola почти догнала Intel с 68000/20/30/40. Можно ещё заметить, что в 70-е Motorola была значительно более крупной компанией, чем Intel.

<p>Производились также многочисленные варианты 6800: 6801, 6802, 6803, 6805, ... Большинство из них это микроконтроллеры с встроенной памятью и портами ввода-вывода. 6803 &ndash; это упрощенный 6801 и его использовали в сильно запоздалом (1983) для своего класса компьютере Tandy TRS-80 MC-10 и его французском клоне Matra Alice, которые были сравнимы с Commodore VIC-20 (1980) или Sinclair ZX81 (1981). Система команд 6801/6803 была значительно улучшена, были добавлены 16-битные команды, умножение, ... Появилась необычная инструкция безусловного перехода (BRN &ndash; branch never), который никогда не выполняется! Некоторые инструкции стали чуть быстрее. Тут можно заметить, что архитектура 680x формировалась под сильным влиянием архитектуры PDP-11. Некоторые детали PDP-11 были скопированы скорее  механически, например, бесполезные команды CLV и SEV.

<p>680x полностью поддерживают работу с целыми числами со знаком, z80 и 6502 поддерживают её хуже, а у 8080 такой поддержки нет практически совсем. Однако в 8-битном программном обеспечении такая поддержка нужна была очень редко.

<p>6809 был выпущен в 1978, когда с 8086 уже началась 16-битная эпоха, и имеет весьма развитую систему команд, включая умножение двух байтовых аккумуляторов с получением 16-разрядного результата за 11 тактов (для сравнения, 8086 требует от 70 тактов на подобную операцию). Два аккумулятора могут в нескольких случаях группироваться в один 16-разрядный, что даёт быстрые 16-битные инструкции. 6809 имеет два индексных регистра и рекордное среди 8-битных процессоров число методов адресации &ndash; 12. Среди методов адресации есть уникальные для 8-битных чипов, такие как индексная с автоинкрементом или декрементом, относительно счётчика команд, индексная со смещением. 6809 имеет интересную возможность использовать два типа прерываний: можно использовать быстрые прерывания с частичным автоматическим сохранением регистров и прерывания с полным сохранением регистров &ndash; у 6809 есть три входа для сигналов прерывания FIRQ (быстрое маскируемое), IRQ (маскируемое), NMI (немаскируемое). Также иногда удобны в использовании быстрые инструкции чтения и установки сразу всех флагов.

<p>Однако, операции с памятью требует на такт больше, чем 6502 или 6800. Индексные регистры так и остались неуклюжими 16-битными динозаврами в 8-битном мире, некоторые операции просто шокируют своей медленностью, например, пересылка одного байтового аккумулятора в другой занимает 6 тактов, а обмен их содержимым &ndash; 8 тактов (сравните с 8080, где 16-битный обмен проходит за 4 такта)! Зачем-то предлагаются сразу два указателя стека, возможно это было влияние тупиковой архитектуры VAX-11 &ndash; в 8-битной архитектуре с 64 КБ памяти выглядит очень несуразно. И даже наличие инструкции с интересным названием SEX всех проблем 6809 устранить не может. В целом, 6809 всё же несколько быстрее 6502 на той же частоте, но требует такую же по быстродействию память. Мне удалось сделать деление для 6809 с 32-разрядным делимым и 16-разрядным делителем (32/16=32,16) за чуть более 520 тактов, для 6502 у меня не получилось добиться менее 650 тактов. Второй аккумулятор &ndash; большое преимущество, но другие возможности 6502, в частности, инвертированный перенос, сводят это преимущество только к означенным 25%. А вот умножение на 16-битною константу оказалось медленнее, чем табличное для 6502 с таблицей на 768 байт. 6809 позволяет писать довольно компактные и быстрые коды, используя адресацию установленной страницы (direct page), но эта адресация делает коды довольно путанными. Суть этой адресации в установке старшего байта адреса данных в специальном регистре и указании только младшего байта адреса в командах. Такая же система только с фиксированным значением старшего байта используется в 6502, где она называется адресацией нулевой страницы (zero page). Адресация установленной страницы &ndash; это прямой аналог использования сегментного регистра DS в x86 только не для сегментов размером 64 КБ, а для сегментиков размером всего 256 байт. Ещё одна надуманность архитектуры 6800 в использовании порядка байт от старшего к младшему (Big Endian), что притормаживает 16-битные операции сложения и вычитания. 6809 несовместим по кодам инструкций с 6800 &ndash; можно только исходники от 6800 транслировать в код 6809, что аналогично случаю с 8080 и 8086. 6809 стал последним 8-битным процессором от Motorola, в дальнейших разработках вместо него было решено использовать 68008.

<p>Можно предположить, что Motorola потратила немало средств для продвижения 6809. Это сказывается до сих пор при упоминании об этом процессоре. Про 6809 имеется много благоприятных отзывов, отличающихся некоторой туманностью, обобщениями и неконкретностью. 6809 позиционировался как 8-битный суперпроцессор для микромейнфреймов. Для него даже был сделан почти Unix, операционные системы OS-9 и UniFlex. Он выл выбран как основной процессор для Apple Macintosh и, как следует из фильмов о Стиве Джобсе, только его эмоциональное вмешательство определило переход на более перспективный 68000. Конечно, 6809 &ndash; это хороший процессор, но в целом лишь незначительно лучший своих появившихся гораздо раньше конкурентов 6502 (на три года раньше) и z80 (на два). Можно только гадать, что бы было, если бы Motorola хотя бы половину усилий потраченных на разработку и продвижение 6809 потратила на развитие 6502.

<p>6809 использовался в нескольких довольно известных компьютерных системах. Наиболее известные среди них &ndash; это американский компьютер Tandy Color или Tandy Coco, а также их британский или точнее валлийский клон Dragon-32/64. Компьютерные рынки 80-х отличала значительная нетранспарентность и Tandy Coco распространялись в основном только в США, а Драконы помимо собственно Великобритании получили некоторую популярность и в Испании. Во Франции 6809 почему-то стал основой для массовых компьютеров 80-х серии Thomson, которые так и остались практически неизвестными где-либо ещё кроме Франции. 6809 также использовался в качестве второго процессора по крайней мере в двух системах: в серии Commodore SuperPET 9000 и в очень малотиражной приставке для TUBE-интерфейса компьютеров BBC Micro. Использовался этот процессор и в других менее известных автору системах, в частности, японских. Он также получил некоторое распространение в мире игровых консолей. Стоит упомянуть одну из таких консолей, Vectrex, которая использует уникальную технологию &ndash; векторный дисплей.

<div align=center>
<p><img src=https://habrastorage.org/webt/pj/ni/vy/pjnivyjqtgxbghvmxin5c3cqceg.jpeg style=width:50%;height:auto;>
<p style=font-size:90%>Цветной КоКо 3
</div>

<p>680x имеют интересную недокументированную инструкцию с интересным названием "Остановись и поджарься" (Halt and Catch Fire &ndash; HCF), которая используется для тестирования на уровне электроники, например, осциллографом. Её использование приводит процессор к зависанию, из которого можно выйти только его перезапуском (reset). Эти процессоры имеют и другие недокументированные инструкции. В 6800 есть, например, инструкции симметричные непосредственной загрузке регистра константой, т.е. инструкции непосредственной выгрузки регистра в адрес следующий за этой инструкцией!

<p>Как и 8080, 8085 или z80 6809 очень трудно называть чисто 8-битным. А 6309 даже формально трудно назвать 8-битным, его производила японская фирма Toshiba (точный год начала его производства мне найти не удалось, но есть некоторые данные, указывающие на 1982) как процессор, полностью совместимый с 6809. Однако, этот процессор можно было переключать в новый режим, который при сохранении почти полной совместимости с 6809 предоставлял почти на порядок большие возможности. Эти возможности были скрыты в официальной документации, но были опубликованы в 1988 в сети Usenet. Были добавлены ещё два аккумулятора, но инструкции с ними существенно медленнее, чем с первыми двумя. Сильно сокращено время исполнения большинства инструкций. Добавлены ряд команд, среди которых просто фантастическое для процессоров такого класса знаковое деление 32-битного делимого на 16-битный делитель (32/16=16,16) за 34 такта, причем делитель берется из памяти. Появилось также 16-разрядное умножение с 32-разрядным результатом за 28 тактов. Были также добавлены очень полезные инструкции для быстрого копирования блоков памяти с временем исполнения 6 + 3n, где n &ndash; это число копируемых байт, копировать можно как с уменьшением, так и с увеличением адресов. Эти же инструкции можно использовать и для быстрого заполнения памяти заданным байтом. При их исполнении могут происходить прерывания. Появились ещё новые битовые операции, нуль-регистр и др. Были ещё добавлены прерывания при исполнении неизвестной инструкции и при делении на 0. В каком-то смысле, 6309 &ndash; это вершина технологических достижений среди 8-битных процессоров или точнее процессоров с размером адресуемой памяти 64 КБ.

<p>6309 полностью совместим по клеммам с 6809, что сделало его популярным апгрейдом для цветных Tandy или Драконов. Существуют и специальные версии ОС, использующие новые возможности 6309.


<h2 id=mos6502>MOS Technology 6502 и WDC 65816</h2>

<p>Это процессор с очень драматической судьбой. Ни один другой процессор в этом с ним сравниться не может. Его появление и внедрение сопровождалось очень большими по размаху и последствиям событиями. Перечислю некоторые из них: 

<p>1) ослабление фирмы-гиганта Motorola, возможности которой какое-то время превосходили возможности Intel;

<p>2) уничтожение фирмы MOS Technology;

<p>3) прекращение развития 6502 и его стагнационный выпуск практически без модернизации.

<p>Всё началось с того, что в Motorola по неизвестным вполне причинам отказались поддержать инициативного инженера, Чака Педла, предлагавшего улучшить в целом довольно посредственный процессор 6800, сделать его быстрее и, главное, значительно дешевле. Ему и пришлось покинуть компанию и продолжить свои наработки в небольшой, но перспективной фирме MOS Technology. Он смог уговорить семь других инженеров последовать за ним и только один из них впоследствии вернулся в Motorola. В MOS Technology они вскоре подготовили два процессора 6501 и 6502, сделанных по технологии NMOS. Первый был совместим по разъему с 6800, а в остальном они были идентичны. Команде 6501/6502 удалось успешно внедрить новые технологию производства чипов, что радикально удешевило новые процессоры. В 1975 MOS Technology могла предлагать 6502 за $25, в то время как стартовая цена на Intel 8080 и Motorola 6800 была в 1974 $360. В 1975 Motorola и Intel снизили цены, но они все равно были близки к $100. Специалисты MOS Technology утверждали, что их процессор до 4-х раз быстрее, чем 6800. Мне это кажется сомнительным: 6502 гораздо быстрее может работать с памятью, но второй аккумулятор 6800 очень ускорял многие вычисления. Оценочно могу предположить, что 6502 был в среднем быстрее не более, чем в 2 раза. Как следует из некоторых публикаций уже в 1975 в MOS Technology были планы проводить расширение 6502 до 16-разрядного уровня...

<div align=center>
<p><img src=https://habrastorage.org/webt/0k/rq/uh/0krquhnzypl1amzihtnktvpe_um.jpeg>
<p style=font-size:90%>MOS 6501 рвет конкурентов: Intel и Motorola уже вычеркнуты!
</div>

<p>Но Motorola начала судебный процесс против своих бывших сотрудников &ndash; те якобы использовали технологические секреты фирмы. В ходе процесса удалось установить, что один из инженеров, ушедших из Motorola, вынес некоторые конфиденциальные документы по 6800, действуя вопреки установкам своих коллег. Был ли это его собственный поступок или за ним стояли какие-то направляющие силы до сих пор неизвестно. В итоге Motorola вынудила MOS Technology, чьи финансовые возможности были весьма невелики, выплатить значительную сумму в $200000 и к отказаться от производства 6501. Intel в похожей ситуации с Zilog действовала совсем не так. Хотя надо признать, что MOS Technology действовола иногда слишком рисковано, когда пыталась использовать большие деньги, потраченные Motorola на продвижение 6800, в своих целях. Ирония ситуации заключается в том, что, как отмечал лидер команды разработчиков 6502, они с 6501 просто хотели сделать "предупредительный выстрел" и посмотреть, что из этого получится. Цели предлагать использовать 6501 вместо 6800 не было. Тут ещё можно заметить, что 6501 был всё же не совсем совместим с аппаратурой для 6800, он и 6502, в частности, не поддерживал работу с тремя состояниями выводов и поэтому не мог использоваться напрямую, например, с аппаратурой с прямым доступом к памяти, как 6800.

<p>Мы до сих пор в точности не знаем, почему Motorola выиграла тяжбу с MOS Technologies. Возможно просто у MOS Technologies закончились деньги, их на процесс было потрачено до $800000, а деньги тогда были в несколько раз весомее, чем сейчас. Хотя были и другие факторы. Вроде упомянутого выноса документов. Известно ещё, что, например, чип параллельного интерфейса 6520, производимый в MOS Technology, был точной копией Motorola 6820. Всем, кто ушёл из Motorola, пришлось подписать своё согласие с решением по иску, так как перед началом процесса они подписали бумагу с тем, что они признают любой его результат.

<p>Далее в истории появляется легендарная фирма Commodore и её не менее легендарный основатель Jack Tramiel, в тени которого находилась фигура главного финансиста фирмы, определяющего её политику &ndash; человека по имени Irving Gould. Джек получил кредит у Ирвинга и на эти деньги, используя несколько, мягко сказать, недобросовестную тактику, вынудил MOS Technology стать частью Commodore. После чего, возможно и вопреки желанию Трамела, вынужденного уступать Гуду, разработка 6502 практически остановилась и это при том, что ещё в 1976 удалось произвести опытные образцы 6502 с рабочими частотами до 10 МГц, хотя сообщение об этом появилось только спустя многие годы от человека по имени Bill Mensch (он был в команде, покинувшей Motorola), который не раз делал громкие, но по большому счету пустые заявления и сыграл в судьбе 6502 довольно неоднозначную роль. Чак Педдл навсегда был отстранён от разработки процессоров. Работать с 6502 продолжили не только в Commodore, но и в фирме, созданной Биллом Меншем, Western Design Center (WDC). Любопытно, что никто из прежней команды 6502 не работал с ним в дальнейшем. Кстати, это именно Бил Менш разработал упомянутый выше 6820, который превратился в 6520.

<p>На этом драма вокруг 6502 не закончилась. В 1980 в журнале AIM65 Interactive фирмы Rockwell появилась короткая анонимная статья, о том, что все 6502 несут в себе опасного бага, который получил название JMP (xxFF). Тон статьи предполагает, что-то совершенно из ряда вон выходящее. Впоследствии этот настрой перешёл в позицию фирмы Apple по этому вопросу и стал неким мейнстримом. Хотя никакого "бага", строго говоря, не было. Конечно, специалисту, привыкшему к комфортным процессорам больших систем тех лет, одна из особенностей, вполне уместных и даже полезных среди микропроцессоров, могла показаться чем-то раздражающим, багом. Но на самом деле это, задевшее чьи-то чувства, поведение было описано в официальной документации от 1976 года и в учебниках по программированию, вышедших до появления упомянутой статьи. "Баг" был ликвидирован Билом Меншем, сделавшим 65С02 (CMOS 6502) в сотрудничестве с Apple предположительно к 1983. Автор этого материала сам сталкивался несколько раз с проблемой этого "бага". Ничего не зная о нем, писал программы для Коммодоров. Потом одну из них перенес на системы, где использовался набор команд 65С02. Возникла несовместимость, пришлось менять коды, делать условную компиляцию. Код для 65С02 получился более громоздким и медленным. Потом поднимал этот вопрос на форуме 6502.org, где большинство участников из мира Apple. Спросил, может ли кто-нибудь привести пример, когда означенный "баг" рушил программу. Получил только эмоциональные и общие замечание, конкретного примера так и не было предложено. Иронично, что в официальной документации WDC "баг" не называют прямо багом, а скорее какой-то странностью, вывертом.

<div align=center>
<p><img src=https://habrastorage.org/webt/f-/8q/mv/f-8qmv2x4io6ga8qxomqg0dxqnw.png style=width:50%>
<p style=font-size:90%>Баг!!!
</div>

<p>В то время как Intel, Motorola и другие сделали уже 16-битные процессоры новых поколений, 6502 был лишь микроскопически улучшен и сделан искусственно частично несовместимым с самим собой. Даже если сравнивать улучшения , сделанные в Motorola 6801 по сравнению с 6800 или в Intel 8085 по сравнению с 8080, то они окажутся гигантскими по сравнению с теми, что были сделаны в 65C02. Кроме того, Intel и Motorola сделали их значительно раньше. В 65C02 был сделан ряд небольших изменений, которые, в частности, привели к изменению в ходе исполнения нескольких инструкций, которые стали медленнее на такт, но при этом в каком-то надуманном академическом смысле они стали более правильными. Речь идёт об упомянутом "баге" и инструкциях десятичной арифметики. Последние были "скорректированы" так, что флаги oVerflow, Negative и Zero стали работать "корректно". Однако, при работе с десятичными числами на 6502 (и других микропроцессорах) знак не поддерживается и соответственно флаги N и V не имеют для них никакого смысла. Только коррекция флага нуля имеет какой-то смысл, но крайне незначительный. Были также добавлены десятки новых инструкций, абсолютное большинство которых лишь занимали кодовое пространство, почти ничего не добавляя к возможностям 6502, что оставляло меньше кодов для возможных дальнейших модернизаций. Но, надо признать, что несколько новых инструкций оказались ожидаемыми и полезными, например, BIT с новыми адресными режимами и <code class=code>JMP (ABX,X)</code>. И опять надо признать, что новые инструкции позволяют получать чуть-чуть более быстрые и компактные коды. Кроме того, четыре сравнительно редкие инструкции стали на 65C02 иногда на такт быстрее. Можно ещё добавить, что 65C02 стал занулять флаг десятичного режима при прерывании, что позволяет иногда делать обработчик прерываний на 2 цикла быстрее и на 1 байт короче &ndash; это крошечное улучшение хорошо иллюстрирует общий объем улучшений, сделанных в 65C02.

<p>65C02 был лицензирован многим фирмам, в частности, NCR, GTE, Rockwell, Synertek и Sanyo. Он использовался в Apple II, начиная с моделей IIe, хотя многие IIe использовали NMOS 6502. Вариант 65С02 6512 использовался также в поздних моделях BBC Micro. Atari использовала NMOS 6502. Фирмы Synertek и Rockwell помимо CMOS 6502 производили и NMOS 6502. Кстати, NMOS 6502 имеет свой набор недокументированных инструкций, природа которых совершенна отлична от "секретных" команд 8085. В 6502 эти инструкции появились как побочный эффект, поэтому большинство из них скорее бесполезны, но несколько, например, загрузка или выгрузка одной командой сразу двух регистров и некоторые другие могут сделать код более быстрым и компактным.

<p>Интересно, что NMOS 6502, совместимого с 65C02, так и не сделали. Хотя в начале 80-х технология CMOS не имела явных преимуществ (кроме пониженного энергопотребления) перед NMOS и её развитием HMOS и при этом была заметно дороже. Стоит конечно заметить, что WDC смогла создать CMOS процессор всего лишь спустя несколько лет после того, как Intel и Motorola сделали CMOS варианты своих процессоров 8085 и 680x. В этом она значительно опередила Zilog, где CMOS вариант Z80 был создан только к 1987 году. Однако, если CMOS 8085 и Z80 сразу нашли широкое употребление в мобильных компьютерах, то низкое энергопотребление 65C02 нашло свое применение в компьютерах сравнительно поздно, могу назвать лишь игровую консоль <a href=https://ru.wikipedia.org/wiki/Atari_Lynx>Atari Lynx</a>, производившуюся с 1989. Стоит ещё заметить, что само по себе внедрение технологии CMOS &ndash; это вполне рутинный процесс, через который другие процессоры (x86, 68k, ...) прошли практически незаметно.

<p>Были и другие попытки модернизировать 6502. В 1979 появилась статья, что для компьютеров Atari готовится к производству процессор 6509 (не путать с появившимся позже процессором с таким же названием фирмы Commodore), в котором ожидалось ускорение исполнения команд на 25% и много новых инструкций. Но по неизвестным в точности причинам производство этого процессора так и не состоялось. Commodore проводила лишь микроскопические модернизации. С точки зрения программирования самым интересным является процессор 6509, который пусть и в очень примитивной форме с помощью всего двух специально выделенных для этой цели инструкций и двух байт нулевой страницы позволяет адресовать до 1 МБ памяти. В сверхпопулярных Коммодорах 64 и 128 стояли процессоры 6510/8510, а в менее удачливых серии 264 &ndash; 7501/8501. Эти процессоры имели лишь соответственно 6 и 7 встроенных битовых портов ввода-вывода, при этом 7501/8501 не поддерживали немаскируемых прерываний. Кроме того, на этих процессорах реализовали поддержку с логикой трех состояний, что было необходимо для работы с видеоконтроллерами на C64 и C264. Фирма Rockwell производила вариант 65C02 со своим расширенным 32 битовыми операциями (похожи на битовые инструкции z80) набором инструкций, однако, насколько мне известно, в компьютерах такие процессоры не использовались и сами эти битовые инструкции имели значение скорее только для использования во встроенных системах. Это расширение, кстати, тоже произвёл Билл Менш. Получается, что Билл работал над 6502, только имея конкретные заказы, и никогда не пытался сам в чем-то этот процессор улучшить.

<p>Последняя сцена драмы с участием 6502 обозначилась в недопущении компьютеров на базе 6502 с частотой 2 МГц на рынок США в первой половине 80-х. Это коснулось иностранца-англичанина BBC Micro, их производившая фирма Acorn сделала большую партию компьютеров для США, но, как оказалось, зря. Сработала какая-то блокировка и компьютеры пришлось срочно переделывать под европейские стандарты. Полуамериканские, но формально канадские компьютеры Commodore CBM II (1982), несмотря на некоторые проблемы (в частности, по соответствию стандартам на электрооборудование), были всё же допущены. Возможно из-за того, что у них не было графических режимов и даже цветного текста &ndash; этого не мог компенсировать даже стильный Porsche-дизайн. Последним в списке неудачников оказался 100% американский Apple III (1980) &ndash; известно, что Стив Джобс, как и менеджмент Apple в целом, сделали много, чтобы этот этот компьютер не состоялся. Джобс требовал явно невыполнимых спецификаций, а менеджмент &ndash; нереальных сроков. Узнаем ли мы когда-нибудь их мотивы? В Apple III Plus, выпущенном в 1983, удалось устранить недостатки Apple III, но менеджмент Apple тихо закрыл проект в 1984 из-за нежелания иметь конкуренцию с компьютером Macintosh. Только в 1985, когда эпоха 8-битной техники начала уходить, появился Commodore 128, который мог использовать в одном из своих режимов 6502 с тактом на 2 МГц. Но и тут получился скорее анекдот, так как этот режим практически не поддерживался и программ для него практически нет. Только во второй половине 80-х в США стали производить приставки-ускорители для Apple II, а с 1988 и модель Apple IIc+ c процессором на 4 МГц. Почему так случилось? Возможно потому, что 6502 на 2 или 3 МГц (а такие уже производились в самом начале 80-х) на ряде задач и в особенности с играми могли успешно конкурировать с системами на основе Intel 8088 или Motorola 68000. В 1991 волевым решением корпорация Commodore закрыла интересный, хотя и запоздалый проект С65 на базе процессора 4510 с частотой 3.54 МГц. Чип 4510 был сделан на основе процессора 65CE02, который в свою очередь сделан на основе WDC 65C02. 65CE02 &ndash; это самый быстрый 6502, сделанный только в 1988, в нём была проведена наконец упоминавшаяся раннее оптимизация циклов, давшая 25% прирост скорости. Таким образом, процессор в С65 по быстродействию близок к системам с 6502 на 4.5 МГц. Удивительно, но этот самый быстрый 6502 с расширенным набором инструкций (в каких-то деталях это расширение получилось более удачным, чем в 65816) нигде с тех пор так и не нашёл применения.

<p>C128 и Apple III Plus имели блок управления памятью (MMU), что позволяло использовать несколько стеков и нулевых страниц, адресовать более 64 КБ памяти, и др. В C128 MMU был искусственно урезан для работы только со 128 КБ памяти. Для BBC Micro выпускались приставки с 6502 на 3 Мгц (1984) и 4 МГц (1986).

<div align=center>
<p><img src=https://habrastorage.org/webt/fk/df/-y/fkdf-y4eoanu06-zbqxo_k1gzli.jpeg style=width:50%>
<p style=font-size:90%>Антиреклама &ndash; множественные Porsche PET в апартаментах злодея из Жемчужины Нила (1985) &ndash; эра "только Apple" в Голливуде ещё не наступила
</div>

<p>Теперь несколько слов о системе команд 6502. Главная особенность этого процессора в том, что его сделали почти максимально быстрым, практически без лишних тактов, которых особенно много в процессорах 8080/8085/z80/8088/68000. Фактически это была идеология появившихся позднее и под прямым влиянием 6502 процессоров архитектуры ARM. Эта же идеология доминирует, начиная с 80486, и среди процессоров Intel. Кроме того, 6502 максимально быстро реагировал на прерывания, что делало его очень полезным в некоторых встроенных системах. У 6502 один аккумулятор и два индексных регистра, кроме того первые 256 байт памяти можно использовать в специальных командах либо как более быструю память, либо как набор 16-разрядных регистров (которые почти идентичны по своей функциональности регистрам BC и DE в 8080/z80) для довольно мощных способов адресации. Некоторые арифметические команды (сдвиги, вращение, инкремент и декремент) можно использовать с памятью непосредственно, не используя регистры. 16-разрядных команд нет &ndash; это 100% 8-битный процессор. Поддерживаются все основные флаги кроме характерного архитектуре Intel флага чётности. Есть ещё несколько необычный флаг малополезного 10-го режима, который заменил флаг полупереноса, используемый большинством других процессоров. Процессоры Intel, Zilog и Motorola используют специальные корректирующие инструкции для работы с десятичными числами, а 6502 может переключаться в 10-й режим, что делает его преимущество по скорости с 10-ми числами ещё более значительным, чем с двоичными. Очень впечатляет наличие для 6502 табличного умножения 8-битных операндов с получением 16-битного результата за менее, чем 30 тактов, при размере вспомогательной таблицы в 2048 байт. 6502 использует простейший конвейер инструкций, который позволяет ускорить время исполнения многих инструкций на 1 такт. Медленнее всего у 6502 получаются операции массового копирования памяти &ndash; от 14 тактов на байт. Система инструкций 6502 в некоторых частностях необычно асиммeтрична, например, есть инструкция загрузки регистра Y <code class=code>LDY addr,X</code>, но нет парной ей выгрузки &ndash; <code class=code>STY addr,X</code>. Есть инструкция для сброса флага переполнения, но нет парной ей для его установки. 6502 вместо этой инструкции позволяет делать установку флага переполнения через аппаратный сигнал. Такая работа с флагом переполнения позволяет использовать очень быстрый порт ввода, но для программирования арифметики как установка этого флага, так и его сброс бесполезны. Поэтому в 6510 или 7501/8501 отказались от специального способа установки флага переполнения, но совсем бесполезная теперь инструкция для его сброса осталась!

<p>Самым главным недостатком 6502 считается маленький стек, всего 256 байт. Однако для системы с объемом памяти 64 КБ этого, как показала практика, обычно вполне достаточно. В 6502 мало регистров и поэтому нагрузка на стек меньше, чем, например, у 8080, 6809 или Z80. Кроме того, архитектура 6502 естественно предполагает организацию добавочного стека на нулевой странице &ndash; такой стек особенно хорош при работе с указателями, так как адресация типа (zp,X) идеально подходит для таких случаев. Конечно, размер такого добавочного стека очень ограничен и на многих системах не может быть больше нескольких десятков байт.

<p>Поддержка аппаратных прерываний на 6502 реализовано просто и эффективно. Для маскируемых и немаскируемых прерываний в памяти выделяется два фиксированных адреса, куда записываются адреса соответствующих обработчиков. Примерно так же, но ещё проще, позднее сделали самый популярный режим 1 прерываний в Z80. А вот программные прерывания в 6502 сделаны совсем примитивно: они используют адрес для маскируемых прерываний, что требует громоздких дополнительных программных проверок для их различения. Именно для этого среди флагов 6502 присутствует уникальный флаг программного прерывания. Кроме того, у инструкции программных прерываний нет аргумента, хотя такой аргумент можно добавлять ценой усложнения процедуры обработчика. Из-за того, что возможность для обработки программных прерываний значительно замедляет обработку аппаратных, поддержка программных прерываний довольно часто просто не реализуется.

<p>6502 может работать параллельно с другим устройством, например, другим 6502. Такие двухпроцессорные системы встречались крайне редко. В качестве примера таких систем мне известны только несколько весьма редких моделей дисководов Commodore. Вместо второго процессора обычно использовался видеоконтроллер, который использовал общую с 6502 память.

<p>65816 был выпущен WDС в 1983. Это был первый случай, когда был сделан 16-битный процессор, совместимый со своим 8-битным предшественником, &ndash; для Z80 подобные разработки (Z800, Z180, Z380, eZ80, ...) стали появляться только с 1985. Кроме того, это был один из первых 16-битных процессоров, изготовленных по технологии CMOS! Интересно, что спецификации нового процессора Билл Менш получил от Apple. Конечно, это был большой шаг вперёд, но явно запоздалый и с большими архитектурными изъянами. 65816 уже никем не рассматривался как конкурент для основных процессоров Intel или Motorola &ndash; это уже был второстепенный аутсайдер, который уже как-то запрограммировано был настроен на дальнейшую потерю позиций. 65816 имел два важных плюса &ndash; он был сравнительно дешёв и почти совместим с по-прежнему весьма популярным 6502. В последующие годы Бил Менш даже не пытался как-то улучшить своё детище, сделать оптимизацию циклов, заменить адресацию нулевой страницы расширенной с использованием регистра Z (это было сделано в 65CE02), добавить хотя бы умножение, ... WDC только повышала предельные тактовые частоты, дойдя к середине 90-х до 14 МГц (такой процессор использовался в популярном ускорителе для С64 SuperCPU на частоте 20 МГц). Однако даже сейчас (2020!) WDC предлагает 65816 почему-то только на тех же 14 МГц. 65816 может использовать до 16 МБ памяти, но используемые для этого методы адресации выглядят далёкими от оптимальных. Например, индексные регистры могут быть только 8- или 16-разрядными, стек можно помещать только в первые 64 КБ памяти, только там же можно использовать удобную короткую адресацию установленной страницы (direct page &mdash; обобщение zero page), работа с памятью выше более 64 КБ сравнительна неуклюжа, ... 65816 имеет 16-разрядное АЛУ, но 8-разрядную шину данных, поэтому на арифметических операциях он лишь примерно на 50% быстрее чем 6502. Тем не менее 65816, по словам Билла Менша, был выпущен в количестве более миллиарда. Конечно, ряд команд 65816 явно дополняют пробелы в архитектуре 6502, например, команды массового копирования памяти за 7 тактов на байт, а также адресные режимы для работы со стеком. Можно ещё добавить, что 65816 использует почти все коды инструкций (255 из 256). Последний неиспользованный код предназначен для длинных будущих инструкций, которые так и не появились.

<p>Apple IIx, в разработке которого активное участие принимал Стив Возняк, должен был использовать 65816, но наладить производство этого процессора удалось только в 1984 и первые партии 65816 были бракованными, что вызвало чрезмерные задержки и в итоге закрытие всего проекта.

<p>Есть ещё вариант 65816 65802, который использует 16-разрядную шину адреса и совместим по разъему с 6502. Предлагались апгрейды для Apple II на основе этого процессора, но ускорения с таким апгрейдом возможно получить только на специально для него написанных программах.

<p>6502 использовался в большом числе компьютерных систем, самые популярные из которых &ndash; это 8-битные Commodore, Atari, Apple, Acorn, NES. Commodore PET, в разработке которого активное участие принимал Чак Педдл, появился в продаже на полгода раньше Apple ][, хотя его массовое производство наладилось только на полгода позже Apple ][. Он и его варианты стали первыми компьютерами широко использовавшимся в школах США и Канады &ndash; можно только удивляться, почему Commodore так легко сдала свои позиции Apple в этом бизнесе. Также удивительно, что Commodore легко сдала свои неплохие позиции в бизнесе редактирования текстов, где впоследствие Amstrad добилась впечатляющих успехов. А ещё раньше Commodore по до сих пор неясным причинам покинула рынок калькуляторов. Также по неясным причинам произошел отказ от производства очень перспективного лаптоп-компьютера Commodore LCD. Однако, Commodore VIC-20 стал первым домашним компьютером, продажи которого превзошли миллион штук. Commodore 64 стал самым массовым ПК в истории, их было продано до 17 миллионов штук. Игровые консоли Atari, производимые с 1977 до 1996, были проданы в количестве примерно 35 миллионов! Но это не рекорд, японских игровых консолей NES было продано около 62 миллионов в период с 1983 по 2003. Кстати, в NES использовали вариант 6502 фирмы Ricoh без поддержки десятичного режима. Возможно из-за его почти полной бесполезности, но возможно просто из-за нежелания связываться с патентом MOS Technology на этот режим. Можно наверное утверждать, что для большинства пользователей до конца 80-х дверью в мир цифровых технологий был именно 6502. 6502 использовался в качестве контроллера клавиатуры в компьютере Commodore Amiga, а два 6502 на 10 МГц использовались в высокопроизводительном Apple Macintosh IIfx. Процессор на основе 6502 используется в известной игрушке <a href=https://ru.wikipedia.org/wiki/%D0%A2%D0%B0%D0%BC%D0%B0%D0%B3%D0%BE%D1%87%D0%B8>Томагочи</a>, выпущенной наверное в более сотни миллионов экземпляров. 65816 применялся в довольно популярном компьютере Apple IIgs, а также в редком английском компьютере Acorn Communicator. Игровые консоли Super NES на базе 65816 производились с 1990 по 2003, их было продано около 50 миллионов. 65816 использовался также в некоторых ранних моделях электронных книг.

<p>Интересно, что из трех массовых ПК (так называемая "святая троица"), появившихся в 1977, два были на 6502 и только один на Z80. К сожалению, важнейшие американские производители компьютеров (Apple, Tandy RadioShack, IBM), начиная с 80-х не публиковали информацию о числе произведенных ими ПК.

<p>В 1984 в журнале Byte на фоне картинок с красными знамёнами, Лениным и марширующими солдатами появилась <a href=https://habr.com/post/371693/>статья</a> о плохой копии компьютера Apple ][, сделанной в СССР. В этой статье приводилась любопытная цена на этот компьютер &ndash; $17000 (это абсурдное число, реальная цена была примерно 4000 руб.) и иронично указывалось на то, что советским производителям придётся сильно (dramatically) понизить цену, если они захотят продать своё изделие на Западе. Агат использовался в основном в школьном образовании. Старшие модели Агатов были почти на 100% совместимы с Apple ][ и имели некоторые довольно полезные расширения. 

<p>Можно лишь попытаться фантазировать на тему о том, что бы было, если бы 6502 смог развиваться теми же темпами, что и его конкуренты. Мне кажется, что постепенный перенос памяти нулевой страницы в регистры, улучшение конвейра инструкций и постепенное расширение системы команд с одновременной оптимизацией циклов, позволило бы "терминатору" 6502 оставаться в лидерах по быстродействию до начала 90-х. Введение режима 16, а затем 32 бит позволило бы использовать большие объемы памяти и более быстрые команды. Смогли бы его конкуренты что-то этому противопоставить?

<p>Билл Менш смог обеспечить некоторую поддержку развитию 6502. Однако возможностей одного человека для поддержки конкурентоспособности процессора явно недостаточно. Билл, как превосходный инженер-электронщик, смог обеспечить поддержку исполнения заказов на модернизацию 6502, но обеспечение независимой разработки успешного процессора требовало команды. Кому-то надо было заниматься разработкой модернизации системы инструкций, кому-то разрабатывать новые маркетинговые стратегии и т.п. Кроме того, для разработки были потеряны, как минимум, 1976-78 годы и одному человеку наверстать упущенное было уже не под силу. В каком-то смысле, WDC создала иллюзию благополучия вокруг ситуации с развитием 6502 и это имело для реального развития скорее негативный эффект.

<p>Хотя сам Чак Педдл видел будущее 6502 скорее как дешевого контроллера и конкурента не для Z80, а скорее для микроконтроллеров типа Intel 8048 и процессоров типа 6800, которые обычно использовали только как контроллеры. В 2014 он работал над твердотельным накопителем, в котором использовал 10 штук контроллеров на основе 6502. В начале 80-х он вместе с компаньоном создали компанию, в которой он в 1981 разработал компьютер Victor 9000. В качестве процессора там использовался 8088 &ndash; Чак считал, что 6502 для персонального компьютера будет не лучшим выбором.

<p>Интересно, что сам Чак как и некоторые другие ключевые фигуры ИТ США 1970-х и 1980-х пошел работать с высокие технологии с идеей предотвратить отставание от СССР в развитие ИТ. Эта идея была весьма популярна после запуска Спутника. Тут можно ещё упомянуть ключевую для Intel фигуру Билла Давидова (Bill Davidow), которого Чак очень уважал и с которым поддерживал контакт.

<p>Чака не стало в конце 2019. Он учился у Клода Шеннона и первым предложил использовать групповое кодирование при работе с дисками. Хотя запатентовать это у него не получилось, он в конце 70-х и начале 80-х разработал дисководы, которые позволяли использовать до двух раз больше места, чем типовые. Это, в частности, использовалось в некоторых лучших дисководах Commodore и в компьютере Victor. Затем он сделал первый портативный жесткий диск. Этот диск не ломался, если падал на пол! Затем он работал с производством недорогого ОЗУ. После чего он разрабатывал сверхбыстрый твердотельный накопитель, о котором уже упоминалось.

<p>Хочется закончить некоторыми общефилософскими рассуждениями. Почему 6502 был приторможен и лишен гораздо более яркого будущего? Возможно из-за того, что он реально мог очень потеснить крупные фирмы и создать совершенно новую реальность. Но была ли команда 6502 настроена на такое? Скорее нет, они просто хотели сделать лучший процессор. Возможно они сами не поняли насколько удачным был их процессор и что скорость это главное свойство любого процессора.

<p>Уже гораздо позже, в начале 21-го века при помощи навязанных надуманными причинами судебных процессов была разгромлена фирма Lexra, производившая в течении 5 лет различные инновационные процессоры. Эта печальная история, чем-то напоминает то, что случилось с MOS Technology.
 

<h2 id=z80>Zilog Z80</h2>

<p>Этот процессор стал наряду с 6502 основным процессором первых персональных компьютеров. В истории его появления и использования нет никаких насыщенных драматизмом событий. Есть только некоторая интрига в неуспехе Zilog сделать следующее поколение процессоров. Z80 начали производить в 1976 и его варианты производят до сих пор. Когда-то даже сам Билл Гейтс объявил о поддержке систем на основе z80.

<p>Интересны ряд совпадений. Как и в случае с 6502, главный разработчик Z80, Федерико Фаггин (Federico Faggin), ушёл из крупной компании, из Intel. После работы над z80 Федерико уже почти не работал с процессором следующего поколения Z8000 и в начале 80-х ушёл из основанной им компании, чтобы в дальнейшем уже никогда процессорами не заниматься. Он создал затем несколько относительно успешных стартапов, создавая системы связи, тачпады и цифровые камеры. Можно упомянуть, что, помимо z80, в Zilog им ещё был разработан удачный и производимый до сих пор микроконтроллер Z8.

<p>Z80 &ndash; это более удобный для включения в компьютерные системы процессор, чем 8080. Он требует только одного напряжения питания и имеет встроенную поддержку регенерации динамической памяти. Кроме того, он при полной совместимости с 8080 имеет довольно много новых команд, второй набор основных регистров и несколько совершенно новых регистров. Любопытно, что в Zilog отказались от использования мнемоник ассемблера 8080, а стали использовать свои собственные мнемоники, более подходящие для расширенной системы команд z80. Подобная история случилась с ассемблером Intel x86 в мире программного обеспечения GNU, там тоже почему-то используют по умолчанию свои собственные соглашения по записи программ на ассемблере. В Z80 добавили поддержку флага переполнения, Intel официально добавила поддержку такого флага только в 8086. Однако, этот флаг в z80 совместили с флагом чётности, поэтому одновременно, как в 8086, оба флага использовать не получится. В z80, как и в 6502, есть только базовая проверка значения одного флага, т.е. нет проверок сразу двух или трех флагов, что необходимо для беззнаковых сравнений "строго больше", "меньше или равно", а также всех знаковых &ndash; в таких случаях приходится делать несколько проверок, на 8086, 6800 или PDP-11 достаточно одной.

<p>Среди новых команд z80 особенно впечатляют команды массового копирования памяти за 21 такт на байт, а также интересная команда поиска байта в памяти. Добавили также похожие блочные инструкции для ввода и вывода. Однако наиболее интересна команда EXX, меняющая местами содержимое 48 байт регистровой памяти, регистры BC, DE, HL с их двойниками, которая выполняется всего за 4 такта! Даже 32-битным ARM понадобится на примерно такую же операцию не менее 6 тактов. Остальные добавочные инструкции не так впечатляют, хотя иногда могут быть полезными. Добавлены ещё:

<ul>
<li>16-битное вычитание c заемом и 16-битное сложение с переносом за 15 тактов;
<li>унарный минус для аккумулятора за 8 тактов;
<li>возможность читать из памяти и писать в неё, используя регистры BC, DE, SP, IX, IY, а не только HL;
<li>сдвиги, вращения и ввод-вывод для всех 8-битных регистров;
<li>операции проверки, установки и сброса бита по его номеру;
<li>перемещаемые переходы по смещению (JR): безусловный и по флагам переноса и равенства;
<li>команда цикла;
<li>очень необычные инструкции для десятичных вращений RLD и RRD, похожие на которые были разве что у IBM мейнфреймов;
<li>инструкции для ввода и вывода, работающие через индексный регистр.
</ul>

<p>Всего к 244 инструкциям 8080 было добавлено 458 новых инструкций, а если считать те, которые впоследствии были признаны как почти официальные, то получится ещё около полусотни новых инструкций.

<p>Большинство новых команд довольно медленные, но их правильное использование может все же сделать код несколько быстрее и существенно компактнее. Это особенно относится к использованию новых 16-разрядных регистров IX и IY, которые можно использовать для новых методов адресации. Интересно, что индексные регистры IX и IY появились в Z80 с целью привлечь пользователей 6800 к переходу на Z80! В операциях с этими индексными регистрами всегда надо использовать байтовое смещение, что не всегда необходимо, но всегда замедляет эти и без того небыстрые инструкции.

<p>Многие команды 8080 в z80 стали на такт быстрее и это очень заметное ускорение. Но основная для 16-битной арифметики команда ADD стала на такт медленнее. Также стали медленнее команды <code class=code>LD SP,HL</code>, <code class=code>EX (SP),HL</code>, инкремент и декремент с памятью и 16-разрядными регистрами, а также операции ввода и вывода. Поэтому коды 8080 выполняются на z80 если и быстрее, то только чуть-чуть. Однако, если реализовывать одинаковый алгоритм для 8080 и Z80, то Z80 может быть значительно быстрее, например, расчет числа &pi; по алгоритму-затвору для Z80 у меня получился почти на 40 процентов быстрее, чем для 8080.

<p>В Z80 добавили поддержку уникального флага, который не встречается больше ни в одной системе. Это флаг вычитания. Он используется только командой десятичной коррекции DAA, которую на Z80 можно использовать и после вычитания.

<p>Другая уникальная особенность Z80 &ndash; это общедоступный регистр регенерации памяти. Его можно, например, использовать для генерации случайных чисел.

<p>Система работы с прерываниями стала разнообразнее имеющейся у 8080. С z80 можно использовать как немаскируемые прерывания, так и три способа для работы с маскируемыми:
<ul>
<li>такой же как и у 8080 &ndash; требует контроллера прерываний совместимого со стандартом 8080;
<li>по фиксированному RST &ndash; это самый простой, ему не требуется поддержка внешних схем;
<li>в режиме 2 процессор задаёт старший байт обработчика прерываний, а контроллер определяет младший байт &ndash; этот способ требует аппаратной поддержки дополнительных чипов от Zilog.
</ul>
Однако, прерывания в режиме 2 можно использовать и без поддержки контроллера, просто резервируя 257 байт в памяти под адрес прерывания. Так делают на компьютерах, где аппаратура не поддерживает режим 2, например, на Amstrad CPC/PCW, MSX, ZX Spectrum, ... Это, конечно, несколько затратно, но необходимость в этом может возникнуть в случаях подобных ZX Spectrum, когда вектор прерывания режима 1 находится в ПЗУ. Любопытно, что в некоторых компьютерах MSX можно использовать и прерывания режима 0 без поддержки контроллера.

<p>Работа с прерываниями у Z80 имеет и другие уникальные особенности. Как известно, Z80 как и 8080 при прерываниях не сохраняет слова состояния процессора, но z80 тем не менее имеет целых две уникальные команды для возврата из прерываний. Инструкция возврата из маскируемого прерывания RETI работает также как и обычный возврат из подпрограммы, но её должны заметить как особенную внешние схемы управления и произвести сброс установки прерывания. В других архитектурах (6502, х86, ...) в коде обработчика прерываний нужно явно прописывать команды сброса контроллера, типа <code class=code>MOV AL,20H</code> и <code class=code>OUT 20H,AL</code> для x86. Однако, работа с командой RETI должна иметь поддержку у внешних чипов Zilog, и на известных компьютерах (в частности, ZX Spectrum, MSX, Amstrad CPC/PCW, Tandy TRS-80 model 1/3/4) такого нет. Другая уникальная инструкция &ndash; это RETN для возврата из немаскируемого прерывания. Она также работает как и обычный возврат из подпрограммы, но с небольшим дополнительным эффектом &ndash; она восстанавливает сохраненный при старте немаскируемого прерывания флаг разрешения маскируемых прерываний. Это информация из официальной документации, которая не может не вызвать вопросов. Как, например, быть, если случится вложенное немаскированное прерывание? Согласно последним данным z80 работает проще и логичнее, а в официальной документации допущена ошибка. Z80 после выхода из любого прерывания по команде RETN или RETI всегда восстанавливает флаг разрешения маскируемых прерываний, хотя для RETI это и неважно. Однако, процессор не сохраняет этого флага при старте немаскируемого прерывания.

<p>По непонятным мне причинам компьютеры на базе Z80 обычно не использовали схемы управления прерываниями с полной поддержкой возможностей этого процессора. Возможно из-за цены. Хотя это получается как-то необычно. Дешевый процессор и дорогие схемы поддержки. Как будто Zilog был нацелен на производство только Z80. Для Z80 производились фирменный таймер, параллельный и последовательный интерфейсы, чип DMA и другие подобные устройства, но их в популярных компьютерах не использовали. Применяли их только в некоторых моделях сравнительно редких и дорогих офисных систем, например, Tandy TRS-80 model 2, Tatung Einstein или Robotron 1715.

<p>Z80 имеет довольно много недокументированных инструкций, многие из этих инструкций пропали при переходе на технологию CMOS, но те которые сохранились стали фактически стандартными и были документированы некоторыми фирмами. Особенно полезны инструкции, позволяющие работать с отдельными байтами неуклюжих 16-битных регистров IХ и IY. Кроме недокументированных инструкций Z80 имеет и другие недокументированные свойства, например, два особых флага в регистре состояний.

<p>Конечно, z80 ещё в большей степени, чем 8080 имеет право называться слегка 16-битным. Гипотетический индекс разрядности у z80 явно чуть-чуть повыше, но при этом парадоксально, что АЛУ у z80 на самом деле 4-битное! На электронном уровне z80 и 8080 &ndash; совершенно разные чипы.

<p>16-ые операции остались у Z80 не вполне реализованными, хотя возможно это случилось из-за необходимости поддержания совместимости с 8080. В частности, очень неудобно, что 16-ые инкремент и декремент вообще не меняют флагов.

<p>Конечно, Z80 может дать немало других оснований для критики. Помимо унаследованных от 8080 пустых инструкций типа <code class=code>LD B,B</code> в Z80 появились ещё более бессмысленные инструкции-двойники, т.е. более большие и медленные клоны имеющихся инструкций, это длинные <code class=code>LD HL,(nn)</code> и <code class=code>LD (nn),HL</code>, а также <code class=code>RLC A</code>, <code class=code>RRC A</code>, <code class=code>RL A</code>, <code class=code>RR A</code>. А если считать полуофициальные инструкции, то таких некрасивых двойников обнаружится ещё больше. В официальной документации есть довольно странная ошибка для команд ввода и вывода: там указано, что используется регистр C в качестве индекса, а фактически используется регистр BC. Возможно эта ошибка была сделана намеренно, так как выполнении блочных инструкций ввода или вывода регистр B используется как счетчик. Конечно, если использовать только 256 байт для портов, то эта ошибка сама собой исчезает, но некоторые системы, например, Amstrad CPC/PCW использует все 64 КБ адресного пространства для доступа к портам ввода и вывода и там такие блочные инструкции использовать не получится. Интересно ещё, что даже при использовании 8-битного адреса в операциях IN и OUT, Z80 всё равно формирует 16-битный адрес, используя аккумулятор для задания старшего байта. Это использовалось, например, в ZX81. По моему мнению инструкций для ввода и вывода добавили слишком много, большинство из них скорее избыточны.

<p>В официальной документации по Z80, помимо отмеченных, есть и другие неточности.

<p>Много было написано про сравнение быстродействия z80 и 6502, так как эти процессоры очень широко использовались в первых массовых компьютерах. В этой теме есть несколько непростых моментов, без понимания которых очень трудно сохранять объективность. Благодаря наличию довольно большого числа регистров z80 естественно использовать на частоте большей, чем работает память. Поэтому z80 на 4 МГц может использовать ту же память, что и 6502 или 6809 на 1.33 МГц. По мнению многих опытных программистов, писавших коды для обоих процессоров, на одинаковой частоте 6502 в среднем примерно от 2.4 до 2.6 раз быстрее, чем z80. Автор этого материала с этим согласен. Только нужно добавить, что писать хорошие, быстрые коды для z80 &ndash; это очень непросто, нужно постоянно оптимизировать использование регистров, а для работы с памятью максимально задействовать стек. Если очень стараться, то по моему мнению можно свести разницу между z80 и 6502 до примерно 2.2 раз. А если не стараться и игнорировать тайминги, то легко можно получить разницу и более 4-х раз. В некоторых отдельных случаях z80 может показывать очень быструю работу. На задаче заполнения памяти z80, используя команду PUSH, может быть даже чуть быстрее 6502, но это ценой запрета прерываний. На копировании блоков памяти z80 только в 1.5 раза медленнее. Особенно впечатляет, что в делении 32-разрядного делимого на 16-делитель z80 медленнее только в 1.7 раз. Кстати, такое суперделение было реализовано российским программистом. Таким образом, получаем, что ZX Spectrum c z80 на 3.5 MHz примерно в полтора раза быстрее С64 с 6502 на 1 МГц. Стоит ещё отметить, что часть тактов в большинстве систем с z80 или 6502 отбирается у процессора схемами поддержки генерации видеосигнала, например, из-за этого у популярных компьютеров Amstrad CPC/PCW реальная частота процессора 3.2 МГц, а не полные 4. В системах на 6502 обычно можно отключать экран для получения максимальной процессорной производительности. Если за основу брать частоту работы памяти, а не процессора, то получится, что z80 на 25-40% быстрее, чем 6502. Последний результат можно проиллюстрировать тем, что с памятью с частотой 2 МГц z80 может работать на частоте до 6 Мгц, а 6502 только до 2 МГц.

<p>Также было бы любопытно сравнить быстродействие Z80 и 8088. Конечно, в целом 8088 &mdash; это более мощный процессор, но во многих важных частностях он медленнее, чем Z80. Рассмотрим следующую таблицу, где представлены некоторые типичные случаи, когда Z80 быстрее.
<div align=center>
<table>
<tr><th colspan=2 align=center>Z80<th colspan=2 align=center>8088<th rowspan=2 align=center>gain
<tr><th align=center>code<th align=center>time<th align=center>code<th align=center>time
<tr><td align=center>JP word<td align=center>10<td align=center>JMP word<td align=center>15<td align=center>5
<tr><td align=center>CALL word<td align=center>17<td align=center>CALL word<td align=center>19<td align=center>2
<tr><td align=center>RET<td align=center>10<td align=center>RETN<td align=center>20<td align=center>10
<tr><td align=center>RST byte<td align=center>11<td align=center>INT byte<td align=center>71<td align=center>60
<tr><td align=center>JP (HL)<td align=center>10<td align=center>JMP BX<td align=center>15<td align=center>5
<tr><td align=center>LD r,(HL)<td align=center>7<td align=center>MOV r,[BX]<td align=center>13<td align=center>6
<tr><td align=center>LD (HL),r<td align=center>7<td align=center>MOV [BX],r<td align=center>14<td align=center>7
<tr><td align=center>LD (HL),byte<td align=center>10<td align=center>MOV [BX],byte<td align=center>16<td align=center>6
<tr><td align=center>LD A,(BC)<td align=center>7<td align=center>MOV SI,CX<br>MOV AL,[SI]<td align=center>15<td align=center>8
<tr><td align=center>LD (BC),A<td align=center>7<td align=center>MOV SI,CX<br>MOV [SI],AL<td align=center>16<td align=center>9
<tr><td align=center>LD HL,(word)<td align=center>16<td align=center>MOV BX,[word]<td align=center>18<td align=center>2
<tr><td align=center>LD (word),HL<td align=center>16<td align=center>MOV [word],BX<td align=center>19<td align=center>3
<tr><td align=center>EX (SP),HL<td align=center>19<td align=center>MOV SI,SP<br>XCHG [SI],BX<td align=center>32<td align=center>13
<tr><td align=center>EX (SP),IX<td align=center>23<td align=center>MOV SI,SP<br>XCHG [SI],BP<td align=center>32<td align=center>9
<tr><td align=center>PUSH BC<td align=center>11<td align=center>PUSH CX<td align=center>15<td align=center>4
<tr><td align=center>POP DE<td align=center>10<td align=center>POP DX<td align=center>12<td align=center>2
<tr><td align=center>INC (HL)<td align=center>11<td align=center>INC [BX]<td align=center>20<td align=center>9
<tr><td align=center>DEC (HL)<td align=center>11<td align=center>DEC [BX]<td align=center>20<td align=center>9
<tr><td align=center>SET 0,(HL)<td align=center>15<td align=center>OR [BX],1<td align=center>22<td align=center>7
<tr><td align=center>RES 1,(HL)<td align=center>15<td align=center>AND [BX],0xFD<td align=center>22<td align=center>7
<tr><td align=center>RLC (HL)<td align=center>15<td align=center>ROL [BX],1<td align=center>20<td align=center>5
<tr><td align=center>RR (HL)<td align=center>15<td align=center>RCR [BX],1<td align=center>20<td align=center>5
<tr><td align=center>IN A,(byte)<td align=center>11<td align=center>IN A,byte<td align=center>14<td align=center>3
<tr><td align=center>OUT (byte),A<td align=center>11<td align=center>OUT byte,A<td align=center>14<td align=center>3
</table>
</div>

<p>Легко можно заметить, что Z80 быстрее на инструкциях для счетчика команд и операциях с памятью и портами, унаследованных от 8080. Особенно заметно преимущество Z80 на дальних условных переходах. У 8088 смещение у условных переходов только один байт, поэтому когда нужен более дальний переход, то приходится писать две команды. У Z80 такой проблемы нет, там для перехода выделяется два байта и поэтому в таких случаях условный переход на Z80 существенно быстрее, на 6 или 9 тактов. Практически все операции через регистр HL выполняются на Z80 чуть быстрее, а это и сложение, и вычитание, сравнение, BIT и другие логические операции. Хотя возврат из прерывания у Z80 и 8088 архитектурно сильно различаются, они несут идентичные функции. RETI у Z80 на 30 тактов быстрее IRET и это не считая команд, которые нужно выполнить 8088 для сброса контроллера прерываний. У Z80 вызовы подпрограмм и возврат из них может быть условным, что делает аналогичные коды для Z80 компактнее и быстрее, чем для 8088. И, конечно, эмуляция команд EXX и EX для дополнительного набора регистров, блочных команд ввода-вывода или команд RLD/RRD займет на 8088 весьма значительное время. Кроме того, 8088 работает с очередью команд, которой требуется 4 такта на каждый байт инструкции и это часто добавляет такты при выполнении команды, у Z80 такого тормоза нет. Но несмотря на все эти частные случаи, обычно код для 8088 быстрее кода для Z80 на одинаковых частотах не менее, чем на 50%.

<p>Z80 использовался в очень большом числе компьютерных систем. В США были очень популярны Tandy TRS-80, в Европе &ndash; ZX Spectrum, а позднее Amstrad CPC и PCW. Любопытно, что компьютеры Amstrad PCW сохраняли актуальность до середины 90-х и их массово и активно использовали по назначению до конца 90-х. В Японии и других странах производили довольно успешные во всем мире компьютеры MSX. Довольно популярный C128 мог также использовать z80, но тут пользователям был подстроен скорее конфуз &ndash; у этого позднего, 1985 года выпуска, 8-битного компьютера z80, тактированный официально 2 МГц, реально работает только на 1.6 МГц. Это медленнее даже, чем первые системы на 8080 середины 70-х. Номенклатура компьютеров для использования операционной системы CP/M насчитывает не менее трех дюжин довольно известных систем. Z80 использовался также в игровых консолях Master System, Game Gear, Mega Drive и др. Общее число произведенных систем на базе Z80 скорее всего менее 100 миллионов, что меньше числа систем на базе 6502. Но это не считая калькуляторов. В школах и вузах США, начиная с 90-х и по настоящее время, почти все учащиеся обязаны иметь калькулятор TI-83 или совместимый с ним! Поэтому с учетом калькуляторов, возможно, что в 21 веке число систем на базе Z80 превзошло такое число для 6502.

<div align=center>
<p><img src=https://habrastorage.org/webt/14/ep/4h/14ep4h6v2gm76bbogo_ek4ym51k.jpeg>
<p style=font-size:90%>Такой ПК достойно выглядел даже в середине 90-х, но его z80 медленнее того, что в ZX Spectrum
</div>

<p>Самая быстрая известная автору компьютерная система на основе z80 &ndash; это BBC Micro c TUBE-приставкой с z80B на 6 МГц, выпускавшейся с 1984. Процессор в этой системе работает на полной скорости, как говорят, "без тормозов". Подобные приставки производились и для Apple ][ с 1979. Позднее некоторые из таких приставок использовали Z80H на 8 МГц и даже выше. Интересно, что Microsoft в 1980 году получила наибольшую прибыль именно от продажи таких приставок. Можно ещё упомянуть Amstrad PCW16, производившийся с 1994, который использовал CMOS Z80 на частоте 16 МГц.

<p>В Японии для систем MSX TurboR (1990) производился процессор R800, совместимый с z80. В R800 было добавлено аппаратное 16-разрядное умножение с 32-разрядным результатом. Хотя при умножении на 16-разрядную константу, табличное умножение с таблицей на 768 байт получается на такт быстрее. Есть мнение, что R800 &mdash; это сильно упрощенный Z800, работающий на частоте в четыре раза большей, чем частота шины, которая равна примерно 7.16 MГц. Таким образом, внутренняя частота R800 равна примерно 28.64 МГц!

<p>Сама фирма Zilog производила работу по улучшению Z80 очень непоследовательно и крайне медленно. Первые Z80 работали на частотах до 2.5 МГц, у появившегося вскоре Z80A предельная частота была увеличена до 4 МГЦ &ndash; именно эти процессоры стали основой для большинства популярных, использующих Z80 компьютеров. Z80B появился к 1980, но использовался сравнительно редко, например, в упоминавшейся приставке для BBC Micro или в позднем (1989) компьютере Sam Coupé. Z80H появился к середине 80-х и мог работать на частотах до 8 МГц &ndash; в известных компьютерах не использовался. Интересно, что изделия Zilog имели на чипе специальные ловушки для тех, кто пытался делать с них копии, например, базовый Z80 имел 9 ловушек и они, по отзывам тех, кто этим занимался, замедляли процесс копирования почти на год.

<p>Более глубокая модернизация z80 была приторможена желанием Zilog создать процессоры, конкурентные для 16-разрядных процессоров Intel. В 1978, чуть позже 8086 был выпущен Z8000, не совместимый с z80. Этот процессор оказался не в состоянии противостоять конкурентам из Intel и, особенно, Motorola &ndash; 68000 практически по всем параметрам превосходил Z8000, хотя Z8000 использовался в примерно десятке различных недорогих систем, как правило, для работы с вариантами Unix. Интересно, что IBM даже не рассматривала Z8000 как возможный процессор для IBM PC, поскольку Zilog финансировалась компанией Exxon, которая собиралась конкурировать с IBM. Возможно из-за неуспеха Z8000 Zilog стала к 1980 подразделением Exxon. Была ещё попытка создать конкурентный 32-битный процессор. В 1986 появился Z80000, совместимый с Z8000, который так <b>нигде</b> и не нашёл применения. Некоторые обстоятельства, в частности, очень странные жалобы команды Zilog на чрезмерное финансирование, позволяют подумать, что возможно Zilog в силу каких-то неясных причин скорее саботировала свою работу, будучи частью Exxon. Тут ещё можно вспомнить странные откровения ведущего инженера Zilog Масатоши Шимы (Masatoshi Shima), в которых тот утверждает, что в Zilog искусственно занизили частоту Z8000, чтобы он был не быстрее, чем 8086.

<p>Можно только удивляться, почему Zilog отказалась от своего подхода, показавшего сверхуспешные результаты с Z80, а именно делать процессоры программно совместимые с процессорами Intel, но лучшие их и при этом совершенно разные на аппаратном уровне. Впоследствии такой подход успешно использовали многие фирмы, в частности, AMD, Cyrix, VIA.

<p>Создание нового процессора на базе Z80 было отложено до 1985, когда был сделан Z800. Однако, тогда основные усилия Zilog были направлены на Z80000 и Z800 было выпущено очень мало. В 1986, после провала Z80000 был выпущен Z280, незначительно улучшенный вариант Z800, который, в частности, мог работать на внутренней частоте в несколько раз большей, чем частота шины &ndash; такая новинка принесла потом процессорам Intel 486DX2 и 486DX4 крупный успех. Z280 имел и другие перспективный особенности, которые потом с успехом применяли другие фирмы. Но, возможно из низкой производительности &ndash; Z280, несмотря на многие технологические новинки, мог использовать только сравнительно низкие тактовые частоты, этот процессор также <b>нигде</b> не нашёл применения. Считается, что Z280 примерно соответствовал по возможностям Intel 80286, но был существенно, не менее 50% медленнее при использовании одинаковой с 80286 тактовой частоты. Возможно, если бы Z280 появился 5 годами ранее, то он бы мог стать очень успешным.

<p>Наибольшего успеха удалось добиться благодаря сотрудничеству с японской фирмой Hitachi, которая в 1985 выпустила свой супер-Z80, HD64180, схожий по возможностям с Intel 80186, который позволял использовать 512 КБ памяти, добавлял дюжину новых инструкций, но при этом некоторые почти стандартные недокументированные инструкции Z80 не поддерживались. HD64180 использовался в некоторых компьютерных системах. Zilog получила лицензию на HD64180 и стала производить их с маркировкой Z64180. Zilog удалось незначительно улучшить этот процессор, в частности, добавить поддержку работы с 1 МБ памяти и выпустить его к концу 1986 года. Этот новый процессор получил название Z180 и стал основой для семейства процессоров и контроллеров, с тактовыми частотами до 33 МГц. Он использовался в некоторых редких компьютерах MSX2, но больше как контроллер. Любопытно, что Z280 и Z180 появились в один год, как и их примерные аналоги 80286 и 80186 четыре года до этого. В 1994 на базе Z180 был сделан 32-битный Z380, сохранивший совместимость с z80 и примерно соответствующий по возможностями Intel 80386 или Motorola 68020 &ndash; Zilog показала отставание от конкурентов почти в 10 лет. Уже 21 веке опять на базе Z180 производятся весьма успешные процессоры-контроллеры eZ80 с таймингами почти как у 6502. Их используют в различном оборудовании, в частности, в сетевых платах, DVD-приводах, калькуляторах, ... А процессора, совместимого с 6502 и сравнимого с eZ80, так и не появилось. Возможно просто из-за того, что у Zilog всегда было лучше с финансами, чем у WDC.


<h2 id=tms9900>Texas Instruments TMS9900</h2>

<p>Для этого очень особенного процессора кодов мне писать не доводилось. А это первый доступный для использования в персональных компьютерах 16-битный процессор. Он производился с 1976 года. Использует гораздо реже встречающийся порядок байт от старшего к младшему (Big Endian). Такой порядок используется ещё только в процессорах Motorola серий 6800 и 68000 и в архитектуре гиганта IBM/370. Все прочие процессоры данного обзора используют обратный порядок байт (Little Endian).

<p>У TMS9900 есть всего три 16-битных регистра: счётчик команд, регистр состояний и регистр базы псевдорегистров. Этот процессор использует выделенный участок памяти размером 32 байта как 16 двубайтных регистра. Такое использование памяти чем-то напоминает нулевую страницу памяти в архитектуре 6502. Используя регистр базы, TMS9900 может очень быстро менять контекст. Это напоминает Z80, который имеет два регистровых контекста. Система флагов отличается своеобразием, наряду с типичными флагами переноса, нуля (равенства), переполнения, чётности, есть ещё два уникальных флага признаков логического и арифметического меньше. Работа со стеком и подпрограммами напоминает RISC-процессоры будущего. Готового стека просто нет, его можно сделать использую один из псевдорегистров. При вызове подпрограммы выбирается новое значение для счетчика и базы и все три регистра сохраняются в псевдорегистрах нового контекста. Таким образом, вызов подпрограммы больше похож на вызов программного прерывания. TMS9900 имеет встроенный контроллер прерываний, рассчитанный на работу с аппаратными прерываниями числом до 16.

<div align=center>
<p><img src=https://habrastorage.org/webt/bs/ir/lv/bsirlvxf7fobwzwpdcvxkcnousc.jpeg width=50%>
<p style=font-size:90%>Первый 16-разрядный домашний компьютер &ndash; у него даже цветные спрайты есть
</div>

<p>Система команд выглядит очень внушительно. Есть даже умножение и деление. Уникальная инструкция X (подобная есть только на мейнфреймах IBM) позволяет исполнять одну инструкцию по любому адресу в памяти и переходить к следующей. Исполнение команд довольно медленное, самые быстрые инструкции выполняются только за 8 тактов, арифметические команды &ndash; за 14, зато умножение (16*16=32) за 52 такта и особенно деление (32/16=16,16) за 124 такта были наверное рекордно быстрыми среди процессоров 70-х.

<p>TMS9900 требует три напряжения питания -5, 5 и 12 вольт и четыре фазы сигнала тактирования &ndash; это антирекорды среди известных мне процессоров. В 1979 этот процессор был продемонстрирован специалистам фирмы IBM, которые тогда искали процессор для находящегося в разработке прототипа IBM PC. Очевидные недостатки TMS9900 (адресуемость только 64 КБ памяти, отсутствие необходимых архитектуре контроллеров, относительная медленность) произвели соответствующее впечатление и для будущего лидера среди ПК был выбран Intel 8088. Для устранения проблемы отсутствия контроллеров Texas Instruments также производила вариант TMS9900 с 8-разрядной шиной, TMS-9980, который работал на 33% медленнее.

<p>TMS9900 использовался в довольно популярных в США компьютерах TI99/4 и TI99/4A, которые были "разгромлены" в войне цен компьютером Commodore VIC-20 к 1983. Любопытно, что в результате этой войны Texas Instruments была вынуждена снизить цены на свой компьютер до невероятных для 1983 $49 (в 1979 цена была $1150!) и продавать их с большим для себя убытком. Можно для примера привести сравнительно непопулярный компьютер Commodore+4, который прекратили производить ещё в 1986, но цены на который упали до этих $49 только в 1989 году. TI99/4A прекратили производить в 1984, тогда, когда из-за сверхнизких цен он стал набирать популярность. Этот компьютер лишь условно можно назвать 16-разрядным. Потому что он имеет только 256 байт (!) памяти ОЗУ и всю память ПЗУ адресуемые через 16-разрядную шину. Остальная память и устройства ввода-вывода работают через медленную 8-разрядную шину. Поэтому возможно более правильно считать первым домашним 16-битным компьютером отечественный БК-0010. Любопытно, что TI99/4 и TI99/4A использовуют процессор на частоте 3 МГц &ndash; точно на такой же как и БК-0010.

<p>В своих популярных калькуляторах серии, начавшейся с TI-81, Texas Instrument предпочла использовать Z80 вместо своего в чем-то более продвинутого процессора...

<p>В TI-99/4 и TI99/4A в качестве видеоконтроллера использовалась довольно удачная микросхема TMS9918, которая стала основой для весьма популярного во всём мире стандарта MSX, а также некоторых других компьютеров и игровых консолей. В японской компании Yamaha этот видеочип был значительно улучшен и впоследствии использовался, в частности, для модернизации самих TI-99/4 и TI99/4A!

<p>Серия TI99/4 &ndash; это редкий пример компьютеров, где производитель процессора и компьютера был одним и тем же.


<h2 id=pdp11>Процессоры DEC PDP-11</h2>

<p>С начала 70-х в мире началась 10-летняя эпоха доминирования фирмы DEC. Компьютеры DEC были существенно дешевле, производимых фирмой IBM и поэтому привлекли к себе внимание со стороны небольших организаций, для которых системы IBM были недоступны. С этих компьютеров начинается также эпоха массового профессионального программирования. Серия компьютеров PDP-11 оказалась очень удачной. Различные модели PDP-11 производили с начала 70-х до начала 90-х. В СССР они были успешно клонированы и стали первыми массовыми популярными компьютерными системами. Среди клонов компьютеры с названиями СМ ЭВМ, Электроника-60/81/85, ДВК-1/2/3, БК-0010/0011 (БК0010 &ndash; это первый ПК, которые стало возможным купить в магазине). Кстати, очень вероятно, что количество компьютеров архитектуры PDP-11, произведенных в СССР, было большим общего числа компьютеров этой архитектуры, произведенных во всем остальном мире!

<p>Однако, DEC продвигала также более дорогие и сложные компьютеры семейства VAX-11, ситуация вокруг которых отличалась некоторой политизированностью. И со второй половины 70-х DEC практически остановила развитие в линии PDP-11. В частности, так и не была введена поддержка 16-х чисел для ассемблера. СУБД Oracle изначально была создана для PDP-11 в 1979, но уже следующую версию в 1983 для этих компьютеров делать не стали &ndash; предпочли им системы на MS-DOS. Быстродействие систем PDP-11 также практически не менялось с середины 70-х.

<div align=center>
<p><img src=https://habrastorage.org/webt/v5/wc/_j/v5wc_j2ybrirswrbe_4h9gmzfvy.jpeg width=50%>
<p style=font-size:90%>PDP-11/70 (Мисс Хрюшка) из Музея живых компьютеров, работает до сих и свободно доступен через сеть
</div>

<p>PDP-11 использовали разные, совместимые по основной системе команд процессоры, например, LSI-11, F-11, J-11. В конце 70-х DEC сделала дешёвый процессор для микрокомпьютеров T-11. Однако, по неясным причинам он, несмотря на казалось бы большое и качественное программное обеспечение, которое можно было бы в перспективе перенести на систему его использующую, так и не был замечен производителями компьютерных систем. Единственным исключением стала одна модель игровой консоли фирмы Atari. T-11 нашёл себе массовое применение только в мире встроенного оборудования, хотя по возможностям он скорее слегка превосходил z80. В СССР выпускались процессоры К1801ВМ1, К1801ВМ2, К1801ВМ3, ... близкие процессорам DEC, а также точные копии процессоров DEC. Последние были гораздо дороже и выпускались в маленьких количествах.

<p>Систему команд процессоров архитектуры PDP-11 отличает почти полная ортогональность, приятное качество, но когда его доводят до крайности, это может создавать и нелепые команды. Система команд процессоров PDP-11 оказала влияние на многие архитектуры и в особенности на Motorola 68000.

<p>Система команд PDP-11 строго 16-битная. Все 8 регистров общего назначения (а счетчик команд в этой архитектуре &ndash; это обычный регистр R7) &ndash; 16 разрядные, регистр состояний (содержит типичные флаги) 16-разрядный тоже, размер команд от 1-го до 3-х 16-разрядных слов. Каждый операнд в команде может быть (хотя есть исключения, например, инструкция XOR) любого типа &ndash; это и есть ортогональность. Среди типов &ndash; обычные регистр или память. Программисты в 80-е иногда не понимали, почему в системе команд Intel x86 нет команд типа память-память. Это влияние школы PDP-11, где запросто можно написать полные адреса у каждого операнда. Это, конечно, медленно и особенно медленно для систем с типичной с начала 90-х медленной памятью. К памяти можно обращаться и через регистр, регистр со смещением, регистр с авто-декрементаций или инкрементацией. Особенностью системы команд PDP-11 является возможность двойного косвенного обращения к памяти через регистр, например, <code class=code>MOV @(R0)+,@-(R1)</code> означает то же, что и оператор языка С/C++ <code class=code>**&ndash;r1 = **r1++;</code>, где r0 и r1 декларируются как <code class=code>signed short **r0, **r1;</code>.

<p>Другой пример, команда <code class=code>MOVB @11(R2),@-20(R3)</code> соответствует <code class=code>**(r3-20) = **(r2+11);</code>, где r2 и r3 декларируются как <code class=code>char **r2, **r3;</code>.

<p>В популярных ныне архитектурах одной командой в таких случаях уже не обойтись, понадобится возможно не менее 10 команд. Можно также получать адрес относительно текущего значения счётчика команд. Приведу ещё пример с более простой адресацией. Команде <code class=code>ADD #16,11(R4)</code> в архитектуре Intel x86 можно сопоставить <code class=code>ADD [BX+11],16</code>. В ассемблерах DEC принято писать операнды слева-направо, в отличие от Intel, где пишут справа-налево. Есть основание полагать, что GNU ассемблер для x86 делали под влиянием именно ассемблера PDP-11. Хотя в ассемблере PDP-11 есть странное исключение для инструкции CMP, где операнды почему-то идут как в Intel x86.

<p>Команды умножения и деления только знаковые и доступны не на всех процессорах. Команда деления, как и на 68k, но в отличие от x86, правильно ставит флаги, что позволяет нормально работать со случаями переполнения. Однако не все PDP-11, поддерживающие деление, правильно работают с флагами при таком переполнении. Арифметика десятичных чисел также опциональна &ndash; это так называемая коммерческая арифметика по терминологии DEC. В качестве курьёза полной ортогональности приведу пример команды <code class=code>MOV #11,#22</code>, которая после исполнения превращается в <code class=code>MOV #11,#11</code> &ndash; это пример использования непосредственной константы в качестве операнда. Другая курьёзная команда &ndash; это уникальная команда MARK, код которой нужно класть в стек и никогда нельзя использовать явно. Вызов подпрограмм в архитектуре PDP-11 также несколько своеобразен. Соответствующая команда сначала сохраняет выделенный регистр (может быть любым) в стеке, затем сохраняет счётчик команд в этом регистре и только затем записывает в счетчик команд новое значение. Команда возврата из подпрограммы должна сделать всё наоборот и знать, какой регистр был использован при вызове подпрограммы. В качестве примера необычной команды можно ещё указать на умножение, в котором в зависимости от номера используемого регистра для результата можно получить либо полное 32-битное произведение, либо только его младшие 16 разрядов. Наличии в системе команд абсолютно бесполезных инструкций CLV, SEV, CLZ, SEZ, CLN, SEN демонстрирует некоторую непродуманность в мелочах этой системы. Также несколько неуклюже реализована работа с переносом в командах ADC и SBC, например, чтобы сделать сложение двух слов с переносом на PDP-11 нужно две команды, в то время как на x86 или 68k достаточно одной. Хотя на IBM/370 для такой операции потребуется даже три команды. Странные и непредсказуемые эффекты можно получить, используя счётчик команд как обычный регистр, хотя это возможно касается только некоторых моделй процессоров.

<p>Любопытно, что среди программировших на PDP-11 сложилась культура работы напрямую с машинными кодами. Программисты могли, например, работать без дизассемблера при отладке. Или даже писать небольшие программы прямо в память, не ассемблируя!

<p>Также любопытно, что мнемоники ассемблера для PDP-11 стали основой для ассемблеров популярных процессоров 680x, 6502, 68k.

<p>Конечно, тайминги команд не отличаются слишком скоростными характеристиками. Удивительно было когда-то узнать, что на отечественном компьютере БК команда пересылки из регистра в регистр занимает целых 12 тактов (10 тактов при использовании кода из ПЗУ), а команды с двумя операндами с двойной косвенной адресацией исполняются за более чем 100 тактов. Z80 делает 16-разрядную регистровую пересылку за 8. Однако, медленность БК вызвана не столько процессором, сколько плохим качеством отечественной памяти, под особенности которой БК пришлось приспособить. Если бы использовалась достаточно быстрая память, то и БК пересылал 16 регистровых бит за 8 тактов тоже. Когда-то было много споров, что быстрее БК или Спектрум? Сразу надо сказать, что Спектрум &ndash; это при использовании верхних 32 КБ памяти один из самых быстрых массовых 8-битных персональных компьютеров. Поэтому неудивительно, что Спектрум быстрее БК, но не намного. А если бы БК работал с памятью без тормозов, то он был бы наверное чуть быстрее.

<p>Плотность кодов также скорее слабое место архитектуры PDP-11. Коды инструкций должны быть кратными длине машинного слова &ndash; 2 байтам, что особенно неприятно при работе с байтовыми аргументами или простыми командами вроде установки или сброса флага. Но при сравнении с другими архитектурами PDP-11 показывает на практике иногда даже лучшую плотность кодов!

<p>Интересны попытки сделать персональный компьютер на базе архитектуры PDP-11. Одним из первых ПК в мире, появившихся лишь чуть позже Apple ][ и Commodore PET и скорее чуть раньше Tandy TRS-80, был Terak 8510/a, который имел черно-белую графику и возможность загружать неполный вариант Unix. Этот ПК был довольно дорог и, насколько мне известно, использовался только в системе высшего образования США. С 1978 производился компьютер в виде комплекта для сборки Heathkit H11. Сама фирма DEC тоже пыталась сделать свой ПК, но очень непоследовательно. DEC, например, выпускала ПК на базе z80 и 8088, явно играя скорее против своих основных разработок. Персоналки на базе архитектуры PDP-11 DEC PRO-325/350/380 имели некоторые скорее искусственные несовместимости с базовой архитектурой, что затрудняло использование части программного обеспечения. Лучше всего персонализация технологий мини-компьютеров получилась в СССР, где производились БК, ДВК, УК НЦ, ... Кстати, Электроника-85 &ndash; это довольно точный клон DEC PRO-350. Кроме того, родственный архитектуре PDP-11 процессор CP1600 использовался в популярных в начале 80-х игровых консолях Intellivision.

<div align=center>
<p><img src=https://hsto.org/storage2/054/de2/ed6/054de2ed61ad81127c1d7db0f7171100.jpg>
<p style=font-size:90%>Отечественный 16-разрядный домашний компьютер (модель 1987 года) &ndash; почти PDP-11 совместимый
</div>

<p>К1802ВМ2, который использовался в ДВК, примерно в два раза быстрее К1801ВМ1. К1801ВМ3 ещё быстрее, он во многом соответствует лучшим процессорам PDP-11 и близок по быстродействию к Intel 8086.

<p>В топовых моделях PDP-11 и близких им отечественных компьютерах процессор может адресовать до 4 МБ памяти, но одной программе при этом может обычно выделяться не более 64 КБ. Однако, используя специальные возможности аппаратуры и системного ПО, можно было создавать и большие коды. Лучшие процессоры DEC, например, J-11 могут использовать раздельное адресное пространство для инструкций и данных, что увеличивает размер адресного пространства вдвое и никак не замедляет исполнения. Массовые отечественные процессоры такого не умели. И тут стоит заметить, что даже первые процессоры x86, умели такое прямо "из коробки" и более продвинуто, выделяя таким образом до 256 КБ, а если считать пространство портов, то и все 320КБ. Размер исполняемого кода в PDP-11 можно также увеличивать через оверлеи, размещаемые в памяти. Работа с оверляеми PDP-11 требует очень основательной поддержки со стороны ОС и компиляторов и существенно медленнее, чем дальние вызовы в первых x86. Для работы с большими данными на PDP-11 можно использовать виртуальные массивы, что опять требует хорошей поддержки со стороны ОС и компиляторов и также медленнее, чем работа с большими массивами на первых x86. По быстродействию лучшие процессоры для PDP-11 по числу операций на мегагерц близки к 8086. Однако из-за более высоких используемых частот, лучшие PDP-11 были быстрее первых IBM PC, но уже AT с 8 МГц с ними практически сравнялись.


<h2 id=vax>Процессор для DEC VAX</h2>

<p>Системы VAX-11 были довольно популярны в 80-е, особенно в высшем образовании. Сейчас трудно понять некоторые концепции, описанные в книгах тех лет, без знания особенностей архитектуры этих систем. Они могли эмулировать популярные PDP-11. VAX-11 были дороже PDP-11, но более ориентированы на универсальное программирование и всё же существенно дешевле систем IBM/370. Для архитектуры VAX был к середине 80-х сделан процессор V-11, а до этого времени использовались процессорные сборки.

<p>Архитектура VAX-11 32-разрядная, она использует 16 регистров, среди которых как и на PDP-11 есть счётчик команд. Предполагается использование двух стеков, один из которых используется для хранения кадров-фреймов подпрограмм. Кроме того, один из регистров назначен для работы с аргументами вызываемых функций. Таким образом, для стеков выделены 3 из 16 регистров. Система команд VAX-11 не может не поражать своей огромностью и наличием весьма редкостных и часто уникальных команд, например, для работы с полями битов или несколькими типами очередей, для вычисления CRC, умножения 10-х строк, ... Многие команды есть как в трехадресных вариантах (как ARM), так и в двухадресных (как х86), но есть и четырехадресные команды, например, расширенное деление EDIV. Конечно же есть поддержка работы с вещественными числами.

<p>Но VAX-11 &ndash; это очень медленная для своего класса и цены система. Даже сверхпростейший 6502 на 4 МГц мог обогнать самый медленный из семейства VAX-11/730, а самые быстрые системы VAX-11 &ndash; огромные шкафы и "целые мебельные гарнитуры", по производительности оказываются на уровне первых PC AT. Когда появился 80286 стало ясно, что дни VAX-11 сочтены и даже торможение с внедрением систем на основе 80286 не могло уже ничего принципиально изменить. Более прямолинейные англичане из Acorn, сделав ARM в 1985, ничего не скрывая, заявили что ARM гораздо дешевле и заметно быстрее. VAX-11, тем не менее, сохранял актуальность до начала 90-х, имея всё же некоторые преимущества перед ПК, в частности, более быстрые системы для работы с дисками.

<p>Известно, что среди самых дешёвых VAX-11 были проблемы с совместимостью. В частности, на первые VAX-11/730 не удавалось портировать Unix из-за особенностей реализации на них привилегированных инструкций.

<p>VAX-11 &ndash; это наверное последняя массовая система, в которой удобство работы на языке ассемблер считалось важнее быстродействия. В каком-то смысле, такой подход перешел на современные популярные языки сценариев.

<div align=center>
<p><img src=https://gordonbell.azurewebsites.net/Digital/timeline/photos/vax11-785.jpg>
<p style=font-size:90%>VAX-11/785 &ndash; это тоже компьютер (1984) &ndash; самый быстрый среди VAX-11, по быстродействию процессора сравним с IBM PC AT или ARM Evaluation System
</div>

<p>Удивительно, но в открытом доступе очень мало литературы по системам VAX. Как будто действует какой-то странный закон о забвении. С историей этой архитектуры связаны несколько эпизодов, близких к политике и коррелированных с историей СССР. Вполне возможно, что фактический отказ от развития архитектуры PDP-11 был вызван её дешевизной и успехами её клонирование в Советском Союзе. А клонирование VAX стоило на порядок больших ресурсов и вело в тупик. Интерес к VAX создавали, используя, например, используя розыгрыши типа знаменитого Кремлевского Вакса на 1 апреля 1984, в которой тогдашний лидер СССР Константин Черненко предлагал выпить водки по случаю подключения к сети Usenet. Другая шутка заключалась в том, что на некоторые чипы VAX впечатывалось послание на ломаном русском языке о том, как хорош VAX.

<p>Некоторые первые модели VAX были клонированы в СССР к концу 80-х, но таких клонов было произведено очень мало и они практически не нашли себе применения.

<p>Несколько систем VAX доступны для использования через сеть. И это их выгодно отличает от систем IBM/370, c которыми они конкурировали.

<p>Конечно нужно иметь в виду, что на VAX-11 история компьютеров VAX в DEC не завершилась. Последние модели VAX-11 были сделаны в середине 80-х. Им на смену пришли модели VAX 8000. Параллельно шло развитие линий MicroVax, VAXstation и VAXserver. VAX 8000 сменили более дешёвые и несколько более быстрые VAX 6000. Уже в начале 90-х MicroVax сменили модели VAX 4000. Процессоры VAX c начала 90-х показывали производительность на уровне 80486, но имели несколько более высокие тактовые частоты. Могу предположить, что 80486DX4 на частоте 100 МГц и первые процессоры Pentium стали обгонять лучшие модели VAX 7000 по производительности. После чего в DEC пришлось отказаться от поддержки системы инструкций VAX и перейти к её эмуляции на системах DEC Alpha. Были ещё и суперкомпьютеры VAX 9000 и многопроцессорные варианты, например, VAX 7000, но это были очень дорогие системы. Можно ещё упомянуть системы повышенной надежности VAXft, в которых функции процессора дублировались, что позволяло преодолевать сбой одного из процессоров. После V11 были процессоры CVAX, Rigel, NVAX и NVAX+.


<h2 id=x86>Intel: от 8086 до 80486</h2>

<p>Безусловно, что одним из самых лучших процессоров, из сделанных в 70-е, является 8086, а также его более дешевый почти аналог 8088. Интересно, что 8088 и 8086 внешне выглядят идентично, их чипы имеют одинаковое число ножек и почти все они имеют одинаковую функциональность. Архитектуру этих процессоров приятно отличает отсутствие механических заимствований и следований абстрактным теориям, продуманность и взвешенность архитектуры, сбалансированность и ориентированность на дальнейшее развитие. Из недостатков архитектуры x86 можно назвать её некоторую громоздкость и склонность к экстенсивному росту числа инструкций. 

<p>Одним из гениальных конструктивных решений 8086 стало изобретение сегментных регистров. Этим как бы одновременно достигались две цели &ndash; "бесплатная" перемещаемость программ, размером до 64 КБ (это до середины 80-х был очень даже достойный объем для компьютерной памяти для одной программы), и адресуемость до 1 МБ адресного пространства. Можно ещё заметить, что 8086 как и 8080 или z80 имеет ещё и специальное адресное пространство для портов ввода-вывода размером 64 КБ (y 8080 и 8085 этот объем &ndash; 256 байт). Сегментных регистров всего четыре: для кода, для стека и два для данных. Таким образом, для быстрого использования доступны 64*4 = 256 КБ памяти, но это было очень много даже в середине 80-х. На самом деле проблем по размеру кода нет, так как можно использовать так называемые длинные вызовы подпрограмм с загрузкой и сохранением полного адреса из двух регистров. Есть только ограничение в 64 КБ на размер одной подпрограммы &ndash; это достаточно и для многих современных приложений. Некоторую проблему создаёт только невозможность быстрой адресации к массивам данных размером более 64 КБ &ndash; при использовании таких массивов нужно загружать сегментный регистр и собственно адрес при каждом обращении, что снижает скорость работы с такими большими массивами в несколько раз.

<p>Сегментые регистры реализованы так, что их присутствие практически незаметно в машинных кодах, что позволило, когда пришло время, легко от них отказаться.

<p>Довольно часто можно встретить критику сегментной организации памяти, т.е. такой организации, что в общем случае для адресации ячейки памяти нужно использовать два указателя. Однако, это какая-то странная критика, скорее надуманная. Сама по себе сегментация &ndash; это совершенно естественный способ организации виртуализации и защиты памяти. Фактически критике подвергалась не сама сегментация, а только максимальный размер сегментов, 64 КБ. Однако, это ограничение является прямым следствием реализации желания иметь большие объемы памяти при использовании 16-разрядных регистров. Поэтому вся критика сегментации &ndash; это фактически замаскированное требование перехода на 32-разрядную архитектуру. Ситуация усложнялась тем, что сегментация в первых x86 только частично имела функциональность нормального устройства управления памятью (MMU), в частности, работа с сегментными регистрами была доступна прикладным программам. В 80286 сделали полную поддержку сегментации, но это сделало прежние прикладные программы для 8086 несовместимыми с режимом, когда эта полная поддержка активировалась. Только с появлением 80386 все проблемы были решены и критика прекратилась, хотя 80386 по-прежнему использовал сементацию!

<p>Удивительно, что почему-то практически невозможно найти подобную критику в отношении популярных PDP-11, где ограничения на использование памяти существенно более жёсткие. Не самые дорогие PDP-11 были существенно дороже лучших персональных компьютеров, а самые лучшие PDP-11 до середины 80-х были быстрее лучших IBM PC совместимых машин. PDP-11 были компьютерами более высокого класса до появления ПК на базе 80486 и использовали сегментирование...

<p>Использование одного указателя для хранения полного адреса памяти было естественным в архитектуре мейнфреймов IBM, VAX и процессора 68000. Легко заметить, что в этом списке нет персональных компьютеров, так как даже 68000 изначально разрабатывали для сравнительно дорогих, неперсональных систем. Процессор 8086 сохранил много общего с 8080, который использовался больше как контроллер. Поэтому довольно странно сравнивать системы на базе 8088 с, например, VAX или даже рабочими станциями Sun &ndash; это совершенно разные классы машин. Но, возможно, благодаря Биллу Гейтсу IBM PC изначально стали равнять на гораздо более дорогие системы. Первый IBM PC имел всего 16 КБ памяти, а 64 КБ было в 1981 скорее роскошью для индивидуального покупателя. К середине 80-х типовые объемы памяти для IBM PC совместимых систем достигли 512 КБ &ndash; сегментация при таких объемах памяти практически никогда не могла создавать каких-либо затруднений. Когда типовые объемы памяти для IBM PC совместимых машин превысили 512 КБ появился 80386. Стоит вспомнить, что даже в 1985 большинство систем были 8-битные и для работы с памятью, объемами более 64 КБ, приходилось использовать переключения банков памяти &ndash; это на порядок или даже два более сложно и медленно, чем использование больших массивов с 8086. А первые IBM PC были вполне сопоставимы именно с 8-битными системами, а не с VAX. Кстати, альтернативный вариант дизайна IBM PC использовал Z80. Поэтому можно только восхититься инженерами Intel, которые смогли в течении более 40 лет развивать процессоры x86 так, чтобы они всё это время были относительно недорогими, технически одними из лучших и это при сохранении бинарной совместимости со всеми предшествующими моделями, начиная с 8086! Хотя это не рекорд, IBM поддерживает совместимость с архитектурой System/360 уже почти 60 лет.

<p>Как это было отмечено, архитектура 8086 сохранила близость к архитектуре 8080, что позволило сравнительно небольшими усилиями переносить программы с 8080 (или даже с z80) на 8086 и особенно в случае, если были доступны исходные тексты программ.

<p>Команды 8086 не отличаются высокой скоростью исполнения, но вполне сопоставимы с конкурентами, например, Motorola 68000, который появился на год позже. Одной из новинок, немного разгоняющих в целом неспешный 8086, стала очередь команд.

<p>8086 использует восемь 16-разрядных регистров, некоторые из которых можно использовать как два байтовых регистра, а некоторые как индексные. Таким образом, регистры 8086 отличает некоторая разнородность, но она хорошо сбалансирована и регистры очень удобны в использовании. Эта разнородность, кстати, позволяет иметь более плотные коды. 8086 использует те же флаги, что и 8080, плюс несколько новых. Например, появился флаг типичный для архитектуры PDP-11 &ndash; пошагового исполнения. По сравнению с PDP-11 улучшилась логика описания работы с флагами для работы со знаковыми числами. Рассмотрим таблицу, где приведены соответствия между значениями флагов и отношениями между знаковыми числами.

<div align=center>
<p><img src=https://habrastorage.org/webt/ap/d9/fd/apd9fd0hdyqseunyez8kjjgwnvg.png>
<p style=font-size:90%>Так по-разному описывали одни и те же отношения в разных компаниях
</div>

<p>Из этой таблицы наверное естественно сделать вывод, что в Intel понимали логические операции, в DEC их понимали несколько хуже, ну а в Motorola похоже могли только списывать <a href=https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%B7%D1%8A%D1%8E%D0%BD%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D0%B0>ДНФ</a> из учебников по булевой алгебре.

<p>8086 позволяет использовать очень интересные режимы адресации, например, адрес можно составить из суммы двух регистров и константного 16-разрядного смешения, на который накладывается значение одного из сегментных регистров. Из суммы, составляющей адрес, можно оставить только два или даже одно слагаемое. Такое на PDP-11 или на 68k одной командой не получится. Большинство команд 8086 не позволяют иметь оба операнда типа память, один из операндов должен быть регистром. Такой подход полностью аналогичен тому, что использовался на лучших тогда системах IBM/370. Вдобавок у 8086 есть ещё и строковые команды, которые как раз умеют работать с двумя адресами в памяти. Строковые команды позволяют делать быстрое блочное копирование (17 тактов на байт или слово), поиск, заполнение, загрузку и сравнение. Кроме того, строковые команды можно использовать при работе с портами ввода-вывода. Очень интересна идея 8086 использовать префиксы команд, позволяющие без существенного усложнения схем кодирования команд использовать часто очень полезную дополнительную функциональность.

<p>8086 имеет одну из лучших среди всех компьютерных систем организацию работы со стеком. Используя только два регистра (BP и SP), 8086 позволяет решать все проблемы при организации вызовов подпрограмм с параметрами.

<p>Среди команд есть знаковые и беззнаковые умножение и деление. Есть даже уникальные команды десятичной корректировки для команд умножения и деления. Трудно сказать, что в системе команд 8086 чего-то явно не хватает. Скорее наоборот. Деление 32-разрядного делимого на 16-разрядный делитель с получением 32-разрядного частного и 16-разрядного остатка может потребовать до 300 тактов &ndash; не особенно быстро, но в несколько раз быстрее, чем такое деление на любых 8-битных процессорах (кроме 6309) и сравнимо по скорости с 68000. Деление на х86 имеет одну неожиданную и скорее неприятную особенность &ndash; оно непредсказуемо меняет флаги признаков.

<p>Стоит ещё добавить, что в архитектуре x86 осталось унаследованная от 8080 команда XCHG, которая была усовершенствованна. Интересно, что в архитектуре x86 для команды NOP используется <code class=code>XCHG AX,AX</code>. Из-за этого NOP получился сравнительно медленным, 3-тактовым. И это сохранялось до 80486! Можно удивляться, почему для NOP не выбрали 2-тактовую <code class=code>MOV AX,AX</code>. Подобных бесполезных операций MOV 8086 имеет всего 16 &ndash; это больше, чем Z80. Для XCHG бесполезных инструкций набирается даже 71, так как, например, эквивалентные инструкции <code class=code>XCHG BX,CX</code> и <code class=code>XCHG CX,BX</code> кодируются по-разному. XCHG &ndash; это редкий случай, когда AX обычно кодируется не как регистр общего назначения: XCHG с AX короче на один байт и быстрее на один такт, чем общий случай, и, кроме того, из-за очереди команд, обычно быстрее, чем MOV. Однако, 7 более длинных и медленных инструкций XCHG, когда AX кодируется обычным образом &ndash; это особо некрасивая часть упомянутых бесполезных инструкций. В более поздних процессорах стали использоваться инструкции XADD, CMPXCHG и CMPXCHG8B, которые также могут выполнять атомарно обмен аргументов. Такие инструкции &ndash; одна из особенностей х86, их трудно встретить на процессорах других архитектур.

<p>Можно резюмировать, что 8086 &ndash; это очень удачный процессор, сочетавший в себе как удобство программирования, так и привязанность к характерным для своего времени ограничениям по объему памяти. 8086 использовался сравнительно редко, уступив более дешевому 8088 почетное место быть первым процессором для основной для персональных компьютеров нашего времени архитектуры IBM PC. 8088 использовал 8-разрядную шину данных, что делало его несколько более медленным, но зато позволяло строить на его основе более доступные покупателям системы.

<div align=center>
<p><img src=https://habrastorage.org/webt/m3/_i/jg/m3_ijgxxxf9p-uh7tpyt03n2ihy.jpeg width=50%>
<p style=font-size:90%>IBM 5150 или первый IBM PC
</div>

<p>Интересно, что Intel принципиально отказалась вносить усовершенствования в свои процессоры, предпочитая вместо этого разрабатывать их следующие поколения. Один из крупнейших субподрядчиков (second source) Intel, японская корпорация NEC, которая в начале 80-х была намного крупнее Intel, решила усовершенствовать 8088 и 8086, выпустив процессоры V20 и V30, совместимые с ними по разъёму и до 30% более быстрые. NEC даже предложила Intel стать своим субподрядчиком! Intel вместо этого начала судебный процесс против NEC, который, однако, не смогла выиграть. Почему-то эта большая разборка между Intel и NEC совершенно проигнорирована википедией.

<p>80186 и 80286 появились в 1982. Таким образом Intel имела две почти независимые команды разработчиков. Тогда же появился и 80188, который отличался от 80186 только узкой шиной данных, &ndash; в Intel никогда не забывали о недорогих решениях для встроенных систем. 80186 &ndash; это улучшенный несколькими командами и сокращенными таймингами 8086 плюс несколько встроенных в чип схем, типичных для архитектуры х86: генератором тактов, таймерами, DMA/ПДП, контроллером прерываний, генератором задержек и др. Такой процессор, казалось бы, мог бы сильно упростить производство основанных на нём компьютеров, но из-за того, что встроенный контроллер прерываний оказался почему-то не совместимым с IBM PC, в ПК он почти никогда не использовался. Автору известна только система BBC Master 512 на основе компьютера BBC Micro, который не использовал встроенные схемы, даже таймер, но было ещё несколько систем, использующих 80186. Адресуемая память у 80186 осталась в как и у 8086 размером в 1 МБ. Японская корпорации NEC производила аналоги 80186, которые были совместимы с IBM PC.

<p>Рассмотрим новые инструкции 80186:
<ul>
<li>однобайтовые инструкции PUSHA и POPA, позволяющие за раз сохранить или восстановить все 8 регистров;
<li>трехоперандное знаковое умножение, уникальное в архитектуре x86, оно больше похоже на инструкцию для ARM;
<li>битовые сдвиги и вращения, с аргументом числом &ndash; в 8086 можно было использовать только число 1 или регистр CL. Для аргумента 1 можно использовать два варианта инструкций, быструю и короткую, унаследованную от 8086, или обобщенную, более длинную и медленную для любых числовых аргументов, что скорее бесполезно;
<li>строковые команды для работы с портами ввода-вывода, они несколько мощнее подобных, имеющихся у Z80;
<li>инструкции ENTER и LEAVE &ndash; поддержка работы с подпрограммами на языках высокого уровня. Они умеют работать с синтаксической вложенностью подпрограмм до 32 уровня &ndash; использование такого типа вложенности характерно для языка паскаль. Однако для паскаля наверное не найти ни одной программы, где была бы вложенность больше 3. Да и сам паскаль с тех пор применяется всё реже и реже. Тут можно заметить, что Motorola также добавила поддержку паскаля в 68020, о чем потом вспоминали с сожалением;
<li>команда BOUND для проверки допустимости индекса массива.
</ul>

<p>80286 имел ещё лучшие тайминги, чем 80186, среди которых особо выделяется просто фантастическое деление (32/16=16,16) за 22 такта &ndash; с тех пор деление делать быстрее так и не научились! 80286 поддерживает работу с всеми новыми командами 80186 плюс много команд для работы в новом, защищенном режиме. 80286 стал первым процессором с встроенной поддержкой защищенного режима, который позволял организовать защиту памяти, правильное использование привилегированных инструкций, доступ к виртуальной памяти. Хотя работа в новом режиме сравнительно редко использовалась, это был большой прорыв вперёд. В этом новом режиме сегментные регистры приобрели новое качество, позволяя использовать до 16 МБ адресуемой памяти и до 1 ГБ виртуальной памяти на задачу. Главной проблемой 80286 была невозможность переключаться из защищенного режима в реальный, в котором работали тогда большинство программ. Используя "секретную" недокументированную инструкцию LOADALL, можно было использовать 16 МБ в памяти и в реальном режиме.

<p>В 80286 вычисление адресов в операндах инструкций стало производиться отдельными схемами и перестало замедлять исполнение команд. Это добавило интересные возможности, например, командой <code class=code>LEA AX,[BX+SI+4000]</code> всего за 3 такта стало возможным выполнить два сложения и перенос результата в регистр AX!

<p>Сегментные регистры в защищенном режиме стали частью полноценной системы управления памятью (MMU). В реальном режиме эти регистры, как это уже упоминалось, лишь частично обеспечивали функциональность MMU.

<p>Число производителей и конкретных систем, использующих 80286 огромно, но, конечно, первыми стали компьютеры IBM PC AT с почти фантастическими среди персональных компьютеров показателями по быстродействию. С этих компьютеров память начала отставать по быстродействию от процессора, появились состояния задержки, но тогда это казалось ещё чем-то временным.

<p>У 80286, как и у 8086/8088, работа с прерываниями была реализована не на 100% корректно, что в очень редких случаях могло приводить к весьма неприятным последствиям. Например, команда POPF у 80286 всегда разрешала прерывания при своём исполнении, а при исполнении команды с двумя префиксами (в качестве примера можно взять <code class=code>REP ES:MOVSB</code>) на 8086/8088 после вызова прерывания один из префиксов терялся. Ошибка в POPF была только у ранних выпусков 80286.

<p>Защищенный режим 80286 был скорее неудобен, делил всю память на сегменты размером не более 64 КБ и требовал непростой программной поддержки работы с виртуальной памятью. Сегментный способ работать с памятью явно уступал почти по всем характеристикам страничному.

<p>80386, появившись в 1985, сделал работу в защищенном режиме вполне комфортной, позволил использовать до 4 ГБ адресуемой памяти и легко переключаться между режимами. Кроме того, для поддержки многозадачности для программ для 8086 был сделан режим виртуального 8086. Для управления памятью стало возможным использовать как большие сегменты размером до 4 ГБ, так и удобный страничный режим. 80386 при всех своих новшествах сохранил полную совместимость с программами, написанными для 80286. Среди новшеств 80386 можно ещё назвать вытягивание регистров до 32-бит и добавление двух новых сегментных регистров. Кроме того, при вычислении адреса все регистры стали равноправными и стало возможным использовать масштабирование. Однако, это равноправие регистров добавило много бесполезных и некрасивых инструкций-двойников. Тайминги изменились, но неоднозначно. Был добавлен быстрый битовый сдвигатель (barrel shifter), что позволило делать множественные сдвиги с таймингами одного. Однако, это новшество очень сильно почему-то очень замедлило исполнение команд циклических сдвигов. Умножение стало чуть медленнее, чем у 80286. Работа с памятью стала, наоборот, чуть быстрее, но это не относится к строковым командам, которые остались быстрее у 80286. Автору этого материала не раз приходилось сталкиваться с мнением, что в реальном режиме с 16-битным кодом 80286 в итоге всё же чуть-чуть быстрее, чем 80386 на той же самой частоте.

<p>В 80386 были добавлены новые команды, большинство из которых лишь давали новые способы для работы с данными, фактически дублируя с оптимизацией для некоторых случаев имеющиеся. Например, были добавлены команды:

<ul>
<li>для проверки, установки и сброса бита по номеру, похожие на те, что были сделаны для z80;
<li>побитового сканирования BSF и BSR;
<li>копирования значения со знаковым или нулевым расширением, MOVSX и MOVZX;
<li>установки значения в зависимости от значений флагов операций SETxx;
<li>сдвигов сдвоенных величин SHLD, SHRD &ndash; похожие команды есть на мейнфреймах IBM.
</ul>

<p>Процессоры x86 до появления 80386 могли использовать только короткие, со смещением один байт условные переходы &ndash; этого было часто очень недостаточно. С 80386 стало возможным использовать смещения из двух или четырех байт, причем несмотря на то, что код новых переходов стал в два или три раза длиннее, время его исполнения осталось таким же как и у прежних, коротких переходов.

<p>Радикально была улучшена поддержка отладки введением 4-х аппаратных точек останова, используя их, стало возможным останавливать программы даже на адресах в памяти, которую нельзя изменять.
 
<p>Вследствие того, что основной защищенный режим стал гораздо проще для управления, чем в 80286, ряд унаследованных команд стали ненужными рудиментами. В этом основном защищенном, так называемом flat-режиме используют сегменты размером до 4 ГБ, что превращает все сегментные регистры в малозаметную формальность. А полудокументированный нереальный режим позволил даже использовать всю память как и во flat-режиме, но из простого для установки и управления реального режима.

<p>С 80386 фирма Intel отказалась делиться своими технологиями, став фактически монопольным производителем процессоров для архитектуры IBM PC, а с ослаблением позиций Motorola, и для других архитектур персональных компьютеров. Системы на основе 80386 были очень дороги до начала 90-х, когда они стали наконец доступны массовым потребителям на частотах от 25 до 40 МГц. C 80386 IBM стала утрачивать позиции ведущего производителя IBM PC совместимых компьютеров. Это проявилось, в частности, в том, что первым ПК на основе 80386 стал в 1986 компьютер фирмы Compaq.

<p>Трудно не сдержать восхищение теми объёмам работы, которая была проделана создателями 80386 и её результатами. Осмелюсь даже высказать предположение, что 80386 заключает в себе больше достижений, чем все технологические достижения человечества до 1970, а может и до 1980. Интересно, что команда разработчиков 80386 отличалась своеобразной и открытой религиозностью.

<p>Довольно интересна тема ошибок в 80386. Напишу про две. Первые чипы имели некоторые команды, которые затем исчезли из руководств по этим процессорам и перестали исполняться на более поздних чипах. Если использовать первые источники информации по 80386 практически, может случиться неожиданное затруднение. Речь идет о командах IBTS и XBTS. У всех 80386DX/SX, производимых как AMD, так и Intel (что обнаруживает их любопытную внутреннюю идентичность), есть очень странный и неприятный баг, который проявлялся в уничтожение значения регистра EAX, если после записи в стек или выгрузке оттуда всех регистров командами POPAD или PUSHAD использовалась команда, использовавшая адрес с регистром BX. В некоторых ситуациях процессор мог даже зависнуть. Просто кошмарный баг и очень массовый, а в википедии нет даже упоминаний про него. Были и другие баги.

<p>Появление ARM изменило ситуацию в мире компьютерных технологий. Несмотря на проблемы, процессоры ARM продолжали своё развитие. Ответом Intel стал 80486. В борьбе за быстродействие и за первое место в мире передовых технологий Intel пошла даже на уродующее до сих облик персонального компьютера решение &ndash; использование охлаждающего вентилятора.

<p>В 80486 были улучшены тайминги большинства инструкций и некоторые из них стали выполняться как и на процессорах ARM за такт. Хотя умножение и деление почему-то стали чуть медленнее. Особенно странно, что однократные двоичные сдвиги и вращения регистра стали выполняться даже медленнее, чем с 8088! Появилась довольно большая для тех лет, размером 8 КБ, встроенная кэш-память. Появились и новые инструкции, например, CMPXCHG &ndash; она заняла место незаметно пропавших инструкций IBTS и XBTS (любопытно, что в качестве секретной эта инструкция была доступна уже и на поздних 80386). Новых инструкции совсем немного &ndash; всего шесть, из которых стоит упомянуть весьма полезную команду для смены порядка байт в 32-разрядном слове BSWAP. Большой полезной новинкой стало наличие встроенного в чип арифметического сопроцессора &ndash; так ещё никто не делал. Была также улучшена работа очереди команд.

<p>Первые системы на базе 80486 были невероятно дороги. Довольно необычно, что первые компьютеры на базе 80486, модель VX FT, сделала английская фирма Apricot &ndash; их цена в 1989 была от 18 до 40 тысяч долларов, а вес системного блока &ndash; более 60 кг! Хотя появление именно здесь компьютерных систем на базе новейшего процессора Intel могло быть вызвано логикой конкуренции с ARM и Acorn. IBM выпустила первый компьютер на базе 80486 в 1990, это была модель PS/2 90 стоимостью $17000. 

<p>Трудно себе представить процессоры Intel без секретных, недокументированных официально возможностей. Часть таких возможностей скрывали от пользователей, начиная с самых первых 8086. Например, такой пусть и почти никому не нужный факт, что второй байт в инструкциях десятичной коррекции AAD и AAM имеет значение и может быть другим, вообще недесятичным (это было документировано только с процессора Pentium спустя 15 лет!). Более неприятно умолчание сокращенных команд AND/OR/XOR с операндом байтовой константой, например, AND BX,7 с опкодом длиной три байта (83 E3 07). Эти команды, делающие код более компактным, что было особенно важно с первыми ПК, были тихо вставлены в документацию только по 80386. Интересно, что в фирменных руководствах по 8086 или 80286 есть намек об этих командах, но конкретных опкодов по ним там нет. В отличие от похожих инструкций ADD/ADC/SBB/SUB, по которым была предоставлена полная информация. Это, в частности, привело к тому, что многие ассемблеры (все?) не умели производить более короткие коды. Ещё одна группа секретов скорее может быть названа некоторой странностью &ndash; ряд инструкций имеют по два кода операций. Речь идёт, например, об инструкциях SAL/SHL (опкоды D0 E0, D0 F0 или D1 E0, D1 F0) и некоторых других. Обычно, а может и всегда, используется только один код операции. Второй, секретный не используется практически никогда. Можно только удивляться, почему Intel так бережно сохраняет эти лишние, захламляющие пространство опкодов неофициальные дублирующие инструкции? Инструкция SALC ждала своего официального документирования до 1995 почти 20 лет! Инструкция для отладки ICEBP была официально несуществующей 10 лет с 1985 по 1995. Более всего писалось про тайные инструкции LOADALL и LOADALLD &ndash; они так навсегда и останутся тайными, так как их можно было использовать для простого доступа к большим объемам памяти только на 80286 и 80386 соответственно. До недавнего времени сохранялась интрига вокруг инструкции UD1 (0F B9), которая неофициально являлась примером неправильного опкода. Неофициальное недавно стало официальным.

<p>В СССР был освоен выпуск клонов процессоров 8088 и 8086, а полностью воспроизвести 80286 так и не получилось. Удалось реализовать только расширенную систему команд 80186 и отдельный чип для управления памятью, что должно было позволять запускать программы для 80286.


<h2 id=m68k>Motorola: от 68000 до 68040</h2>

<p>Motorola &ndash; это единственная фирма, которая какое-то время могла успешно конкурировать с Intel в области производства процессоров для персональных компьютеров. В 1980 Motorola фактически поставила Intel в ситуацию кризиса, из которого та могла выйти только мобилизовав все свои силы и организовав группу сокрушения (Crush Group) своих конкурентов, действия которой несколько нарушали антимонопольное законодательство США.

<p>68000 был выпущен в 1979 и на первый взгляд выглядел гораздо внушительнее 8086. Он имел 16 32-разрядных регистров (точнее даже 17), отдельный счетчик команд и регистр состояний. Мог адресовать 16 МБ памяти напрямую, что не создавала никаких ограничений, например, для больших массивов. Однако, внимательный анализ особенностей 68000 показывает, что не всё так хорошо, как кажется. В те годы иметь память более 1 МБ &ndash; это недостижимая роскошь даже для средних по размеру организаций. Плотность кодов у 68000 хуже, чем у 8086 &ndash; а значит коды с той же функциональностью занимают у 68000 больше места. Последнее связано и с тем, что коды у 68k должны быть кратными 2 байтам по длине, а у х86 &ndash; 1. Но информация о плотности кодов спорная, так как есть свидетельства, что в некоторых случаях у 68000 она может быть лучше, чем у 8086. Из 16 регистров &ndash; 8 адресные, в чём-то это чуть более продвинутые аналоги сегментных регистров x86. АЛУ и шина данных 16-разрядные, поэтому операции с 32-битными данными медленнее, чем можно ожидать. Время исполнения операций типа регистр-регистр &ndash; 4 такта, а у 8086 &ndash; только 2. Компьютеры на базе 68000 до середины 80-х получались гораздо более дорогими, чем на базе Intel 8088, но 68000 не мог работать с виртуальной памятью и не имел аппаратной поддержки работы с вещественными числами, что делало его непригодным для использования в самых продвинутых системах. Для поддержки использования виртуальной памяти требовался ещё один процессор, обычно для этого использовали ещё один 68000. В 1982, как отмечал Bill Joy, в Sun начали разработку своего процессора, так как 68000 не соответствовал нуждам заказчиков по производительности и, особенно, для работы с вещественными числами. Интересно, что из-за большого размера 68000 в Motorola называли "техасский таракан".

<p>Однако, большой размер позволил втиснуть больше функциональности. Например, 68000 может без внешнего контроллера обслуживать до 8 внешних прерываний. Архитектура x86 требует наличия внешнего контроллера прерываний (относительным исключением является только 80186). Шины данных и адреса у 68000 не мультиплексированы в отличие от 8086, в Intel только с 80286 отказались от такого тормозящего систему совмещения шин.

<p>Как всегда, с изделиями от Motorola, архитектура 68000 показывает несколько неуклюжестей и надуманных странностей. Например, два стека (от второго стека отказались в самых популярных сегодня 68k процессорах <a href=https://ru.wikipedia.org/wiki/Freescale_ColdFire>Coldfire</a>) или два флага переноса (один для признаков, а другой для операций). Несмотря на наличие двух флагов переноса, операции сложения и вычитания с переносом поддерживают только два режима адресации, что делает их гораздо менее удобными подобных операций на x86, &ndash; 68000, таким образом, сохранил некоторую неуклюжесть таких операций свойственную IBM/370 и, отчасти, PDP-11. На этом странности с флагами не заканчиваются. Почему-то многие команды, включая даже MOVE, зануляют флаги признака переноса и переполнения. Другая странность, что команда для сохрания состояния арифметических флагов, которая работала нормально в 68000, сделана привилегированной во всех процессорах, начиная с 68010. Это, в частности, сделало невозможным использование единой операции для сохранения флагов для 68000 и более поздних процессоров 68k. Таким образом, сохранить флаги как на x86 командами PUSHF или SAHF на 68k единым образом нельзя! Возможно Motorola не стоило делать команду <code class=code>MOVE from SR</code> привилегированной, а вместо этого следовало изменить её так, чтобы она в пользовательском режиме всегда возвращала фиксированную информацию о некоторых системных флагах. Некоторые операции раздражают своей неоптимизированностью, например, операция записи нуля в память CLR работает медленнее записи константы 0 в память командой MOVE или сдвиг влево медленнее сложения операнда с самим собой. Есть некоторые практически лишние команды, например, есть как арифметические, так и логические сдвиги влево. Даже адресные регистры при кажущимся на первый взгляд преимуществе перед сегментными регистрами 8086, имеют ряд раздражающих недостатков. Например, в них требовалось грузить целых 4 байта вместо двух у 8086 и из этих четырех один был лишний. Система команд 68000 обнаруживает много сходства с системой команд PDP-11, разработанной ещё в 60-е, хотя некоторые методы адресации и порядок байт взяты почти наверняка от IBM/370. Адресация через базу и индексный регистр сделана в 68000 на уровне 8-битных 6800 или Z80, с однобайтным смещением &ndash; это как-то совершенно непрактично, в 8086 смещение 16 разрядов, в ARM или IBM/370 &ndash; 12. Даже 6502 может использовать 16-разрядное смещение c индексацией. Нормальное смещение стало поддерживаться только с 68020. Сюрпризы на 68k могут возникнуть с необычной командой цикла, в которую надо передавать не число повторений, а число на единицу меньшее. 68k ещё не хватает инструкции подобной TEST для 8086. Несмотря на большие возможности компании Motorola, 68000 был изначально сделан по сравнительно старой технологии, которая уступала даже той, что использовали при производстве 6502.

<p>Коды для Motorola 68k выглядят как-то более громоздко и неуклюже по сравнению с х86 или ARM. С другой стороны, 68000 всё же побыстрее 8086, по моим оценкам примерно на 20-30%. Кодам 680x0 к тому же присуща и какая-то своя особенная красота и элегантность, меньшая механистичность, характерная для x86. Кроме того, как показало общение с экспертами eab.abime.net, плотность кодов у 68k часто лучше, чем у x86. 68000, как и ARM или VAX, может в качестве базы использовать PC, что очень удобно. x86 и даже IBM/370 этого не умеют &ndash; поддержка такой адресации появилась только у x86-64. Хотя, стоит отметить, что адресации по PC у 68к доступна только для операнда-источника, для операнда-приёмника она не работает, что делает её заметно менее полезной. Наличие большего числа регистров у 68000 также существенное преимущество по сравнению с 8086, хотя из-за невозможности на 68000 быстро использовать отдельные байты 16-битного слова, это преимущество проявляется только при обработке 16- и 32-разрядных данных. Очень хорошо для 68к сделаны операции инкремента и декремента, которые позволяют использовать шаг от 1 до 8 &ndash; в x86 и большинстве других известных архитектур шаг всегда равен 1. 68k имеет очень гибкую и удобную инструкцию MOVEM, которая позволяет сохранять или восстанавливать любое множество регистров, &ndash; подобная инструкция есть и для ARM, а в x86 приходиться для таких операций использовать много команд для сохранения или восстановления отдельных регистров. Но MOVEM занимает 4 байта, поэтому когда нужно сохранять или восстанавливать не более трех регистров, код на x86 получается более компактным. Кроме того, x86 (c 80286) имеет ещё команду для сохранения и восстановления сразу всех регистров, поэтому в общем случае преимущество 68k из-за наличия MOVEM не слишком значительно. Весьма привлекательная черта архитектуры 68k &ndash; это адресные режимы с авто-инкрементом и -декрементом, таких на x86 нет. Независимость пользовательского стека от прерываний позволяет использовать данные над вершиной стека, что немыслимо на 8086. Такой очень странный и нерекомендуемый способ работы со стеком доступен и на x86 в многозадачных средах, где у каждой задачи и у системы есть свои стеки.

<p>В целом, 68000 &ndash; это хороший процессор, с большой системой команд. Его изначально планировали для использования в миникомпьютерах, а не персоналках. Именно под 68000 начинается разработка рабочих станций фирмами Sun, Apollo, HP, Silicon Graphics и позднее NeXT. В этот список можно добавить и Apple, которая производила компьютер Lisa класса рабочих станций. 68000 использовали во многих ныне легендарных персональных компьютерах: в первых компьютерах Apple Macintosh, которые выпускались до начала 90-х, в первых мультимедийных компьютерах Commodore Amiga, в сравнительно недорогих и качественных компьютерах Atari ST. 68000 также использовался в относительно недорогих компьютерах, работающих с вариантами Unix, в частности, в довольно популярном Tandy 16B. Интересно, что IBM одновременно с разработкой PC вела разработку компьютера System 9000 на базе 68000, который был выпущен менее чем через год после PC. 

<div align=center>
<p><img src=https://habrastorage.org/webt/bb/6q/iu/bb6qiuatbww6hvwaqzjs5gzv6oi.jpeg style=width:50%>
<p style=font-size:90%>Apple Lisa &ndash; странно, что у первых компьютеров Apple на базе 68000 (Lisa и Macintosh) графика была черно-белой, тогда как у восьмибитников Apple ][ она была цветной
</div>
<div align=center>
<p><img src=https://habrastorage.org/webt/7p/1w/bv/7p1wbvftf4q8trooqzrsxk57wq0.gif>
<p style=font-size:90%>Это известная демка для Amiga 1000, такая графика в 1985 казалась невероятной фантастикой. Это картинка в формате GIF, что позволяет показывать только 256 цветов из 4096, показываемых реальной Амигой, &ndash; другие форматы для полноцветной анимированной графики всё ещё поддерживаются недостаточно хорошо
</div>

<p>68010 появился явно запоздало, только в 1982, тогда же Intel выпустила 80286, поставивший персональные компьютеры на уровень мини-ЭВМ. 68010 совместим по разъёму с 68000, но система его команд чуть-чуть отличается, поэтому замена 68000 на 68010 так и не стала популярной. Несовместимость была вызвана надуманной причиной привести 68000 в большее соответствие с идеальной теорией организации поддержки виртуализации. 68010 лишь незначительно, не более чем на 10% быстрее 68000. Очевидно, что 68010 сильно проигрывал 80286 и был даже послабее появившегося в том же году 80186. Как и 80186, 68010 практически так и не нашёл себе применения в персональных компьютерах.

<p>68008 был также выпущен в 1982 наверное с надеждой повторить успех 8088. Это 68000, но с 8-разрядной шиной данных, что позволяло использовать его в более дешевых системах. Но 68008, как и 68000, не имеет очереди команд, что делает его на примерно 50% медленнее, чем 68000. Таким образом, 68008 может быть даже чуть медленнее, чем 8088, который из-за наличия очереди команд лишь на примерно 20% медленнее, чем 8086. IBM предлагала Motorola сделать 68008 к 1980, но тогда IBM отказали, хотя это стоило бы по признанию сотрудников Motorola работы одному сотруднику только менее месяца. Если бы отказ не случился, то возможно IBM выбрала бы 68008 для IBM PC.

<p>На основе 68008 сэр Клив Синклер сделал Spectrum QL &ndash; очень интересный компьютер, который из-за более низкой цены мог бы конкурировать с Atari ST и похожими компьютерами. Но Клив параллельно и явно преждевременно стал очень много сил вкладывать в развитие электромобилей, оставив QL (Quantum leap &ndash; квантовый скачок) скорее как второстепенную задачу, что при наличии некоторых неудачных конструктивных решений, привело компьютер и всю фирму Клива к преждевременному закрытию (фирма стала частью компании Amstrad, которая отказалась производить QL).

<p>Было бы интересно посчитать индекс разрядности для 68000, он, как мне кажется, явно повыше 16, хотя скорее и не выше 24.

<p>Появившись в 1984, 68020 опять вернул Motorola на первые позиции. В этом процессоре были реализованы многие очень интересные и перспективные новинки. Самый сильный эффект безусловно производит конвейер инструкций, позволяющий иногда выполнять до трёх инструкций одновременно! 32-разрядная шина адреса выглядела в те годы несколько преждевременной и поэтому выпускался более дешёвый вариант процессора 68020EC с 24-битной шиной. Зато 32-разрядная шина данных выглядела уже вполне уместно и позволяла значительно ускорить работу. Новинкой выглядел и встроенный кэш пусть и небольшого, 256 байт, объема, что позволяло иногда значительно улучшить быстродействие, так как основная динамическая память уже не успевала за процессором. Хотя в общем случае такой маленький кэш лишь незначительно влиял на производительность. Были добавлены достаточно быстрые операции для деления (64/32=32,32) и умножения (32*32=64), за примерно 80 и до 45 тактов соответственно. Тайминги инструкций были в целом значительно улучшены, например, деление (32/16=16,16) стало выполняться за примерно 45 тактов (более 140 тактов у 68000). Некоторые инструкции в самых благоприятных случаях могут исполняться, не занимая тактов вообще! Были добавлены новые адресные режимы, в частности, с масштабированием &ndash; у x86 такой режим появился только в следующем году у 80386. Другие новые адресные режимы позволяют использовать двойную косвенную адресацию, используя при этом несколько смещений, &ndash; PDP-11 был здесь заметно превзойден.

<p>Но некоторые новые инструкции, например, тяжеловесные операции с битовыми полями или ставших малонужными при быстрых делении и умножении новые операции с 10-и числами, выглядели скорее пятым колесом у телеги, чем чем-то существенно полезным. Адресные режимы с двойной косвенной адресацией теоретически выглядят интересно, но практически нужны довольно редко и исполняются очень медленно. Возможность использования 32-разрядного смещения в адресации была скорее преждевременным новшеством, так как для объемов памяти на системах до середины 90-х такие большие смещения практически никогда не требовались. Тут опять, как и в случае с 68000, Motorola предложила пользователям платить за возможность работать с такими большими размерами памяти, которые ещё фактически не могли быть аппаратно обеспечены. В отличие от 80286, 68020 требует времени для вычисления адреса операнда, так называемого эффективного адреса. Деление у 68020 получилось всё же почти в два раза медленнее чудо-деления у 80286. Умножение и некоторые операции также медленнее. У 68020 нет встроенной системы управления памятью (MMU) и скорее экзотическая возможность подключать до восьми сопроцессоров этого не могла исправить. Сам главный архитектор 68000 признал, что в 68020 было сделано слишком много режимов адресации и что получился поэтому какой-то монстр. Типа ориентировались на VAX и удобство ассемблерного программирования, а будущее пришло с RISC, высокими скоростями и мощными компиляторами. А вот ещё цитата от Билла Джоя: "Стало ясно, что Motorola развивает свои процессоры примерно также ошибочно как и DEC. Другими словами, 68010 68020 68040, становились более и более сложными. И они буксовали, не становясь быстрее такими же темпами как транзисторы, из которых они были сделаны".

<p>Неудивительно поэтому, что в современном развитии архитектуры 68k отказались практически от всех новых команд 68020. Это касается, в частности, процессоров Coldfire и 68070, используемых во встроенных системах.

<p>68020 широко использовался в массовых компьютерах Apple Macintosh II, Macintosh LC и Commodore Amiga 1200. Он также использовался в нескольких моделях систем для работы с Unix.

<p>Появление 80386 со встроенным и очень добротно сделанным MMU и 32-разрядными шинами и регистрами, опять поставило Motorola в позицию номер 2. 68030, появившись в 1987, в последний раз, ненадолго смог вернуть Motorola лидерство. 68030 имеет встроенную систему управления памятью и увеличенный в два раза кэш, разделенный на кэш для инструкций и данных &ndash; это была очень перспективная новинка. Кроме того, 68030 мог использовать более быстрый интерфейс доступа к памяти, что может ускорять операции с памятью почти на треть. Однако, в целом работа с памятью осталась медленной &ndash; 4 такта на обращение, т.е. число тактов осталось таким же как и у 68000. Об этом даже шутили как о "стандартном цикле памяти Motorola". Для сравнения, у 80286 такой цикл занимал 2 такта, а у ARM или 6502 &ndash; 1. Справедливости ради надо добавить, что официально цикл доступа к памяти у 68020 и 68030 занимает 3 такта, но во многих инструкциях фактически получается скорее 4. Несмотря на все новшества, 68030 оказался несколько медленнее 80386 на одинаковых частотах. Однако, 68030 был доступен на частотах до 50 Мгц, а 80386 только до 40 Мгц, что делало топовые системы на базе 68030 слегка быстрее. Неожиданно, но 68030 не поддерживает некоторые инструкции своего предшественника, например, CALLM и RTM! Недостатки архитектуры процессоров 68k вынудили основных производителей компьютеров на базе этих процессоров искать им замену. Sun начала производить собственные процессоры SPARC, Silicon Graphics перешла на процессоры MIPS, Apollo разработала собственный процессор PRISM, HP стала использовать собственный процессоры PA-RISC, ATARI стала работать со специализированными RISC-процессорами, а Apple была вынуждена перейти на процессоры PowerPC. Интересно, что Apple собиралась перейти на SPARC во второй половине 80-х, но договориться с Sun не получилось. Можно только удивляться тому, как плохо работал менеджмент у Motorola, они как будто сами не верили в будущее своих процессоров.

<p>68030 использовался в компьютерах серии Apple Macintosh II, Commodore Amiga 3000, Atari TT, Atari Falcon и некоторых других.

<p>С 68040 Motorola очередной раз попыталась превзойти Intel. Этот процессор появился год спустя после 80486, но по совокупности полезных качеств он так и не смог его превзойти. Фактически Motorola 68k, имея более перегруженную систему команд, оказалась не в состоянии её поддерживать и в каком-то смысле сошла с дистанции. Кроме того, Motorola участвовала также в разработке PowerPC, который запланировано шел на смену 68k и это не могло не сказаться на качестве разработки 68040. В 68040 смогли поместить только очень урезанный сопроцессор для работы с вещественными числами и сам чип грелся существенно больше, чем 80486. Согласно результатам на lowendmac.com/benchmarks 68040 только примерно в 2.1 раза быстрее 68030, что означает, что 68040 несколько медленнее 80486 на той же частоте. 68040 практически не нашёл применения в популярных компьютерах. Некоторое заметное применение нашёл только его более дешёвый вариант &ndash; 68LC040, не имеющий встроенного сопроцессора. Однако, первые варианты этого чипа имели серьёзный аппаратный дефект, не позволяющий использовать даже программную эмуляцию сопроцессора!

<p>Проблемы с математическим сопроцессорами у Motorola были всегда. Motorola, как уже об этом упоминалось, так и не выпустила такого сопроцессора для 68000/68010, в то время как Intel выпускала свой очень успешный 8087 c 1980. Для процессоров 68020/68030 производились сразу два сопроцессора 68881 и его улучшенный пин-совместимый вариант 68882. Но для получения существенного прироста производительности код для 68882 нужно компилировать не так как для 68881.

<p>Тут уместно сказать, что и Intel x86 пор сих имеет проблемы с математическим сопроцессором &ndash; точность расчетов некоторых функций, например, синуса на некоторых аргументах совсем небольшая, иногда не более 4 знаков. Поэтому современные компиляторы часто вычисляют такие функции, не прибегая к услугам сопроцессора.

<p>Удивительно, что Motorola смогла ещё выпустить 68k процессор класса Pentium, 68060 в 1994. Этот процессор также имел проблемы с арифметикой вещественных чисел. И, главное, ни осталось ни одной популярной системы, кроме Commodore Amiga, где 68060 мог бы найти применение, но компания Commodore обанкротилась в том же 1994.

<p>Процессоры Motorola вплоть до 1994 включительно были в целом вполне сравнимы с Intel x86 и в отдельных важных частностях они были всегда лучше. Однако в Intel, в отличие от Motorola, очень много сил потратили на удержание своих заказчиков и привлечения новых. И иногда в борьбе со своим основным конкурентом Intel действовала почти некрасиво. Трудно поверить, что большая обзорная статья в журнале Byte от 9/1985, где про 68000 огульно заявляется, что он "по сравнению 8088 требует огромных усилий для того, чтобы программы работали нормально", могла появиться вне контекста этой борьбы. С другой стороны, Motorola все делала позже и дороже Intel. Кроме того, процессорам Motorola явно не хватало оригинальности, слишком многое было скопировано с технологий DEC и IBM. Конечно, провал 68к был вызван комплексными причинами, сочетающими в себе как слабый стратегический маркетинг, так и некоторые архитектурные недостатки.

<p>Почему-то процессоры архитектуры 68k даже не пытались склонировать в СССР, хотя на основе 68020 был разработан компьютер <a href=https://ru.wikipedia.org/wiki/%D0%91%D0%B5%D1%81%D1%82%D0%B0_(%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80)>Беста</a>.

<h2 id=ns32016>National Semiconductor 32016</h2>

<p>Это первый настоящий 32-битный процессор, предложенный для использования в компьютерах ещё в 1982. Это процессор изначально планировался как VAX-11 на чипе, но из-за невозможности договориться с фирмой DEC фирме National Semiconductor (NS) пришлось сделать процессор только отдельными деталями похожий на архитектуру VAX-11.

<p>С этого процессора начинается использование страничной виртуальной памяти &ndash; сегодня это доминирующая технология. Но поддержка виртуальной памяти не встроена в процессор, а требует сопроцессора. Отдельный сопроцессор требуется и для работы с вещественными числами.

<p>Система команд NS32016 огромна и похожа на систему команд VAX-11, в частности, наличием отдельного стека для кадров подпрограмм. Шина адреса 24-битная, что позволяет использовать до 16 МБ памяти. Особенностью 32016 является работа с флагами признаков. Помимо стандартных флагов переноса (который можно использовать и как признак для условного перехода), переполнения, знака, равенства (или нуля) есть ещё флаг L (less), означающий меньше &ndash; это как перенос для сравнений. Ситуация с переносом похожа на ту, что есть у процессоров Motorola 680x0. Флаг переполнения почему-то называется F. Есть флаги пошагового режима, привилегированного режима и (уникальность!) флаг выбора текущего стека. При выполнении арифметических инструкций флаги знака, нуля, меньшести (L) не ставятся, они устанавливаются только командами сравнения.

<p>Можно использовать восемь 32-разрядных регистров общего назначения. Кроме того, есть ещё счетчик команд, два указателя стека, указатель стека кадров подпрограмм, указатель базы программы (это что-то уникальное), указатель базы модулей (также что-то очень редкостное), указатель на таблицу векторов прерываний, регистр конфигурации и регистр состояния. По быстродействию NS32016 оказался сравним с 68000. 

<p>32016 насколько мне известно использовался только с персональными компьютерами BBC Micro как второй процессор. Это была очень дорогая и престижная приставка для 1984 года. Можно было заказывать процессор с частотами 6, 8 и 10 МГц. С последними возникали некоторые технические проблемы и он был очень дорог. Программного обеспечения для 32016 было очень мало, только сделанная силами Acorn, чем-то похожая на Unix операционная система Panos и постоянный спутник Acorn бейсик. BBC Micro не использовали чип MMU &ndash; хотя его можно было подключить, программ для его использования не было. Арифметический сопроцессор подключать даже и не предусматривалось.

<p>Известно, что этот очень сложный процессор имел серьёзные аппаратные ошибки, которые устранялись годами.


<h2 id=arm>Acorn ARM</h2>

<p>Идеология 6502, а именно делать проще, дешевле и лучше, нашла своё продолжение в почти фантастической разработке фирмы Acorn, процессоре ARM-1, выпущенном в 1985, тогда же, когда появилось технологическое чудо фирмы Intel, процессор 80386. ARM состоял из на порядок меньшего числа транзисторов и поэтому потреблял существенно меньше энергии и был при этом в среднем гораздо быстрее. Конечно, у ARM не было никакого MMU и даже операций деления и умножения, поэтому в некоторых расчетах, основанных на делении 80386 мог быть быстрее. Однако достоинства ARM оказались столь велики, что на сегодня это самая массовая процессорная архитектура. Было выпущено более 100 миллиардов таких процессоров.

<p>Разработки ARM в 1983 начались после того, как в фирме Acorn провели исследования с процессором 32016, которые показали, что на многих расчётах 6502 на два раза меньшей рабочей частоте мог быть быстрее этого, как казалось, гораздо более мощного процессора. Тогда уже был доступен 80286, который показывал очень хорошую производительность, но фирма Intel, возможно почувствовав немаленький потенциал небольшой фирмы Acorn, отказалась предоставить свой процессор для тестирования. При этом технология 80286 не была закрытой как 80386 и была передана многим фирмам, поэтому история до сих пор ждёт раскрытия деталей этого несколько необычного отказа. Возможно, если бы Intel разрешила использовать свой процессор, то в Acorn использовали бы именно его, а не стали бы разрабатывать ARM.

<p>ARM разрабатывали всего несколько человек, причем тестировали систему команд, используя бейсик BBC Micro. Сама разработка проходила в здании бывшего подсобного помещения, которое часто называют сараем или амбаром. Дебют процессора получился скорее неудачным. В 1986 была выпущена приставка для BBC Micro c названием ARM Evaluation system, содержащей помимо процессора 4 МБ памяти (это очень много для тех лет), что сделало эту приставку очень дорогим изделием (её цена была более 4000 фунтов стерлингов, т.е. примерно 6000 долларов). Конечно, если сравнивать её с компьютерами того времени со сравнимыми по быстродействию возможностями, то приставка оказывалась на порядок или даже почти два дешевле. Но для новой системы было очень мало программ. И это несколько странно, так как вполне было возможно портировать Unix для этой системы &ndash; тогда были доступны многочисленные варианты Unix, которые не требовали MMU, были варианты Unix для PDP-11, 68000, 80186 и даже 8088. Любопытно, что в 90-е для Acorn Archimedes был портирован Linux. Возможно задержка с появлением настоящего Unix для ARM была вызвана нежеланием Acorn передавать технологию ARM другим фирмам.

<div align=center>
<p><img src=http://www.computinghistory.org.uk/userdata/images/large/70/88/product-77088.jpg>
<p style=font-size:90%>Первая система на базе ARM
</div>

<p>Несколько неудачная маркетинговая политика Acorn привела фирму к 1985 к очень тяжелому финансовому положению. Acorn помимо ARM пыталась ещё вести дорогостоящую разработку компьютеров для бизнеса, которая провалилась, в частности, из-за недостатков выбранного для них процессора 32016. Не слишком удачным оказался также и компьютер Acorn Communicator. Разработка сравнительно удачного, но не совсем IBM PC совместимого компьютера Master 512, была весьма затратной. Кроме того, много финансовых ресурсов было потрачено в безрезультатной попытке выйти на рынок США, на который возможно в рамках гипотетической большой игры по поглощению самой Acorn была допущена итальянская фирма Olivetti со своими довольно удачными, основанными на Intel 8086 и 80286, компьютерами. Кстати, после поглощения Acorn, роль Olivetti на американском рынке довольно быстро сошла на нет. 

<p>Уже как часть Olivetti Acorn разработала улучшенный чип ARM2 со встроенными командами умножения, на основе которого был сделан потрясающий тогда своим быстродействием персональный компьютер <a href=https://ru.wikipedia.org/wiki/Acorn_Archimedes>Archimedes</a>, первые модели которого стали доступны в 1987. Однако, менежмент из Olivetti был ориентирован на работу с IBM PC совместимыми компьютерами и не желал использовать свои ресурсы для реализации продукции Acorn. Также удивительно, что Архимеды не пришли на смену BBC Micro в английских школах. Возможно это случилось из-за несостоявшейся сделки с СССР по компьютерам <a href=https://ru.wikipedia.org/wiki/Memotech_MTX512>Memotech MTX</a>. Memotech взяла миллион фунтов стерлингов у английского правительства, а после срыва сделки объявила себя банкротом. После этого правительство прекратило практику поддержки своих производителей компьютерной техники, включая Acorn.

<p>ARM предоставляет для использования 16 32-разрядных регистров (их реально больше, если учитывать регистры для системных нужд). Один из регистров, R15, подобно архитектуре PDP-11 является счётчиком команд. Почти все операции выполняются за 1 такт. Больше тактов нужно, в частности, для переходов, умножений и обращений к памяти. По сравнению, с основными процессорами тех лет ARM отличало отсутствие такой типовой структуры как стек. Стек реализуется, если необходимо, через один из регистров. При вызове подпрограмм стек не используется, вместо этого адрес возврата сохраняется в выделенном для него регистре. Такая схема, очевидно не работает для вложенных вызовов, для которых приходится организовывать стек. Уникальная особенность ARM &ndash; в совмещении счётчика команд, который 26-разрядный, т. е. позволяющий адресовать до 64 МБ, с регистром состояний. Для флагов в этом совмещенном регистре выделяется восемь бит, ещё два добавочных бита в этом регистре получаются за счёт того, что младшие два бита адреса не используются, так как коды должны быть выровнены по границе 4-байтного слова. Процессор может обращаться к байтам и 4-байтным словам, к 16-битным данным он напрямую обращаться не может. Инструкции для работы с данными у ARM 3-адресные. Характерной особенностью архитектуры RISC является использование команд типа регистр-память только для загрузки и выгрузки данных. ARM имеет встроенный быстрый битовый сдвигатель (Barrel Shifter), позволяющий без затрат тактов сдвигать значение одного из регистров в команде на любое число раз. Например, умножение значения регистра R0 на 65 c помещением результата в регистр R1 можно записать одной однотактовой командой сложения <code class=code>ADD R1, R0, R0 shl 6</code>, а умножение на 63 &ndash; командой <code class=code>RSB R1, R0, R0 shl 6</code>. В системе команд есть обратное вычитание, что позволяет, в частности, иметь унарный минус как частный случай этой команды и ускорить процедуру деления. ARM имеет ещё одну уникальную особенность: все его инструкции условные. Имеется 16 случаев (комбинаций флагов), которые присоединяются к каждой инструкции. Инструкция выполняется, только в случае, если текущий набор флагов соответствует набору в этой инструкции. В процессорах других архитектур подобное исполнение имеет место, как правило, только для условных переходов. Эта особенность ARM позволяет во многих случаях избегать медленной операции переход. Последнему также способствует то, что при выполнении арифметических операций можно отказаться от установки флагов состояния. С ARM подобно процессору 6809 можно использовать как быстрые, так и обычные прерывания. Кроме того, в режимах прерывания регистры со старшими номерами заменяются на системные, что позволяет сделать обработчики прерываний более компактными и быстрыми.

<p>Система инструкций ARM содержит существенно меньше базовых команд, чем система инструкций процессоров x86. Но сами инструкции у ARM очень гибкие и мощные. Несколько очень удобных и мощных инструкций ARM не имеют аналогов для 80386, например, RSB (обратное вычитание), BIC (AND с инвертированием, такая команда есть у PDP-11), 4-адресная MLA (умножение с суммированием), LDM и STM (загрузка или выгрузка множества регистров из памяти, похожи на команду MOVEM для процессоров 68k). Почти все инструкции ARM 3-адресные, а почти все инструкции 80386 имеют не более 2 операндов. Система команд ARM более ортогональна &ndash; все регистры взаимозаменяемы, некоторое исключение составляют только регистры R14 и R15. Большинство команд ARM могут потребовать 3-4 команды 80386 для своей эмуляции, а большинство команд 80386 можно проэмулировать 2-3 командами ARM. Интересно, что эмулятор IBM PC XT на аппаратуре компьютера Acorn Archimedes с процессором на 8 МГц работает даже быстрее, чем реальный компьютер PC XT. На компьютере Commodore Amiga с процессором 68000 на 7 МГц эмулятор может работать только со скоростью, не большей 10-15% реального PC XT. Очень интересно также, что первые компьютеры <a href=https://ru.wikipedia.org/wiki/NeXT_Computer>NeXT</a> с 25 МГц 68030 показывали производительность целочисленных расчетов на уровне того же 8 МГц ARM. Apple собиралась в проекте Möbius сделать компьютер-преемник Apple ][, но когда выяснилось, что прототип этого компьютера в режиме эмуляции обгоняет не только Apple ][, но и основанные на 68k процессорах Макинтоши, проект закрыли!

<p>Среди недостатков ARM можно выделить проблему загрузки константы в регистр. Можно загружать только 8 разрядов за один раз, хотя при этом константу можно инвертировать и сдвигать. Поэтому загрузка полной 32-разрядной константы может занять до 4 команд. Можно, конечно, загрузить константу из памяти одной командой, но тут возникает проблема указания адреса этой величины, так как смещение может быть только 12-разрядным. Другой недостаток ARM в относительно невысокой плотности кодов, что делает программы несколько большими, а главное снижает эффективность работы процессорного кэша. Однако, это возможно было скорее следствием невысокого качества компиляторов для этой платформы. Инструкции умножения позволяют получить только младшие 32-разряда результата. Долгое время существенным недостатком ARM было отсутствие встроенной поддержки управления памятью (MMU) &ndash; этой поддержки, например, требовала Apple в начале 90-х. Сопроцессоры для работы с вещественными числами для архитектуры ARM также стали использоваться с существенной задержкой. У ARM не было таких продвинутых средств для отладки, какие были у архитектуры x86. Есть ещё некоторая странность в языке стандартного ассемблера для ARM: операции для битового сдвигателя принято писать через запятую. Таким образом, вместо простой формы <code class=code>R1 shl 7</code> &ndash; сдвинуть содержимое регистра R1 на 7 бит влево &ndash; нужно писать <code class=code>R1, shl 7</code>.

<p>С 1989 стал доступен ARM3 с встроенным кэшем. В 1990 команда разработчиков ARM отделилась от Acorn и создала с помощью Apple и VLSI компанию ARM Holdings. Одной из причин отделения стала слишком большая затратность разработки ARM по мнению менежмента Acorn-Olivetti. Впоследствии Acorn прекратила своё самостоятельное существование, а ARM Holdings превратилась в крупную компанию. Однако, разделение Acorn и ARM Holdings было также инициировано желанием Apple иметь процессор ARM в своем компьютере Newton и не зависить от другого производителя компьютеров.

<p>ARM показывал производительность на целочисленных данных, превосходящую 80486 на той же частоте на 10-20%! Intel смогла достичь преимущества использованием технологии умножения тактовой частоты и затем крепко закрепить его с процессором Pentium. DEC StrongARM смог ненадолго вернуть себе лидерство в 1996, после чего эта технология была куплена Intel, которая с тех пор является крупным производителем процессоров ARM-архитектуры. Таким образом, существует два центра развития этой архитектуры.

<p>Дальнейшее развитие архитектуры ARM также весьма любопытно, но это уже другая история. Хотя можно упомянуть, что именно благодаря доле в ARM Holdings Apple в 90-е смогла избежать банкротства.


<h2 id=last>Некоторые выводы, предположения и вопросы</h2>

<p>Трудно отделаться от ощущения, что 8-битные процессоры оказались лишь нежелательной необходимостью для основных действовавших в 70-е и 80-е персонажей на сцене компьютерной истории. Самый удачный 8-битник 6502 был фактически заморожен. Intel и Motorola скорее тормозили как собственные разработки маленьких процессоров, так и сдерживали других разработчиков.

<p>Почти уверен, что Amiga или Atari ST работали бы лучше и быстрее на 4 МГц процессоре с 20- или 24-битным адресом, совместимом с 6502, чем с 68000. Бил Менш недавно заявил, что сегодня несложно сделать 6502 на 10 ГГц.

<p>Если бы в серии Amstrad PCW, успех которой могли бы разделить и Commodore CBM II, начали использовать оптимизированные z80 на повышенных частотах, то вполне возможно, что эта серия была бы актуальной и 10 лет назад.

<p>Каким был бы мир, если бы ARM сделали в 1982, что было вполне возможно?

<p>Какими были бы отечественные компьютеры, если бы копировали и развивали не самые дорогие, а самые перспективные технологии?
<br>
<hr>
<p>Cтатья опубликована на <a href=https://geektimes.ru/post/298735/>geektimes</a>, а также переведена на <a href=https://litwr.livejournal.com/tag/processor>английский</a>.
</body>

