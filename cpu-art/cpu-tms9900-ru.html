<head>
<meta charset=utf-8>
<title>Эмоциональная история процессоров для первых компьютеров с 70-х до начала 90-х</title>
<meta name=keywords content="CPU,processor,computer,history,Intel,Motorola,DEC,IBM,PDP-11,Commodore,VIC-20,6502,Z80,6800,TMS9900,TMS9995,ARM,Texas Instruments,8086,8088,80286,68000">
<link rel=stylesheet type=text/css href=style.css>
</head>
<body>
<h1 id=first>Эмоциональная история процессоров для первых компьютеров с 70-х до начала 90-х</h1>
<h2 id=tms9900>Texas Instruments TMS9900</h2>

<p>Это первый доступный для использования в персональных компьютерах 16-битный процессор. Он производился с 1976 года. Использует гораздо реже встречающийся порядок байт от старшего к младшему (Big Endian). Такой порядок используется ещё только в процессорах Motorola серий 6800 и 68000 и в архитектуре IBM/370. Все прочие процессоры данного обзора используют обратный порядок байт (Little Endian).

<p>У TMS9900 есть всего три внутренних 16-битных регистра: счётчик команд, регистр состояний и регистр базы внешних регистров. Этот процессор использует выделенный участок памяти размером 32 байта, указываемый значением регистра базы, как 16 двубайтных регистра общего назначения. Такое использование памяти чем-то напоминает нулевую страницу памяти в архитектуре 6502. Таким образом внешние регистры &ndash; это скорее форма адресации, чем реальные регистры. Меняя значение регистра базы, TMS9900 может очень быстро менять свой набор внешних регистров. Это напоминает Z80, который имеет два регистровых контекста. Система флагов отличается своеобразием, наряду с типичными флагами переноса, нуля (равенства), переполнения, чётности, есть ещё два уникальных флага признаков логического и арифметического больше. Последний флаг компенсирует отсутствие флага знака, а вот флаг логического больше является логическим следствием флагов переноса и нуля и поэтому он теоретически избыточен. Для пояснения избыточной роли флага логического больше привожу следующую ниже таблицу.<br>
<div align=center>
<table border=1>
<tr><th colspan=2 align=center>TMS9900<th colspan=2 align=center>x86
<tr><th align=center>op<th align=center>flags<th align=center>op<th align=center>flags
<tr><td align=center>JL<td align=center>L&gt;=0 and Z=0<td align=center>JB<td align=center>C=1
<tr><td align=center>JLE<td align=center>L&gt;=0<td align=center>JBE<td align=center>C=1 or Z=1
<tr><td align=center>JH<td align=center>L&gt;=1<td align=center>JA<td align=center>C=0 and Z=0
<tr><td align=center>JHE<td align=center>L&gt;=1 or Z=1<td align=center>JAE<td align=center>C=0
</table>
</div>
<p>Однако, TMS9900 не ставит флаг переноса в операциях сравнения и поэтому возможно флаг логического больше отчасти играет роль, похожую на флаг переноса в архитектуре 68k. Готового стека нет, его можно сделать, использую один из регистров. При вызове подпрограмм стек не используется, вместо этого адрес возврата сохраняется в выделенном для него регистре &ndash; именно так работают с вызовами подпрограмм на ARM или IBM/370. Можно ещё вызывать подпрограммы с переключением контекста, когда при вызове сохраняется не только адрес возврата, но и текущий набор внешних регистров и два остальных внутренних регистра. Такой расширенный вызов подпрограммы больше похож на вызов программного прерывания. Есть и инструкция для явного вызова программного прерывания. Довольно уникально, что при вызове программного прерывания можно передавать параметр. TMS9900 имеет встроенный контроллер прерываний, рассчитанный на работу с маскируемыми аппаратными прерываниями c 16 приоритетами. Кроме того, есть и поддержка немаскируемых прерываний. В TMS9900 встроен последовательный интерфейс, который позволяет работать с 4096 битовыми портами в отдельном адресном пространстве. Для работы с этим интерфейсом предназначены 5 специальных инструкций. Необычно, что TMS9900 имеет 5 внешних инструкций, в исполнении которых могут участвовать внешние схемы. Архитектура TMS9900 подразумевает наличие инструкций, определяемых аппаратурой пользователя.

<div align=center>
<p><img src=https://habrastorage.org/webt/bs/ir/lv/bsirlvxf7fobwzwpdcvxkcnousc.jpeg width=50%>
<p style=font-size:90%>Первый 16-разрядный домашний компьютер &ndash; у него даже цветные спрайты есть
</div>

<p>Система команд выглядит очень внушительно. Есть даже умножение и деление, многократные сдвиги. Уникальная инструкция X (подобная есть только на мейнфреймах IBM) позволяет исполнять одну инструкцию по любому адресу в памяти и переходить к следующей. Другими словами, эта инструкция исполняет другую инструкцию как подпрограмму. Исполнение команд довольно медленное, самые быстрые инструкции выполняются только за 8 тактов, арифметические команды &ndash; за 14, зато умножение (16*16=32) за 52 такта и особенно деление (32/16=16,16) за 124 такта были наверное рекордно быстрыми среди процессоров 70-х. Интересно, что умножение вообще не меняет флагов, а деление устанавливает только флаг переполнения. Последнее очень удобно &ndash; на x86 такое переполнение деления сразу вызывает аварию-исключение. Инкремент и декремент могут работать с шагом 1 или 2 и при этом устанавливают все арифметические флаги (даже переноса), но они могут применяться только к словам &ndash; для инкрементирования/декрементирования байта понадобится операция сложения/вычитания. В байты также нельзя загружать константы, можно только в слова. Вообще все операции с константами доступны только для слов. Система команд отличается почти полной ортогональностью. Хотя не хватает условных переходов по переполнению, четности и знаковых переходов по &lt;= и &gt;=. Есть и другие пробелы в ортогональности, например, отсутствие некоторых операции с константой. Операнды обычно берутся в порядке слева направо, но некоторые команды используют обратный порядок, что несколько запутывает. Необычно ещё, что при операциях с байтом из регистра используется старший байт регистра.

<p>Методы адресации у TMS9900 довольно разнообразны. Можно, например, даже использовать косвенную адресацию через регистр или через регистр со смещением. Интересно, что у регистра 0 может быть особая роль при его использовании в адресации, что опять напоминает архитектуру IBM/370. У TMS9900 есть адресация с автоинкрементом, но нет с автодекрементом. Последнее может вызвать некоторую асимметрию в кодах для реализации, например, стека. Для TMS9900 довольно естественно генерировать перемещаемый код. Однако, команды для перемещаемых переходов только короткие, со смещением от -256 до 254 байтов. Хотя для сравнения на 8086 и даже 80286 смещения у таких переходов ещё меньше, только от -128 до 127.

<p>Неприятно отсутствие операций сложения и вычитания с флагом переноса. Неприятно также отсутствие вращений через знак переноса. Вращения влево нет, его надо заменять вращением вправо. Всё это делает арифметику длинных целых более медленной. Кроме довольно типичной операции для смены знака, есть ещё операция отбрасывания знака &ndash; получения модуля числа. Также помимо довольно типичной операции зануления есть ещё и операция для заполнения заданной величины единицами. Все эти операции (вращение, сдвиги, смены знака, ...) можно применять только к словам. 

<p>В TMS9900 помимо довольно типичной возможности для проверки всех заданных бит на равенство нулю (в x86 для этого используют инструкцию TEST) есть ещё возможность проверить все заданные биты на равенство единице. Вместо поразрядного умножения (AND) как и в архитектуре DEC PDP-11 используется операция умножения с предварительным инвертированием.

<p>Мнемоники инструкций ассемблера у TMS9900 часто уникальны. Хотя команды нециклических сдвигов имеют названия, идентичные соответствующим инструкциям на Z80. Мне больше всего нравится мнемоника AI (Add Immediate), которой также соответствует фраза Artificial Intelligence (искусственный интеллект). Интересно, что вычитания с константой нет, его надо всегда заменять на AI, что хотя и всегда возможно, но требует некоторого интеллекта. Интересно ещё, что регистры по умолчанию именуются только своим номером &ndash; это возможно также влияние архитектуры IBM/370. Можно ещё заметить, что в ассемблере TMS9900 для записи 16-х чисел используют знак больше &ndash; мне неизвестны другие системы, использующие этот знак таким же образом.

<p>TMS9900 требует три напряжения питания -5, 5 и 12 вольт и четыре фазы сигнала тактирования &ndash; это антирекорды среди известных мне процессоров. В 1979 этот процессор был продемонстрирован специалистам фирмы IBM, которые тогда искали процессор для находящегося в разработке прототипа IBM PC. Очевидные недостатки TMS9900 (адресуемость только 64 КБ памяти, громоздкость подключения, отсутствие необходимых архитектуре контроллеров, относительная медленность) произвели соответствующее впечатление и для будущего лидера среди ПК был выбран Intel 8088. Для устранения проблемы отсутствия контроллеров Texas Instruments также производила вариант TMS9900 с 8-разрядной шиной, TMS9980, который работал на 33% медленнее.

<p>TMS9900 использовался в довольно популярных в США компьютерах TI-99/4A, которые были "разгромлены" в войне цен компьютером Commodore VIC-20 к 1983. Любопытно, что в результате этой войны Texas Instruments была вынуждена снизить цены на свой компьютер до невероятных для 1983 $49 (в 1979 цена была $1150!) и продавать их с большим для себя убытком. Можно для примера привести сравнительно непопулярный компьютер Commodore+4, который прекратили производить ещё в 1986, но цены на который упали до этих $49 только в 1989 году. TI-99/4A прекратили производить в 1984, тогда, когда из-за сверхнизких цен он стал набирать популярность. Интересно, что в ещё 1982 году продажи TI-99/4A составляли 34% американского рынка компьютеров по цене около 500$, опережая Commodore VIC-20 (33%), Atari 400 (20%) и Tandy Coco (13%). Этот компьютер лишь условно можно назвать полностью 16-разрядным. Потому что он имеет только 256 байт (!) памяти ОЗУ и системную память ПЗУ, адресуемые через 16-разрядную шину. Остальная память и устройства ввода-вывода работают через медленную 8-разрядную шину. Более того, большая часть ПЗУ работает вообще через очень необычный и медленный последовательный интерфейс. С другой стороны, TI-99/4A более 16-разрядный, чем IBM PC XT. Возможно более правильно считать первым домашним 100% 16-битным компьютером отечественный БК-0010. Любопытно, что TI-99/4A использует процессор на частоте 3 МГц &ndash; точно на такой же как и БК-0010.

<p>Серия TI-99/4A &ndash; это редкий пример компьютеров, где производитель процессора и компьютера был одним и тем же. Кстати, именно в Texas Instruments была когда-то разработана основа всех персональных компьютеров &ndash; интегральная схема.

<p>В своих популярных калькуляторах серии, начавшейся с TI-81, Texas Instruments предпочла использовать Z80 вместо своих в чем-то более продвинутых процессоров. Хотя когда-то именно Texas Instruments разработала как первый процессор для калькуляторов, так и первый карманный калькулятор.

<p>В TI-99/4A в качестве видеоконтроллера использовалась довольно удачная микросхема TMS9918, которая стала основой для весьма популярного во всём мире стандарта MSX, а также некоторых других компьютеров и игровых консолей. В японской компании Yamaha этот видеочип был значительно улучшен и впоследствии использовался, в частности, для модернизации самих TI-99/4A! Странно, что Texas Instruments не удалось склонить производителей к использованию своего процессора в изделиях, использовавших TMS9918. Единственным исключением стал компьютер компании Panasonic <a href=https://en.wikipedia.org/wiki/Tomy_Tutor>Tomy Tutor</a>, который использовал процессор TMS9995, совместимый с TMS9900. Кстати, Texas Instruments сделала прототипы компьютеров TI-99/2 и TI-99/8 на базе этого процессора, которые по не совсем понятным причинам в серию не пошли. TMS9995 также использовался в позднем (1987) компьютере <a href=https://en.wikipedia.org/wiki/Geneve_9640>Geneve 9640</a>, который совместим c TI-99/4A и поэтому стал наиболее известной системой на базе этого процессора.

<p>TMS9995 заслуживает, чтобы о нем было сказано несколько слов. Это &ndash; весьма оригинальный процессор. Внешняя шина данных 8-разрядная. Но есть внутренняя память размером 256 байт, расположенная по двум фиксированным адресам, которая работает через внутреннюю 16-разрядную шину. TMS9995 использует уже только одно напряжение питания и один сигнал тактирования, что делало системы на его основе проще и дешевле. Есть встроенный таймер. У него по сравнению с TMS9900 всего 4 новых инструкции, которые скорее только оптимизируют некоторые операции, чем вносят что-то принципиально новое. Система управления внешними маскируемыми прерываниями стала более примитивной, от 16 уровней осталось только 3. Однако появилась поддержка внутренних прерываний-исключений: по некорректной инструкции, по таймеру и по переполнению &ndash; последнее было реализовано с ошибкой, которую возможно так и не исправили. Всего от 17 векторов для прерываний в TMS9900 в TMS9995 осталось только 6. Интересно ещё, что TMS9995 фактически делит свою тактовую частоту на 4 &ndash; все тайминги инструкций базируются на частоте в 4 раза меньшей, чем входная тактовая. Инструкции на TMS9995 стали исполняться намного быстрее. Однако, если брать в качестве базовой внешнюю тактовую частоту, то даже с внутренней памятью TMS9995 медленнее, чем TMS9900 на той же частоте.

<p>Cистема инструкций как TMS9900, так и TMS9995 &ndash; это подмножество системы инструкций, использовавшейся на мини-ЭВМ серии TI-990. В заключение можно сделать вывод, что первые домашние 16-битные компьютеры &ndash; это побочная ветвь развития мини-компьютеров от DEC и Texas Instruments.
<br>
<hr>
<p>Cтатья опубликована на <a href=https://geektimes.ru/post/298735/>geektimes</a>, а также переведена на <a href=https://litwr.livejournal.com/1575.html>английский</a>.
</body>

