<head>
<meta charset=utf-8>
<title>Emotional stories about processors for first computers: part 13 (IBM/370)</title>
<meta name=keywords content="CPU,processor,computer,history,IBM,Intel,ARM,hardware,System/360,System/370,System/390,System/Z,x86">
<link rel=stylesheet type=text/css href=style.css>
</head>

<body>
<h2>IBM System/370</h2>

<p>This part primarily focuses on comparing the mainframe machine language with other systems that were popular between the 70s and 90s. These are primarily the x86, 68k, VAX, and ARM. Systems 390 and, in particular, Z are considered very fragmentary â€“ the main attention is paid to the system 370.

<p>The first 360 systems began shipping to customers in 1965, and the more advanced 370 systems from 1970.  IBM maintains software compatibility with these systems to this day!  Surprisingly, before the systems 390, which were delivered, as you can guess from 1990, mainframes worked with 24-bit addresses, that is, they could address no more than 16 megabytes of memory, the same amount as, for example, the 68000, released in 1979, or the 65816 or 32016, released in 1982.  The VAX initially supported 32-bit addressing.  Popular processors 68020 or 80386, which appeared in the mid-80's, also supported 32-bit addresses.  Actually, 16 MB of memory for the best systems of the second half of the 80's was already not enough.  However, since 1983, IBM was producing 370-compatible computers that could use 31 bits for an address as an extension, which eliminated the problem of memory capacity for the best computers.  Unusually and uniquely, these extensions and the 390 systems used the 31-bit addressing rather than the full 32-bit one.  In 2000, IBM announced the first Z system that uses 64-bit addressing and data.  The Z systems have been using processor chips since 2008.  Since 2007, they have been trying to combine the Z architecture with the POWER architecture in a single chip, but so far without success.

<div align=center>
<p><img src=https://habrastorage.org/webt/0e/j3/9j/0ej39jkol5cdj56svyiufmwlawy.jpeg style=width:50%>
<p style=font-size:90%>The IBM System/370-145 with the 2401 tape unit and a printer instead of display, 1971
</div>

<p>By the way, some computer authorities believe that the first serial personal computer was the IBM 5100, produced since 1975, which could execute instructions of the 360 system via a hardware emulator.  Its improved versions were produced until the mid-80's.  Although most likely the first was rather the Wang 2200.  For the price (around $10000) the first "personal computers" were clearly not for home use.

<div align=center>
<p><img src=https://habrastorage.org/webt/xe/_e/si/xe_esilbaro7rmxsmq3oaletjyw.png style=width:50%>
<p style=font-size:90%>The IBM 5100, a version with APL support
</div>

<p>With the advent of the IBM PC architecture, which, as it turned out, for decades determined the mainstream of development for computing, IBM tried in 1983 to combine almost all the best computer technologies in a single product the PC XT/370: their system 370, the IBM PC XT, the Motorola 68000 and Intel 8087.  This XT/370 could be used as a smart terminal for working with a mainframe, like a regular IBM XT, or to directly run mainframe software.  Interestingly, the XT/370 had support for using virtual memory, which required two 68000s.  In 1984, with the introduction of the PC AT, an improved version of the "personal mainframe" AT/370 was released, which in mainframe mode was about twice as fast as the XT/370.  This is not the end of the history of such systems, since the 90s, similar products were produced that correspond to the 390 systems.  As far as I know, such hardware has not been made for Z systems.

<p>IBM for its mainframes uses a rather unusual business model for today, in which computers are not sold, but are leased.  One of the advantages of this model is that it guarantees a constant upgrade of equipment, outdated equipment is automatically replaced with updated one of the corresponding class.  This model also has drawbacks.  For example, a particularly noticeable disadvantage for those who are engaged in the history of computer technology is that computers that have served their time are almost always disposed of and therefore they are almost impossible to find in any museum.

<p>It was amazing to find a live IBM 4361 system in <a href=https://www.livingcomputers.org/>LCM</a>!  However there is reason to believe that this may not be real iron.  For some reason, museum visitors have no access to this computer.  It is also unclear what model is allegedly represented there, and this is despite the fact that other computers in the museum are identified very accurately.  Among the 4361 systems, three models 3, 4, and 5 are known, with model 3 appearing later than models 4 and 5.  But the system in the Museum is self-identified as model 1.  It is possible that this is a prototype.  However, the museum staff did not answer a direct question about help with identification, and this is despite the fact that they answer other and often rather complex questions quite quickly.  Some features of code execution timings give grounds, although not absolutely firm, to assume that the emulator is most likely connected to the network.  In the summer, the museum, in connection with the covid pandemic, has overtly switched to an emulator... There is still a chance to get to the iron mainframes via the <a href=http://moshix.dynu.net/>HNET</a> network, but I have not yet succeeded.

<p>But whatever it is, everyone can connect and try to work in much the same way that high-paid professionals have worked since the mid-70s.  The prices were such that today it is difficult to believe.  For example, an hour of computer time cost more than $20 in the mid-80s and you still had to pay extra for disk space!  True, we are talking about the mainframe operating time, not the terminal through which the work was going.  This is why, for example, when editing a text, 5 minutes of payment time was rarely taken out of an hour of actual work.  The prices for the mainframes themselves were also fantastic.  For example, Intel employees recall that in the early 80's they were given only one mainframe to work with.  Its performance was 10 MIPS, and the price was about 20 million dollars then, which was three times heavier than today!  Interestingly, Intel preferred such computers over the cheaper VAX systems.  Now, even a tablet-sized Raspberry Pi at a few dollars can easily produce over 1000 MIPS.  By the way, on a Raspberry Pi or almost any modern computer, you can run the IBM/370 emulator, which will work much faster than any IBM system from the 80's or even 90's.  However, the emulator needs to be configured and not all useful programs for the IBM/370 are freely available, so free access to a well-tuned system is often the best way to work with the mainframe.  Surprisingly, such access programs, 3270 terminal emulators, are available even on mobile phones!  By the way, I managed to set up my VM/SP system on the <a href=https://en.wikipedia.org/wiki/Hercules_(emulator)>Hercules emulator</a> and deal with the file transfer, but it took at least a week of my time.

<p>The Hercules emulator can emulate the later IBM/390 and IBM/Z systems, but due to problems with the software license, this is much more difficult to do.  As an illustration of such problems, I will cite a well-known case when IBM insisted on removing the Emulation section from an already published book!  In modern electronic versions of this book, this section does not exist; it can only be found in the printed edition or as a separate file on sites dedicated to free software.  The fact is that emulation on regular personal computers since the early 2000s could be noticeably faster than execution on much more expensive mainframes.  IBM therefore had to change the licenses for its software so that it can only be legally used on hardware purchased from IBM.  Of course, it is not that emulators are faster than the best mainframes, they are only demonstrating a markedly better ratio of performance to cost.

<p>Let's now look at the features of the machine language of systems compatible with the 360.  The basic assembler of such systems is called BAL &ndash; Basic Assembly Language.  Surprisingly, if you believe the rumors about IBM, assembler is still one of the main working programming languages there.

<p>The assembler of the mainframes in question has a number of archaic features that were no longer present in other well-known architectures that appeared later.  For example, this is about the fact that BAL mnemonics determine the type of arguments.  Consider the x86 assembly instructions <code class=code>MOV EAX,EBX</code> and <code class=code>MOV EAX,address</code> as an example - both use the mnemonic MOV.  For BAL for such cases different mnemonics LR and L are used in the commands <code class=code>LR 0,1</code> and <code class=code>L 0,address</code> respectively.  However, similar different mnemonics allow using numbers for naming registers, although usually macros R0, R1, ... instead of numbers 0, 1, ... are the first thing that is defined in macro packages for programming convenience.  Another archaism is the use of label jumps in conditional compilation constructs, although in my humble opinion this is sometimes more convenient than block structures.  But the most famous archaism is the use of EBCDIC encoding to work with symbolic information.  In this strange, even for yesterday, encoding the letters of the English alphabet are not encoded in a row [in succession], for example, the letter I has code 201, and the next one J - 209!  The 360 system also supports ASCII encoding in hardware, but in its ancient and long-forgotten version, where the character for the digit 0 has code 80, not 48 as it is now.  As far as I know, ASCII with IBM mainframes was better not even trying to use.  ASCII support was removed already in 370 systems, but introduced at a new level in the systems 390. Some BAL mnemonics are striking in their super-shortness and even non-nemonicity, for example, N means AND, O â€“ OR, X â€“ XOR, A â€“ ADD, S â€“ SUBTRACT, M â€“ MULTIPLY, ...

<p>BAL allows you to work with three basic data types: binary, decimal, and real numbers.  The systems 390 use another special type to work with real numbers.  Some Z systems may also use completely unique data type such as decimal real numbers.  Instructions for working with each type form a special and rather isolated class of instructions.  Generally, with very few exceptions, all the 360-compatible systems support decimal and real arithmetic instructions. As you know, for the x86 or 68k architectures, support for working with real numbers did not appear immediately and was an optional choice for a long time, and working with decimal numbers was not something completely separate from binary arithmetic &ndash; it was rather an extension.

<p>For working with real and binary numbers, different sets of registers are used, and for working with decimal numbers, registers are not used at all.  The system 370 provides 16 32-bit general purpose registers for binary integers, with the command counter being part of the processor status word.  There is no separate stack, it can be organized using any register â€“ this is how the stack was later implemented in the ARM.  The subroutine call is also made as in the ARM, via a link register.  All registers are almost always interchangeable, exceptions are very rare.   If you compare a system of BAL binary registers with the competitive VAX architecture, you will notice that VAX has one register less.  This is true for the ARM as well.

<p>The structure of operands in the instructions will seem quite familiar to those who know the x86 assembler.  For binary numbers, operands have a "register-register" or "register-memory" structure, and for the latter case, both 32-bit and sign-extensible 16-bit values can be loaded from memory.   For example, the analog of the x86 <code class=code>ADD EAX,EBX</code> instruction is <code class=code>AR 0,1</code>, <code class=code>ADD EAX,address</code> &ndash; <code class=code>A 0,address</code>, <code class=code>ADD EAX,address[EBX]</code> &ndash; <code class=code>A 0,address(1)</code>, <code class=code>ADD EAX,address[EBX][EDX]</code> &ndash; <code class=code>A 0,address(1,3)</code>.  However, The System/360 and even its later development do not know how to work with scaling, for example, <code class=code>ADD EAX,address[8*EBX]</code> in BAL can not be written with a single instruction.  On the other hand, the x86 cannot usually do a signed extension for a 16-bit number, for example, BAL instruction <code class=code>AH 0,address</code>, which means to take a 16-bit signed number from memory and add it to the content of register 0, will require two commands for its implementation on the x86.

<p>A rare peculiarity of BAL is the presence of separate instructions for addition and subtraction for signed and unsigned numbers, and unsigned operations in BAL are called logical.  This oddity is caused by the lack of flags in the 360 architecture that are usual to most other architectures.  Instead, only two bits are used, which are set differently by different instructions!  The only difference between signed and unsigned operations is that they set the two status bits mentioned differently.  For signed operations, you can find out whether the result was zero, whether it was positive or negative, whether an overflow occurred, and for unsigned operations, whether the result was zero and whether there was a carry or borrow.  Conditional jump instructions allow you to consider all 16 subsets of cases that are possible when using 2 bits.  Due to this unusual for today way of working with operation flags, conditional jump instructions are difficult to quickly understand.  Although BAL extensions usually add fairly easy-to-understand macros for conditional jumps, where you do not need to parse each of the 4 bits.  Here, to be fair, we can note that there are separate commands for signed and unsigned addition and subtraction, for example, in the MIPS architecture, where there are no flags at all!

<p>Another rare peculiarity is in separate instructions for signed and unsigned comparisons.  I've met similar ones not only at the MIPS, but also at the MicroBlaze.  In the latter, by the way, the carry is the only supported flag for the operation status.

<p>

<p>Edited by 
<hr>
<a href=https://litwr.livejournal.com/>mirror</a>
</body>

