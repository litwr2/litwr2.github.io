<head>
<meta charset=utf-8>
<title>Emotional stories about processors for first computers: part 6 (TI TMS9900)</title>
<meta name=keywords content="CPU,processor,computer,history,TI,Texas Instruments,TMS9900,TMS9995,6502,Motorola,6800,68000,IBM/370,IBM PC,Intel,8088,Commodore,VIC-20,hardware,BE,LE">
<link rel=stylesheet type=text/css href=style.css>
</head>

<h2>Texas Instruments TMS9900</h2>

<p>This is the first 16-bit processor available for use in personal computers.  This processor was produced since 1976.  It used a much rarer big-endian order of bytes.  This order was used only in processors of the Motorola's 6800 and 68000 series and in the architecture of the IBM mainframes.  All other processors in this review use little-endian byte order.

<p>The TMS9900 has only three internal 16-bit registers: the program counter, the status register and the base register for external registers.  This processor uses 32-byte memory space (the workspace), which is pointed by the base register, as 16 double-byte general purpose registers.  Such a way of use of memory is somewhat like the zero page memory in the 6502 architecture.  So the external registers are rather a form of addressing than real registers.  By changing the value of the base register, the TMS9900 can change its set of external registers very quickly.  This is similar to the Z80 which has two register contexts.  Processor status flags are distinguished in originality, along with typical flags of carry, zero (equality), overflow, parity, there also are two more unique flags of logical and arithmetic greater than.  The latter flag compensates for the absence of the sign flag, but the logical greater than is a logical consequence of the carry and zero flags and therefore it is theoretically redundant.  The next table explains the redundant role of the logical &gt; flag.<br>
<div align=center>
<table border=1>
<tr><th colspan=2 align=center>TMS9900<th colspan=2 align=center>x86
<tr><th align=center>op<th align=center>flags<th align=center>op<th align=center>flags
<tr><td align=center>JL<td align=center>L&gt;=0 and Z=0<td align=center>JB<td align=center>C=1
<tr><td align=center>JLE<td align=center>L&gt;=0<td align=center>JBE<td align=center>C=1 or Z=1
<tr><td align=center>JH<td align=center>L&gt;=1<td align=center>JA<td align=center>C=0 and Z=0
<tr><td align=center>JHE<td align=center>L&gt;=1 or Z=1<td align=center>JAE<td align=center>C=0
</table>
</div>
<p>However, the TMS9900 does not set the carry flag in comparison operations, and therefore the logical &gt; flag may play a role more similar to the carry flag in the 68k architecture.  There is no ready to use stack, but you can create a stack using one of the registers.  When calling subroutines, the stack is not used, instead the return address is stored in a register allocated to it &ndash; this is how they work with subroutine calls on the ARM or IBM/370. You can also call subroutines with context switching, when the call saves not only the return address, but also the current set of external registers and the other two internal registers.  Such an extended call is more like calling a software interrupt.  There is also an instruction for explicitly calling a software interrupt.  This instruction has an atypical feature, it has a parameter for an interrupt handler.  The TMS9900 has a built-in interrupt controller designed to work with masked hardware interrupts of up to 16.  In addition, there is support for unmasked interrupts.  The TMS9900 has a built-in serial interface that allows you to work with 4096 bit ports in a separate address space. There are 5 special instructions for working with this interface. Unusually, the TMS9900 has 5 external instructions that can be executed by external circuits. The TMS9900 architecture implies the presence of instructions defined by user's hardware.

<div align=center>
<p><img src=https://habrastorage.org/webt/bs/ir/lv/bsirlvxf7fobwzwpdcvxkcnousc.jpeg style=width:50%;height:auto>
<p style=font-size:90%>The first 16-bit home computer &ndash; it has even color sprites!
</div>

<p>The system of instructions looks very impressive, there are even multiplication and division, multiple shifts.  The unique X instruction (a similar instruction exists only for the IBM mainframes) allows you to execute one instruction on any memory address and move on to the next one.  In other words, this instruction executes another instruction as a subroutine.  The execution of instructions is rather slow, the fastest instructions require 8 cycles and arithmetic instructions 14 cycles.  However, multiplication (16*16=32) for 52 cycles and division (32/16=16,16) for only 124 cycles were probably the fastest among processors of the 70's.  Interestingly, multiplication does not change flags at all, and division only sets the overflow flag.  The latter is very convenient &ndash; on the x86, such a division overflow immediately causes an exception-crash.  Increment and decrement can operate in 1 or 2 steps and set all arithmetic flags (even the Carry), but they can only be applied to words &ndash; adding/subtracting is required to increment/decrement a byte.  Constants cannot be loaded into bytes either, only into words.  In general, all operations with constants are available only for words.  The command system is almost completely orthogonal.  Although there are not enough conditional jumps, for instance on overflow, parity and signed jumps on &lt;= and &gt;=.  There are other gaps in orthogonality, such as the absence of some operations with the immediate value.  Operands are usually taken in left-to-right order, but some instructions use the reverse order, which is somewhat confusing.  It is also unusual that when operating with a byte from a register, the most significant byte of the register is used.

<p>The TMS9900's addressing methods are quite diverse.  You can, for example, even use indirect addressing via a register or via a register with an offset.  Interestingly, register 0 may have a special role when used in addressing, which again resembles the IBM/370 architecture.  The TMS9900 has auto-increment addressing, but not auto-decrement addressing.  The latter can cause some asymmetry in the codes for implementing, for example, the stack. It's pretty natural for the TMS9900 to generate relocatable code.  However, the instructions for relocatable jumps are only short, with offsets from -256 to 254 bytes.  Although, for comparison, on the 8086 and even 80286, the offsets for such jumps are even smaller, only from -128 to 127.

<p>The lack of addition and subtraction operations with the carry flag is unpleasant.  The absence of rotations through the carry flag is also unpleasant.  There is no rotation to the left, it should be replaced by a rotation to the right.  All this makes long integer arithmetic slower.  In addition to a fairly typical operation for changing a sign, there is also an operation of discarding a sign &ndash; getting the modulus of a number.  Also, in addition to the fairly typical zeroing operation, there is also an operation for filling a given value with ones.  All these operations (rotation, shifts, sign changes, ...) can only be applied to words.

<p>On the TMS9900, in addition to the rather typical ability to check all specified bits for equality to zero (in the x86, the TEST instruction is used for this), there is also an opportunity to check all specified bits for equality to one.  Instead of a bitwise multiplication (AND), as in the DEC PDP-11 architecture, a bitwise multiplication operation with pre-inversion is used.

<p>The TMS9900 assembly instruction mnemonics are often unique.  Although the non-cyclic shift commands have the same names as the corresponding instructions on the Z80.  My favorite is the AI (Add Immediate) mnemonic, which also corresponds to the words Artificial Intelligence.   It is interesting that there is no subtraction with a constant, it must always be replaced by AI, which, although always possible, requires some intelligence.  It is also interesting that by default the registers are named only by their number &ndash; this is also possible due to the influence of the IBM/370 architecture.  It may be also noticed that in the TMS9900 assembler, the &gt; sign is used to prefix hex-numbers &ndash; I am not aware of other systems that use this sign in the same way.

<p>The TMS9900 requires three supply voltages of -5, 5 and 12 volts and four phases of the clock signal &ndash; these are the worse specifications among the processors known to me.  In 1979 this processor was demonstrated to IBM specialists, who then were looking for a processor for the IBM PC prototype.  The obvious drawbacks of the TMS9900 (addressability of only 64 KB of memory, bulkiness of connection, lack of the necessary controllers, relative slowness) made an appropriate impression and the Intel 8088 was chosen for the future leader among PC's.  To deal with the lack of controllers Texas Instruments also produced the TMS9900 variant with an 8-bit bus, the TMS9980, which worked 33% slower.

<p>The TMS9900 used in the <a href=https://en.wikipedia.org/wiki/Texas_Instruments_TI-99/4A>TI-99/4A</a> computers which were fairly popular in the USA.  They were "crushed" in the price war by the computer Commodore VIC-20 by 1983.  Curiously as a result of this war Texas Instruments was forced to cut prices on its computer to the incredible price for 1983 of $49 (in 1979 the price was $1150!) and to sell them with a big loss to themselves.  As an example we can mention the relatively unpopular Commodore +4 computer, which ceased to be produced in 1986, the price of which fell to $49 in 1989 only.  The TI-99/4A was stopped being produced in 1984, when because of the ultra-low prices it began to gain popularity.  Interestingly, back in 1982, the TI-99/4A sales accounted for 34% of the US computer market for computers with an average retail price of $500.  This was ahead of the Commodore VIC-20 (33%), Atari 400 (20%) and Tandy Coco (13%).  This computer might only be conditionally called 100% 16-bit: only 256 bytes (very little) of its RAM and its system ROM are addressable through a 16-bit bus.  The rest of the memory and I/O-devices work over a slow 8-bit bus.  Moreover, most of its ROM works through a very unusual and slow serial interface.  On the other hand, the TI-99/4A is more 16-bit than the IBM PC XT.  Maybe it is possible to more correctly consider the <a href=https://en.wikipedia.org/wiki/Electronika_BK>BK0010</a> as the first 100% 16-bit home computer.  It is an interesting coincidence that the TI-99/4A uses a processor at a frequency of 3 MHz &ndash; exactly the same as the BK0010 uses.

<p>The TI-99/4 series is a rare example of computers where a processor and a computer manufacturer was the same.  By the way, it was Texas Instruments that once developed the basis of all personal computers &ndash; the integrated circuit.

<p>In its popular calculators series that began with the TI-81, Texas Instruments chose to use the Z80 instead of their somewhat more advanced processors.  Although once it was Texas Instruments that developed both the first processor for calculators and the first hand-held calculator.

<p>In the TI-99/4A a quite successful TMS9918 chip was used as a video controller, which became the basis for the very popular worldwide <a href=https://en.wikipedia.org/wiki/MSX>MSX</a> standard, as well as for some other computers and game consoles.  In the Japanese company Yamaha this video chip was significantly improved and was subsequently used in particular to upgrade the TI-99/4A themselves!  It is strange that Texas Instruments failed to persuade manufacturers to use their processor in products that used the TMS9918.  The only exception was the Panasonic <a href=https://en.wikipedia.org/wiki/Tomy_Tutor>Tomy Tutor</a> computer, which used the TMS9995 processor compatible with the TMS9900.  By the way, Texas Instruments made prototypes of the TI-99/2 and TI-99/8 computers based on this processor, which did not go into the series for some not entirely clear reasons.  The TMS9995 was also used in the late (1987) <a href=https://en.wikipedia.org/wiki/Geneve_9640>Geneve 9640</a> computer, which is compatible with the TI-99/4A and therefore became the most well-known system based on this processor.

<p>The TMS9995 deserves to have a few words said about it.  This is a very unusual processor.  The external data bus is 8-bit.  But there is an internal memory of 256 bytes located at two fixed addresses, which works through the internal 16-bit bus.  The TMS9995 already uses only one supply voltage and one clock signal, which made systems based on it simpler and cheaper.  There is a built-in timer.  Compared to the TMS9900, it has only 4 new instructions that only optimize some operations rather than introduce something fundamentally new.  The control system for external masked interrupts became more primitive, only 3 levels remained from 16 levels.  However, support for internal interrupts-exceptions appeared: by incorrect instruction, by timer and by overflow &ndash; the latter was implemented with an error that may not have been fixed.  Only 6 of the 17 vectors for interrupts in the TMS9900 are left in the TMS9995.  It is interesting that the TMS9995 actually divides its clock frequency by 4 &ndash; all instruction timings are based on a frequency 4 times lower than the input clock.  Instructions on the TMS9995 became much faster to execute.  However, if we take an external clock frequency as the base, then even with the internal memory, the TMS9995 is slower than the TMS9900 at the same frequency.

<p>The instruction set of both the TMS9900 and TMS9995 is a subset of the instruction set used on the TI-990 series minicomputers.  In conclusion, we can say that the first home 16-bit computers were a side branch of the development of mini-computers from DEC and Texas Instruments.


<p>Edited by Richard BN
<hr>
<a href=https://litwr.livejournal.com/1575.html>mirror</a>

