<head>
<meta charset=utf-8>
<title>Эмоциональная история процессоров для первых компьютеров с 70-х до начала 90-х</title>
<meta name=keywords content="CPU,processor,computer,history,Intel,Motorola,DEC,IBM,PDP-11,VAX-11,Commodore,Amiga,Atari ST,Apple Macintosh,Apple Lisa,Sinclair QL,6502,Z80,6800,8086,8088,80186,80286,80386,80486,Pentium,68000,68008,68010,68020,68030,68040,68060">
<link rel=stylesheet type=text/css href=style.css>
</head>
<body>
<h1 id=first>Эмоциональная история процессоров для первых компьютеров с 70-х до начала 90-х</h1>
<h2 id=m68k>Motorola: от 68000 до 68040</h2>

<p>Motorola &ndash; это единственная фирма, которая какое-то время могла успешно конкурировать с Intel в области производства процессоров для персональных компьютеров. В 1980 Motorola фактически поставила Intel в ситуацию кризиса, из которого та могла выйти, только мобилизовав все свои силы и организовав группу сокрушения (Crush Group) своих конкурентов, действия которой несколько нарушали антимонопольное законодательство США.

<p>68000 был выпущен в 1979 и на первый взгляд выглядел гораздо внушительнее 8086. Он имел 16 32-разрядных регистров (точнее даже 17), отдельный счетчик команд и регистр состояний. Мог адресовать 16 МБ памяти напрямую, что не создавала никаких ограничений, например, для больших массивов. Однако, внимательный анализ особенностей 68000 показывает, что не всё так хорошо, как кажется. В те годы иметь память более 1 МБ &ndash; это недостижимая роскошь даже для средних по размеру организаций. Плотность кодов у 68000 хуже, чем у 8086 &ndash; а значит коды с той же функциональностью занимают у 68000 больше места. Последнее связано и с тем, что коды у 68k должны быть кратными 2 байтам по длине, а у х86 &ndash; 1. Но информация о плотности кодов спорная, так как есть свидетельства, что в некоторых случаях у 68000 она может быть лучше, чем у 8086. Из 16 регистров &ndash; 8 адресные, которые в чём-то, с одной стороны, чуть более продвинутые аналоги сегментных регистров x86, а, с другой,  в чем-то они прямое наследие работы с регистрами на 8-битных архитектурах (8080, 6502, Z80, 6809, ...), где также было разделение на регистры данных и адресные. Главное, что регистры данных нельзя использовать как адреса и набор операций с адресными регистрами ограничен, что несколько неудобно. АЛУ и шина данных 16-разрядные, поэтому операции с 32-битными данными медленнее, чем можно ожидать. Более того, из надуманного порядка байт (Big Endian) операции сложения и вычитания с 32-битными числами выполняются с дополнительным замедлением. Время исполнения операций типа регистр-регистр &ndash; 4 такта, а у 8086 &ndash; только 2. Максимальная задержка при вызове прерывания на 68000 может доходить до 378 тактов и это довольно много. Компьютеры на базе 68000 до середины 80-х получались гораздо более дорогими, чем на базе Intel 8088, но 68000 не мог работать с виртуальной памятью и не имел аппаратной поддержки работы с вещественными числами, что делало его непригодным для использования в самых продвинутых системах. Для поддержки использования виртуальной памяти требовался ещё один процессор, обычно для этого использовали ещё один 68000. В 1982, как отмечал Bill Joy, в Sun начали разработку своего процессора, так как 68000 не соответствовал нуждам заказчиков по производительности и, особенно, для работы с вещественными числами. Интересно, что из-за большого размера 68000 в Motorola называли "техасский таракан".

<p>Однако, большой размер позволил втиснуть больше функциональности. Например, 68000 может без внешнего контроллера обслуживать до 8 внешних прерываний. Архитектура x86 требует наличия внешнего контроллера прерываний (относительным исключением является только 80186). Шины данных и адреса у 68000 не мультиплексированы в отличие от 8086, в Intel только с 80286 отказались от такого тормозящего систему совмещения шин. В 68000 есть привилегированные инструкции, что необходимо для организации многозадачности, которые у x86 появились опять только с 80286. С другой стороны, одних привилегированных команд для полной поддержки многозадачности недостаточно и поэтому их наличие в 68000, в отличие от 80286, выглядит скорее почти бесполезно. Конечно удивительно, что Mototola не производила никакой аппапратуры управления памятью для 68000 и поэтому производители рабочих станций должны были изобретать такое железо самостоятельно. Это тем более удивительно, что поддержка простейшей сегментной организации памяти аппаратно реализуется очень просто. Но эта тема непростая: между рабочими станциями и персональными компьютерами линия разделения проходила именно по факту наличия аппаратного управления памятью. Наличие такого простого и дешёвого устройства радикально меняло класс компьютера и его цену!

<p>Как всегда, с изделиями от Motorola, архитектура 68000 показывает несколько неуклюжестей и надуманных странностей. Например, два стека (в самых популярных сегодня 68k процессорах <a href=https://ru.wikipedia.org/wiki/Freescale_ColdFire>Coldfire</a> есть только один стек) или два флага переноса (один для признаков, а другой для операций). Несмотря на наличие двух флагов переноса, операции сложения и вычитания с переносом поддерживают только два режима адресации, что делает их гораздо менее удобными подобных операций на x86, &ndash; 68000, таким образом, сохранил некоторую неуклюжесть таких операций свойственную IBM/370 и, отчасти, PDP-11. На этом странности с флагами не заканчиваются. Почему-то многие команды, включая даже MOVE и SWAP, зануляют флаги признака переноса и переполнения. Другая странность, что команда для сохрания состояния арифметических флагов, которая работала нормально в 68000, сделана привилегированной во всех процессорах, начиная с 68010. Это, в частности, сделало невозможным использование единой операции для сохранения флагов для 68000 и более поздних процессоров 68k. Таким образом, сохранить флаги как на x86 командами PUSHF или SAHF на 68k единым образом нельзя! Motorola не стоило делать команду <code class=code>MOVE from SR</code> привилегированной, а вместо этого следовало просто изменить её описание так, что она в пользовательском режиме как бы не возвращала информацию о системных флагах, и добавить привилегированную команду именно для чтения этих флагов. Некоторые операции раздражают своей неоптимизированностью, например, операция записи нуля в память CLR работает медленнее записи константы 0 в память командой MOVE или сдвиг влево медленнее сложения операнда с самим собой. CLR кроме записи в память, зачем-то её предварительно читает, что может создать проблемы при работе с портами. Даже адресные регистры при кажущимся на первый взгляд преимуществе перед сегментными регистрами 8086, имеют ряд раздражающих недостатков. Например, в них требовалось грузить целых 4 байта вместо двух у 8086 и из этих четырех один был лишний. Система команд 68000 обнаруживает много сходства с системой команд PDP-11, разработанной ещё в 60-е, хотя некоторые методы адресации и порядок байт взяты почти наверняка от IBM/370. От PDP-11 наверное взята и усложненная система обработки исключений, когда при сбое команда пытается продолжить своё исполнение, &ndash; это делает ускорение процессоров 68k более сложным, чем x86, где в таких случаях команда просто перезапускается. Адресация через базу и индексный регистр сделана в 68000 на уровне 8-битных 6800 или Z80, с однобайтным смещением &ndash; это как-то совершенно непрактично, в 8086 смещение 16 разрядов, в ARM или IBM/370 &ndash; 12. Даже 6502 может использовать 16-разрядное смещение c индексацией. Нормальное смещение стало поддерживаться только с 68020. Сюрпризы на 68k могут возникнуть с необычной командой цикла, в которую надо передавать не число повторений, а число на единицу меньшее. 68k ещё не хватает инструкции подобной TEST для 8086. Несмотря на большие возможности компании Motorola, 68000 был изначально сделан по сравнительно старой технологии, которая уступала даже той, что использовали при производстве 6502. Кстати, одной из важных причин общего краха 68k стало неспособность Motorola быстро наладить массовое производство 68000 и 68020.

<p>К списку неожиданных неудобств можно ещё добавить странности при работе с данными размером в слово. При загрузке слова в адресный регистр происходит знаковое расширение до двойного слова, при загрузке в регистр данных такого не происходит, но команда MOVEM делает знаковое расширение и для регистров данных! Операции с адресными регистрами (CMPA, ADDA, SUBA) размером в слово используют знаковое расширение только для первого операнда, второй всегда берётся размером в два слова. Последнее может затруднить использование адресных регистров для хранения неадресных величин, размером в слово, например, счётчика.

<p>Нельзя не удивляться наличию в системе команд 68000 двух разных способов для вызова подпрограмм &ndash; это уникальная странность архитектуры 68k. Инструкция <code class=code>BSR.W addr</code> абсолютна идентична по функциональности, размеру и таймингам инструкции <code class=code>JSR addr(PC)</code>. Аналогичным образом, в системе команд присутствуют два способа для совершения безусловного перехода, которые также абсолютно идентичны: <code class=code>BRA.W addr</code> и <code class=code>JMP addr(PC)</code>. Некоторый смысл командам BSR и BRA придает только наличие их коротких версий. Однако, BSR.S может быть полезна сравнительно редко, например, для маленьких рекурсивных подпрограмм. И, в любом случае, для чего поддерживать совершенно бесполезные длинные версии этих инструкций?! Есть и другие практически лишние команды, например, арифметические и логические сдвиги влево фактически делают одно и то же. Кстати, сдвиги и вращения с памятью можно использовать только однократные и только с 16-битными данными &ndash; байты и 32-битные величины не поддерживаются даже на 68020 и более поздних процессорах! Ещё может удивить наличие очень малополезной короткой абсолютной адресации &ndash; лучше бы вместо неё сделали перемещаемую адресацию по операнду-приемнику.

<p>Коды для Motorola 68k обычно выглядят как-то более громоздко и неуклюже по сравнению с х86 или ARM. Это во многом связано с обилием уникальных суффиксов S, B, W, L в инструкциях ассемблера 68k. Например, можно написать вот такую странную и бесполезную команду <code class=code>MOVE.L D0,(A0,D0.W)</code>, которая означает, что нужно записать 32-бита данных из регистра D0 по адресу, получаемому сложением содержимого 32-бит регистра A0 и 16-бит регистра D0.

<p>С другой стороны, 68000 всё же побыстрее 8086 на одинаковых частотах, по моим оценкам примерно на 10-40%. А при интенсивном использовании 32-битных данных или больших массивов 68000 может обогнать 8086 даже в несколько раз. Кроме того, варианты первых 68к могли работать на частотах более двух раз, превосходящих доступные для x86! Кодам 680x0 к тому же присуща и какая-то своя особенная красота и элегантность, меньшая механистичность, характерная для x86. Кроме того, как показало общение с экспертами eab.abime.net, плотность кодов у 68k часто лучше, чем у x86. 68000, как и ARM или VAX, может в качестве базы использовать PC, что очень удобно. x86 и даже IBM/370 этого не умеют &ndash; поддержка такой адресации появилась только у x86-64. Хотя, стоит отметить, что адресации по PC у 68к доступна только для операнда-источника, для операнда-приёмника или даже одноадресных команд (например, NOT или TST) она не работает, что делает её почти бесполезной. Проблемы с перемещаемостью кода сделали, например, необходимостью делить код на сегменты, не большие 32 КБ, под Macintosh OS. Наличие большего числа регистров у 68000 также существенное преимущество по сравнению с 8086, хотя из-за невозможности на 68000 быстро использовать отдельные байты 16-битного слова, это преимущество проявляется только при обработке 16- и 32-разрядных данных. Очень хорошо для 68к сделаны операции инкремента и декремента, которые позволяют использовать шаг от 1 до 8 &ndash; в x86 и большинстве других известных архитектур шаг всегда равен 1. 68k, в отличие от x86, может грузить слова только с четных адресов, поэтому операции с байтами со стандартным стеком работают нетипично, указатель стека меняется на 2, а не на 1. Для стеков, организованных через регистры A0-A6, такого не происходит. 68k имеет очень гибкую и удобную инструкцию MOVEM, которая позволяет сохранять или восстанавливать любое множество регистров, &ndash; подобная инструкция есть и для ARM, а в x86 приходиться для таких операций использовать много команд для сохранения или восстановления отдельных регистров. Но MOVEM занимает 4 байта, поэтому когда нужно сохранять или восстанавливать не более трех регистров, код на x86 получается более компактным. Кроме того, x86 (c 80286) имеет ещё команду для сохранения и восстановления сразу всех регистров, поэтому в общем случае преимущество 68k из-за наличия MOVEM не слишком значительно. Приятна также почти полная ортогональность инструкции MOVE &ndash; данные можно пересылать из разных мест памяти, не используя регистры. Но это команда &ndash; исключение, другие команды, например, CMP не ортогональны. Весьма привлекательная черта архитектуры 68k &ndash; это адресные режимы с авто-инкрементом и -декрементом, таких на x86 нет. Независимость пользовательского стека от прерываний позволяет использовать данные над вершиной стека, что немыслимо на 8086. Такой очень странный и нерекомендуемый способ работы со стеком доступен и на x86 в многозадачных средах, где у каждой задачи и у системы есть свои стеки.

<p>В целом, 68000 &ndash; это хороший процессор, с большой системой команд. Его изначально планировали для использования в миникомпьютерах, а не персоналках. Несколько иронично поэтому, что последнее массовое примение этот процессор нашел во второй половине 90-х в калькуляторах и карманных компьютерах. Однако именно под 68000 начинается разработка рабочих станций фирмами Sun, Apollo, HP, Silicon Graphics и позднее NeXT. В этот список можно добавить и Apple, которая производила компьютер Lisa класса рабочих станций. 68000 использовали во многих ныне легендарных персональных компьютерах: в первых компьютерах Apple Macintosh, которые выпускались до середины 90-х, в первых мультимедийных компьютерах Commodore Amiga, в сравнительно недорогих и качественных компьютерах Atari ST. 68000 также использовался в относительно недорогих компьютерах, работающих с вариантами Unix, в частности, в довольно популярном Tandy 16B. Стоит ещё упомянуть быстрые и недорогие компьютеры Sage, которые какое-то время были самыми быстрыми персональными компьютерами вообще &ndash; их развитие сложилось весьма драматично. Интересно, что IBM одновременно с разработкой PC вела разработку компьютера System 9000 на базе 68000, который был выпущен менее, чем через год после PC.

<div align=center>
<p><img src=https://habrastorage.org/webt/bb/6q/iu/bb6qiuatbww6hvwaqzjs5gzv6oi.jpeg style=width:50%>
<p style=font-size:90%>Apple Lisa &ndash; странно, что у первых компьютеров Apple на базе 68000 (Lisa и Macintosh) графика была черно-белой, тогда как у восьмибитников Apple ][ она была цветной
</div>
<div align=center>
<p><img src=https://habrastorage.org/webt/7p/1w/bv/7p1wbvftf4q8trooqzrsxk57wq0.gif>
<p style=font-size:90%>Это известная демка для Amiga 1000, такая графика в 1985 казалась невероятной фантастикой. Это картинка в формате GIF, что позволяет показывать только 256 цветов из 4096, показываемых реальной Амигой, &ndash; другие форматы для полноцветной анимированной графики всё ещё поддерживаются недостаточно хорошо
</div>

<p>68010 появился явно запоздало, только в 1982, тогда же Intel выпустила 80286, поставивший персональные компьютеры на уровень мини-ЭВМ. 68010 совместим по разъёму с 68000, но система его команд чуть-чуть отличается, поэтому замена 68000 на 68010 так и не стала популярной. Несовместимость была вызвана надуманной причиной привести 68000 в большее соответствие с идеальной теорией организации поддержки виртуализации. Другим почти бесполезным новшеством стала возможность перемещать таблицу векторов прерываний. 68010 лишь незначительно, не более чем на 10% быстрее 68000. В 68010 была наконец исправлена недоработка, не позволявшая использовать виртуальную память. Очевидно, что 68010 сильно проигрывал 80286 и был даже послабее появившегося в том же году 80186. Как и 80186, 68010 практически так и не нашёл себе применения в персональных компьютерах.

<p>68008 был также выпущен в 1982 наверное с надеждой повторить успех 8088. Это 68000, но с 8-разрядной шиной данных, что позволяло использовать его в более дешевых системах. Но 68008, как и 68000, не имеет очереди команд, что делает его на примерно 50% медленнее, чем 68000. Таким образом, 68008 может быть даже чуть медленнее, чем 8088, который из-за наличия очереди команд лишь на примерно 20% медленнее, чем 8086. IBM предлагала Motorola сделать 68008 к 1980, но тогда IBM отказали, хотя это стоило бы по признанию сотрудников Motorola работы одному сотруднику только менее месяца. Если бы отказ не случился, то возможно IBM выбрала бы 68008 для IBM PC.

<p>На основе 68008 сэр Клив Синклер сделал Sinclair QL &ndash; очень интересный компьютер, который из-за более низкой цены мог бы конкурировать с Atari ST и похожими компьютерами. Но Клив параллельно и явно преждевременно стал очень много сил вкладывать в развитие электромобилей, оставив QL (Quantum leap &ndash; квантовый скачок) скорее как второстепенную задачу, что при наличии некоторых неудачных конструктивных решений, привело компьютер и всю фирму Клива к преждевременному закрытию (фирма стала частью компании Amstrad, которая отказалась производить QL).

<p>Было бы интересно посчитать индекс разрядности для 68000, он, как мне кажется, явно повыше 16, хотя скорее и не выше 24.

<p>Появившись в 1984, 68020 опять вернул Motorola на первые позиции. В этом процессоре были реализованы многие очень интересные и перспективные новинки. Самый сильный эффект безусловно производит конвейер инструкций, позволяющий иногда выполнять до трёх инструкций одновременно! 32-разрядная шина адреса выглядела в те годы несколько преждевременной и поэтому выпускался более дешёвый вариант процессора 68020EC с 24-битной шиной. Зато 32-разрядная шина данных выглядела уже вполне уместно и позволяла значительно ускорить работу. Новинкой выглядел и встроенный кэш пусть и небольшого, 256 байт, объема, что позволяло иногда значительно улучшить быстродействие, так как основная динамическая память уже не успевала за процессором. Хотя в общем случае такой маленький кэш лишь незначительно влиял на производительность. Были добавлены достаточно быстрые операции для деления (64/32=32,32) и умножения (32*32=64), за примерно 80 и до 45 тактов соответственно. Тайминги инструкций были в целом значительно улучшены, например, деление (32/16=16,16) стало выполняться за примерно 45 тактов (более 140 тактов у 68000). Некоторые инструкции в самых благоприятных случаях могут исполняться, не занимая тактов вообще! Были добавлены новые адресные режимы, в частности, с масштабированием &ndash; у x86 такой режим появился только в следующем году у 80386. Другие новые адресные режимы позволяют использовать двойную косвенную адресацию, используя при этом несколько смещений, &ndash; PDP-11 был здесь заметно превзойден.

<p>Но некоторые новые инструкции, например, тяжеловесные операции с битовыми полями или ставших малонужными при быстрых делении и умножении новые операции с 10-и числами, выглядели скорее пятым колесом у телеги, чем чем-то существенно полезным. Адресные режимы с двойной косвенной адресацией теоретически выглядят интересно, но практически нужны довольно редко и исполняются медленно. Эти режимы, как и избыточность генерации флагов, плохо вписывались в наступающую эпоху мультискалярных архитектур. Возможность использования 32-разрядного смещения в адресации была скорее преждевременным новшеством, так как для объемов памяти на системах до середины 90-х такие большие смещения практически никогда не требовались. Тут опять, как и в случае с 68000, Motorola предложила пользователям платить за возможность работать с такими большими размерами памяти, которые ещё фактически не могли быть аппаратно обеспечены. В отличие от 80286, 68020 требует времени для вычисления адреса операнда, так называемого эффективного адреса. Деление у 68020 получилось всё же почти в два раза медленнее чудо-деления у 80286. Умножение и некоторые операции также медленнее. В целом, 68020 получился заметно медленнее, чем 80286 для байтовых операций. На операциях с 16-битными данными 68020 был только незначительно медленнее и только на операциях с 32-битными данными 68020 уже явно превосходил 80286. У 68020 нет встроенной системы управления памятью (MMU) и скорее экзотическая возможность подключать до восьми сопроцессоров этого не могла исправить. Сам главный архитектор 68000 признал, что в 68020 было сделано слишком много режимов адресации и что получился поэтому какой-то монстр. Типа ориентировались на VAX и удобство ассемблерного программирования, а будущее пришло с RISC, высокими скоростями и мощными компиляторами. А вот ещё цитата от Билла Джоя: "Стало ясно, что Motorola развивает свои процессоры примерно также ошибочно как и DEC. Другими словами, 68010 68020 68040, становились более и более сложными. И они буксовали, не становясь быстрее такими же темпами как транзисторы, из которых они были сделаны". Стоит ещё добавить, что в 68020 специально для прерываний добавили ещё третий стек!

<p>Неудивительно поэтому, что в современном развитии архитектуры 68k отказались практически от всех новых команд 68020. Это касается, в частности, процессоров Coldfire и 68070, используемых во встроенных системах.

<p>68020 широко использовался в массовых компьютерах Apple Macintosh II, Macintosh LC и Commodore Amiga 1200. Он также использовался в нескольких моделях систем для работы с Unix.

<p>Появление 80386 со встроенным и очень добротно сделанным MMU и 32-разрядными шинами и регистрами, опять поставило Motorola в позицию номер 2. 68030, появившись в 1987, в последний раз, ненадолго смог вернуть Motorola лидерство. 68030 имеет встроенную систему управления памятью и увеличенный в два раза кэш, разделенный на кэш для инструкций и данных &ndash; это была очень перспективная новинка. MMU у 68030 не тормозит работу, как это происходило с внешним MMU у 68020. Кроме того, 68030 мог использовать более быстрый интерфейс доступа к памяти, что может ускорять операции с памятью почти на треть. Однако, в целом работа с памятью осталась медленной &ndash; 4 такта на обращение, т.е. число тактов осталось таким же как и у 68000. Об этом даже шутили как о "стандартном цикле памяти Motorola". Для сравнения, у 80286 такой цикл занимал 2 такта, а у ARM или 6502 &ndash; 1. Справедливости ради надо добавить, что официально цикл доступа к памяти у 68020 и 68030 занимает 3 такта, но во многих инструкциях фактически получается скорее 4. Несмотря на все новшества, 68030 оказался несколько медленнее 80386 на одинаковых частотах. Однако, 68030 был доступен на частотах до 50 Мгц, а 80386 только до 40 Мгц, что делало топовые системы на базе 68030 слегка быстрее. Неожиданно, но 68030 не поддерживает некоторые инструкции своего предшественника (CALLM и RTM)! Недостатки архитектуры процессоров 68k вынудили основных производителей компьютеров на базе этих процессоров искать им замену. Sun начала производить собственные процессоры SPARC, Silicon Graphics перешла на процессоры MIPS, Apollo разработала собственный процессор PRISM, HP стала использовать собственный процессоры PA-RISC, ATARI стала работать со специализированными RISC-процессорами, а Apple была вынуждена перейти на процессоры PowerPC. Интересно, что Apple собиралась перейти на SPARC во второй половине 80-х, но договориться с Sun не получилось. Можно только удивляться тому, как плохо работал менеджмент у Motorola, они как будто сами не верили в будущее своих процессоров. Тут можно ещё добавить, что Motorola выпускала вариант процессора 68030 без MMU! Такой вариант использовался в самых дешевых вариантах компьютера Commodore Amiga 4000. Intel таких изделий не производила, хотя для самой популярной тогда ОС DOS MMU был не нужен.

<p>68030 использовался в компьютерах серии Apple Macintosh, Commodore Amiga 3000, Atari TT, Atari Falcon и некоторых других.

<p>С 68040 Motorola очередной раз попыталась превзойти Intel. Этот процессор появился год спустя после 80486, но по совокупности полезных качеств он так и не смог его превзойти. Фактически Motorola 68k, имея более перегруженную систему команд, оказалась не в состоянии её поддерживать и в каком-то смысле сошла с дистанции. Кроме того, Motorola участвовала также в разработке PowerPC, который запланировано шел на смену 68k и это не могло не сказаться на качестве разработки 68040. В 68040 смогли поместить только очень урезанный сопроцессор для работы с вещественными числами и сам чип грелся существенно больше, чем 80486. Согласно результатам на lowendmac.com/benchmarks 68040 только примерно в 2.1 раза быстрее 68030, что означает, что 68040 несколько медленнее 80486 на той же частоте. Хотя на некоторых тестах 68040 существенно быстрее 80486. 68040 практически не нашёл применения в популярных компьютерах. Некоторое заметное применение нашёл только его более дешёвый вариант &ndash; 68LC040, не имеющий встроенного сопроцессора. Однако, первые варианты этого чипа имели серьёзный аппаратный дефект, не позволяющий использовать даже программную эмуляцию сопроцессора! Возможно это было сделано умышленно, так как в Power Macintosh не предполагалась эмуляция инструкций сопроцессора. Но главная проблема 68040 &ndash; это то, что Motorola так и не смогла сделать его вариант с удвоением частоты, как это смогла сделать Intel для 80486DX2 в 1992.

<p>Проблемы с математическим сопроцессорами у Motorola были всегда. Motorola, как уже об этом упоминалось, так и не выпустила такого сопроцессора для 68000/68010, в то время как Intel выпускала свой очень успешный 8087 c 1980. В Atari, однако, нашли способ продключать сопроцессор для 68020/30 к 68000 в компьютерах серии ST &ndash; сопроцессор там мог быть подключен по адресам в памяти, что конечно его замедляло и требовало использования нетипичных кодов. Для 68020/68030 получился уже перебор, для них производились сразу два сопроцессора: 68881 и улучшенный пин-совместимый с ним 68882. Однако, эти сопроцессоры были не 100% совместимы и для получения заметного прироста быстродействия от использования 68882, код нужно было генерировать специальным образом. Таким образом, коды, сгенерированные для 68881, работали на 68882 лишь незначительно быстрее. 68882 появился позднее и стоил заметно дороже 68881. Интересно, что встроенный сопроцессор архитектуры PowerPC имеет меньшую точность, чем 68881/82, поэтому результаты расчетов с дробными числами на Power Macintosh получаются менее качественными, чем на прежнем поколении компьютеров Macintosh!

<p>Тут уместно сказать, что и Intel x86 пор сих имеет проблемы с математическим сопроцессором &ndash; точность расчетов некоторых функций, например, синуса на некоторых аргументах совсем небольшая, иногда не более 4 знаков. Поэтому современные компиляторы часто вычисляют такие функции, не прибегая к услугам сопроцессора.

<p>Удивительно, что Motorola смогла ещё выпустить 68k процессор класса Pentium, 68060 в 1994. Этот процессор также имел проблемы с арифметикой вещественных чисел. И, главное, ни осталось ни одной популярной системы, кроме Commodore Amiga, где 68060 мог бы найти применение, но компания Commodore обанкротилась в том же 1994. Согласно некоторым конспирологическим теориям Commodore обанкротилась, в частности, из-за того, что 68060 мог создать конкуренцию архитектуре Power PC, которую стали использовать компьютеры Apple Macintosh.

<p>Процессоры Motorola вплоть до 1994 включительно были в целом вполне сравнимы с Intel x86 и в отдельных важных частностях они были всегда лучше. Однако в Intel, в отличие от Motorola, очень много сил потратили на удержание своих заказчиков и привлечения новых. И иногда в борьбе со своим основным конкурентом Intel действовала почти некрасиво. Трудно поверить, что большая обзорная статья в журнале Byte от 9/1985, где про 68000 огульно заявляется, что он "по сравнению 8088 требует огромных усилий для того, чтобы программы работали нормально", могла появиться вне контекста этой борьбы. С другой стороны, Motorola все делала позже и дороже Intel. Кроме того, процессорам Motorola явно не хватало оригинальности, слишком многое было скопировано с технологий DEC и IBM. Среди причин краха 68k, в частности, и Motorola, в целом, иногда называют и политическую причину, а именно недостаточные вложения этой компании в экономику Израиля, что сильно отличало её от Intel. Конечно, провал 68k был вызван комплексными причинами, сочетающими в себе как слабый стратегический маркетинг, так и некоторые архитектурные недостатки.

<p>Но на этом история не закончилась. В 2015, когда Motorola уже давно ушла в прошлое, был выпущен Apollo Core 68080!

<p>Почему-то процессоры архитектуры 68k даже не пытались склонировать в СССР (склонирован был только 68881), хотя на основе 68020 был разработан компьютер <a href=https://ru.wikipedia.org/wiki/%D0%91%D0%B5%D1%81%D1%82%D0%B0_(%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80)>Беста</a>.

<br>
<hr>
<p>Cтатья опубликована на <a href=https://geektimes.ru/post/298735/>geektimes</a>, а также переведена на <a href=https://litwr.livejournal.com/789.html>английский</a>.
</body>

