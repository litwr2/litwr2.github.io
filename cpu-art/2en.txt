However, the larger size allowed more functionality to be squeezed in.  For example, the 68000 can handle up to 8 external interrupts without an external controller.  The x86 architecture, on the contrary, requires an external interrupt controller (the only very special exception is the 80186).  The data and address buses of the 68000 are not multiplexed, unlike the 8086.  Only with the 80286, Intel abandoned such multiplexing which is slowing computer systems.

Addressing via base and index registers is done on the 68000 at the level of the 8-bit 6800 or Z80, with a single-byte offset – this is somehow completely impractical. On the 8086 offsets are 16 bits, on the ARM or IBM/370 – 12. Even the 6502 can use a 16-bit offset along with indexing.  Surprises with the 68k can occur with the unusual loop instruction, which should be passed not the number of repetitions, but a number one less.

This is a famous demo for the Amiga 1000, such graphics in 1985 seemed incredible fantasy. This is an image in GIF format, which allows you to show only 256 colors out of 4096 displayed by the real Amiga – other formats for full-color animated graphics have still not been well supported [a caption]

The IBM System/370-145 with the 2401 tape unit and a printer instead of display, 1971 [a caption]

The IBM 5100, a version with APL support [a caption]

The popular processors 68020 or 80386 also supported 32-bit addresses. [Popular processors the 68020 or 80386 also supported 32-bit addresses.]

Initially, BAL did not have relative, relocatable jumps like the Z80 or x86. They were only added to the System/390.

The SPM, TM, TS, STCK, and STPT instructions are also somewhat unusual. The first one allows you to set all operation flags and the optional exception mask with a single command. The TM instruction allows you to check a group of bits and determine three cases: all zeros, all ones, and a mix of zeros and ones. Such a check cannot be performed by a single command in other architectures. However, TM only works with individual bytes in memory. TS is used when working with multiple processors – there is a similar command for the 68k. The STCK instruction reads the value of an external (!) timer, and the STPT instruction reads the value of an internal timer embedded in the processor circuit. Strangely, the STPT command is privileged, but the STCK is not.

It is also worth mentioning the CS and CSS instructions, which are designed to support multiprocessing. They are implemented for the System/370, i.e. they became available since the early 70s. In the x86, the CS analog, the CMPXCHG instruction, was implemented no earlier than 1987, and the CDS analog, the CMPXCHG8B instruction, was implemented only in 1994!

The STIDP processor identification instruction is introduced from the System/370. It is privileged and not very informative. For the x86, analogous command is significantly more powerful. Here you can also notice that the IBM 4361 in LCM allows any user to execute STIDP. This is obviously an exception-triggered emulation.

Four BAL addressing modes specify two operands for the instruction, and the fifth mode specifies three-operand commands. However, ignoring some of the information allows you to have one-operand commands, and the use implicit information allows you to have four-operand commands. Ignoring is implemented through the special role of register 0. If it is used in the address, it is not counted. All BAL instructions take up strictly 2, 4, or 6 bytes. It is similar to the 68k or PDP-11 but not to the x86, VAX or ARM.

Several more addressing modes were added to the System/390, bringing their number to 18. The number of instructions has also increased significantly, among the new instructions there are even ones that support working with Unicode – this is still not available for x86! Among the new instructions of the System/390, there are other unique ones. Several more addressing modes were added to the System/Z, and the total number of instructions for the modern Z is very large and probably even more than the number of commands for the modern x86-64!
