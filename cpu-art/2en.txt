However, the larger size allowed more functionality to be squeezed in.  For example, the 68000 can handle up to 8 external interrupts without an external controller.  The x86 architecture, on the contrary, requires an external interrupt controller (the only very special exception is the 80186).  The data and address buses of the 68000 are not multiplexed, unlike the 8086.  Only with the 80286, Intel abandoned such multiplexing which is slowing computer systems.

Addressing via base and index registers is done on the 68000 at the level of the 8-bit 6800 or Z80, with a single-byte offset – this is somehow completely impractical. On the 8086 offsets are 16 bits, on the ARM or IBM/370 – 12. Even the 6502 can use a 16-bit offset along with indexing.  Surprises with the 68k can occur with the unusual loop instruction, which should be passed not the number of repetitions, but a number one less.

The 68000, like the ARM or VAX, can use PC as a base, which is very convenient.  The x86 and even the IBM/370 can't do this - support for such addressing appeared only in the x86-64.  Having more registers is also a significant advantage for the 68000 compared to the 8086, although this advantage is only shown when processing 16-and 32-bit data due to the inability of the 68000 to quickly use separate bytes of a 16-bit word.

This is a famous demo for the Amiga 1000, such graphics in 1985 seemed incredible fantasy. This is an image in GIF format, which allows you to show only 256 colors out of 4096 displayed by the real Amiga – other formats for full-color animated graphics have still not been well supported [a caption]

The IBM System/370-145 with the 2401 tape unit and a printer instead of display, 1971 [a caption]

The IBM 5100, a version with APL support [a caption]

A dynamic demo running on the IBM 4381 emulator in LCM, an emulator of terminal 3270-3 is used [a caption]

The popular processors 68020 or 80386 also supported 32-bit addresses. [Popular processors the 68020 or 80386 also supported 32-bit addresses.]

Initially, BAL did not have relative, relocatable jumps like the Z80 or x86. They were only added to the System/390.

The SPM, TM, TS, STCK, and STPT instructions are also somewhat unusual. The first one allows you to set all operation flags and the optional exception mask with a single command. The TM instruction allows you to check a group of bits and determine three cases: all zeros, all ones, and a mix of zeros and ones. Such a check cannot be performed by a single command in other architectures. However, TM only works with individual bytes in memory. TS is used when working with multiple processors – there is a similar command for the 68k. The STCK instruction reads the value of an external (!) timer, and the STPT instruction reads the value of an internal timer embedded in the processor circuit. Strangely, the STPT command is privileged, but the STCK is not.

It is also worth mentioning the CS and CSS instructions, which are designed to support multiprocessing. They are implemented for the System/370, i.e. they became available since the early 70s. In the x86, the CS analog, the CMPXCHG instruction, was implemented no earlier than 1987, and the CDS analog, the CMPXCHG8B instruction, was implemented only in 1994!

The STIDP processor identification instruction is introduced from the System/370. It is privileged and not very informative. For the x86, analogous command is significantly more powerful. Here you can also notice that the IBM 4361 in LCM allows any user to execute STIDP. This is obviously an exception-triggered emulation.

Four BAL addressing modes specify two operands for the instruction, and the fifth mode specifies three-operand commands. However, ignoring some of the information allows you to have one-operand commands, and the use implicit information allows you to have four-operand commands. Ignoring is implemented through the special role of register 0. If it is used in the address, it is not counted. All BAL instructions take up strictly 2, 4, or 6 bytes. It is similar to the 68k or PDP-11 but not to the x86, VAX or ARM.

Several more addressing modes were added to the System/390, bringing their number to 18. The number of instructions has also increased significantly, among the new instructions there are even ones that support working with Unicode – this is still not available for x86! Among the new instructions of the System/390, there are other unique ones. Several more addressing modes were added to the System/Z, and the total number of instructions for the modern Z is very large and probably even more than the number of commands for the modern x86-64!

In the systems 360, 370 and 390, the offset when accessing data in memory, as in the ARM, is 12-bit, i.e. no more than 4095, which is not very convenient – in large programs, there may be a lack of registers for basing. In x86, this offset is 16-bit, which, of course, is much more convenient. But the System/Z has added support for addressing with a 20-bit offset, which is of course even better. Although, it is worth noting that in the x86-64, the offset can be 32-bit. As already noted, in systems before 390, as in the ARM, it was not possible to use large constants when working with registers. The x86 architecture was much more flexible here. Therefore, when using an assembler with the systems 360 or 370, it was often mandatory to use literals or pseudo-constants, which is somewhat slower.

Systems that are compatible with the IBM/360 have always had good performance. My experiments with the LCM's 4361-1, in particular, in the project of calculating the number π using the spigot-algorithm, showed very good timings. The 4361-1 instructions work almost without delay, this is like the ARM or other modern processors. However, due to the somewhat awkward command system inherited from the 60s, in particular, due to the lack of division by a 16-bit divider, the result for the efficiency of the processor electronics was at the level of the 80186. This is about 80% worse than the result shown by the then best computer from the VAX family, the model 785. However, the mainframe in LCM is clearly not the best among the IBM mainframes available then.

As a student, I happened to work with a Soviet IBM/370 clone, the ES-1045, in 1987 through batch mode, and in 1989 through dialog mode. For batch mode, we had to prepare punch cards. At that time, I was already using a home computer and therefore the use of archaic punch cards did not leave the best impression. However the dialog mode was not bad, but it often broke down when there were a large number of users. Therefore, some students came to work by 4 am! Since then, I have not been able to deal with mainframes anymore. I only recently decided to use emulation to sort out this landmark technology for the history of computers.

The cloning of the IBM/360 was very popular. Such clones were made in England, Germany, Japan, and other companies in the United States. In the USSR, this cloning took on a very dramatic connotation. For the sake of this cloning, almost all domestic developments in the field of IT were curtailed, some of which were quite promising. In particular, the branch of Ural computers was closed, about which a known computer man Charles Simonyi later spoke with warmth. The BESM-10 project was also closed, although the machines of the previous BESM-6 class were comparable to the IBM/360 in performance. Also, for the sake of this cloning, an almost concluded contract with ICL was torn off, perhaps with this contract, the British IT industry would have acquired a new dynamic and would not have fallen into decline. Only the Elbrus supercomputers, perhaps because of their connection to the defense industry, survived the "clone invasion", which Dijkstra called the greatest US victory in the Cold war.

As people who worked with mainframes in the USSR recall, domestic clones were distinguished by extremely low reliability and required constant attention from the maintenance staff. While the original American IBM mainframes were among the most reliable computers of their time. Soviet clones were put in kilograms and sometimes tens of kilograms of precious metals, gold, platinum, palladium and silver, but this did not help to fix the situation with reliability. Because of such a large number of highly liquid values, it is difficult to imagine that a working domestic clone could be preserved anywhere.

Interestingly, the chief architect of the IBM/360 left IBM and founded Amdahl Corporation, which for more than two decades specialized in the production of systems compatible with IBM mainframes and at the same time slightly superior in performance and reliability at lower prices. As a result, due to major changes in the mainframe market, Amdahl, like ICL, became part of the Japanese company Fujitsu.

As it was already written above, I managed to set up a working configuration for VM/SP 6. However, it turned out that XEDIT editor is not freely available, and a simple EDIT is too peculiar and inconvenient, so I have to edit the texts on the host. It was also discovered that the standard program for transferring files from a terminal emulator to the mainframe and back was unavailable, which required the use of virtual punch cards for such a transfer. Another unpleasant surprise was found in connection with debugging. The DEBUG command does not support step-by-step execution! While this feature was even available for the DDT debugger for the 8080 processor. It is also surprising, though less critical, that DEBUG is not able to do disassembly, which was often embedded even in the simplest monitors of the 70s processors. Under VM/SP, long line wrapping and line break control characters are not supported at the low level! Therefore, when printing from an assembly language program, you need to format lines manually so that they do not disappear beyond the right edge of the screen, and also take care of filling the last line with finishing spaces. The lack of automatic vertical scrolling is also unusual.

Those who want to work with mainframes for the first time should keep in mind that mainframes are a huge ecosystem, where many familiar concepts can have a different interpretation. For example, there is no simple concept of file. One of the key attributes of a file is its record size, there is nothing like this for Linux or Microsoft Windows files. The files themselves differ in the methods of accessing them and about this was written and may be written non-thin books. It is also unusual that in VM/SP, the disk name is written at the end of the full file name, and the name, extension, and disk are separated by spaces, and the disk name itself is called the file mode for some reason. I would also like to sort out multitasking MVS, as far as I know they never got to it in the USSR.

In general, it is somewhat unexpected that some well-known operating systems that were used on very expensive computers did not support working with file directories, which equated them with the very first and primitive OS for microcomputers, such as CP/M or Commodore DOS. This is why VM/SP was sometimes called CP/M for mainframes. Surprisingly, as far as I know, support for directories in VM/SP has not been introduced, although the last release of the system dates back to 2018. For some reason, working with directories for expensive computers before the 80's was often poorly supported. For example, there was no such support in DEC RT-11 and even one of the best OS for the PDP-11, RSX-11, only supported two-level directories. The most popular IBM operating system until the 2000s was MVS (1974) and even here the directories were only partially made, as in Apple MFS (1984). Although in Unix (1973), MS-DOS (since 1983), or even 8-bit Apple ProDOS (1983), this was all right from the start. The most advanced work with files was offered in VAX/VMS (1977), where in addition to directories, there is even built-in support for file versioning.

Interestingly, the scripting language for VM/SP, MVS and some other IBM operating systems, Rexx, in its reduced form became the language of batch files for the Commodore Amiga.

Mainframe software usually uses only two colors. Color-enabled terminals were used relatively rarely and therefore there were few color programs. There are also few programs with dynamic graphics: frequent screen updates lead to noticeable unpleasant flickering.

In conclusion, I can't help but express my admiration for IBM's technologies. They have always been distinguished by their unique originality and high level. I would especially like to note the very good quality of documentation, which is publicly available even for modern systems. IBM demonstrates tremendous dynamism in technology development, even though it is one of the largest companies in the world. In terms of the number of employees, it is almost equal to Microsoft, Google and Intel taken together!

The theme of mainframes is very vast. Of course, I was able to write only a small part of what it can hold. I would be very grateful for clarification and additional information.

