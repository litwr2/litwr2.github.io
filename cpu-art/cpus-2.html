<head>
<meta charset=utf-8>
<title>Эмоциональная история IBM/370</title>
<meta name=keywords content="CPU,processor,computer,history,IBM,Intel,ARM,hardware,System/360,System/370">
<link rel=stylesheet type=text/css href=style.css>
</head>
<body>
<h1 id=first>Эмоциональная история IBM/370</h1>

<p>В <a href=>первой части</a> написал про многие разные процессоры до середины 90-х. Для мейнфреймов IBM там места не нашлось, так как эти системы не использовали процессоры-чипы. Однако, мейнфреймы IBM тесно связаны с другими компьютерными системами, долгое врямя являясь лучшими образцами компьютерной техники, на которую так или иначе ориентировались практически все. Кстати, формат хабр-блога, как и Википедии, позволяет редактирование, что позволило значительно переработь содержимое упомянутой первой части с учетом поступивших замечаний и прочей дополнительной информации.

<p>Первые системы 360 стали поставляться заказчикам с 1965 года, а более совершенные системы 370 с 1970. IBM поддерживает программную совместимость с этими системами до настоящего времени!

<p>Кстати, некоторые авторитеты считают, что первый персональный компьютер был <a href=https://en.wikipedia.org/wiki/IBM_5100>IBM 5100</a>, производимый с 1975, который через аппаратный эмулятор мог исполнять инструкции системы 360. Его улучшенные варианты производились до средины 80-х. Хотя скорее всё-таки первым серийным ПК был <a href=https://en.wikipedia.org/wiki/Wang_2200>Wang 2200</a>. По ценам (примерно $10000) эти первые персональные компьютеры были явно не для домашнего использования.

<p>IBM использует довольно необычную для сегодняшнего дня бизнес-модель, при которой компьютеры не продаются, а сдаются в аредну. Одно из преимуществ такой модели в том, что она гарантирует постоянный апгрейд аппаратуры, устаревающая техника автоматически заменяется на обновленную соответствующего класса. У этой модели есть и недостатки. Например, особенно ощутимый недостаток для тех, кто занимается историей компьютерных технологий, &ndash; это то, что отслужишие свое компьютеры практически всегда утилизируются и поэтому их практически невозможно встретить ни в каком музее.

<p>Удивительно было обнаружить живую систему IBM 4361 в <a href=>LCM</a>! Но есть основания предположить, что это возможно не настоящее железо. Доступ посетителей музея к этому компьютеру почему-то закрыт. Не понятно также, какая именно модель там якобы представлена, и это при том, что другие компьютеры в музее идентифицируются весьма точно. Среди систем 4361 известны три модели 3, 4 и 5, причем модель 3 появилась позже моделей 4 и 5. Но система в музее самоидентифицируется как модель 1. Возможно, что это прототип. Однако, сотрудники музея на прямой вопрос о помощи с идентификацией не ответили и это при том, что на другие и часто довольно сложные вопросы они отвечают довольно оперативно. Некоторые особенности таймингов исполнения кодов дают основания, хотя и не абсолютно твердые, предполагать, что скорее всего к сети подключен эмулятор.

<p>Но что бы там ни было, каждый может подключиться и попробовать поработать примерно также как работали очень высокооплачиваемые специалисты с середины 70-х. Цены были такие, что сегодня трудно поверить. Например, час машинного времени стоил в середине 80-х более 20 долларов и надо было ещё доплачивать за место на дисках. Правда речь идет именно о времени работы мейнфрейма, а не терминала, через который шла работа. Поэтому, например, при редактировании текста из часа фактической работы редко набиралось и 5 минут времени на оплату. Цены на сами мейнфреймы также были фантастические. Например, сотрудники Intel вспоминают, что в начале 80-х им предоставляли для работы только один мейнфрейм. Его производительность была 10 MIPS, а цена примерно 20 миллионов тогдашних долларов, которые были раза в три тяжелее сегодняшних! Сейчас даже Raspberry Pi размером с таблетку и ценой в несколько долларов может запросто выдать более 1000 MIPS. Кстати, на Raspberry Pi или практически любом современном компьютере можно запустить эмулятор IBM/370, который будет работать значительно быстрее, чем любая система IBM из 80-х или даже 90-х. Однако, эмулятор надо настраивать и не все полезные программы для IBM/370 доступны свободно, поэтому бесплатный доступ к хорошо настроенной системе &ndash; это часто лучший способ поработать с мейнфреймом. Удивительно, но такие программы для доступа, эмуляторы терминалов, доступны даже на мобильниках! Между прочим, мне удалось наладить свою систему VM/SP на эмуляторе Hercules и наладить перенос файлов.

<p>Эмулятор Hercules может эмулировать и более поздние системы IBM/390 и IBM/Z, но из-за проблем с лицензией на программное обеспечением, это сделать намного сложнее. В качестве иллюстрации таких проблем приведу известный случай, когда IBM настояла на удалении раздела Эмуляция из уже опубликованной книги! В современных электронных вариантах этой книги этого раздела нет, его можно найти только в типографском издании или отдельным файлом на сайтах, посвященных свободному ПО. Дело в том, что эмуляция на обычных персоналках с начала 2000-х могла быть заметно быстрее, чем исполнение на гораздо более дорогих мейнфреймах. IBM поэтому пришлось изменить лицензии на своё программное обеспечение так, что его можно легально использовать только на аппаратуре, купленной у IBM.

<p>Рассмотрим теперь особенности машинного языка систем 360 и 370. Базовый ассемблер систем, совместимых с IBM/360, называют BAL &ndash; Basic Assembly Language. Удивительно, но если верить слухам о современном программировании в IBM, то там до сих пор ассемблер &ndash; это один из основных рабочих языков программирования!

<p>Ассемблер рассматриваемых мейнфреймов имеет ряд архаических особенностей, который в других архитектурах, появившихся с середины 70-х уже отсутствовали. Речь, например, идет о том, что мнемоники BAL определяют тип аргументов. Подобное сохранилось в ассемблере Intel 8080. Рассмотрим команды ассемблера x86 <code class=code>MOV&nbsp;EAX,EBX</code> и <code class=code>MOV&nbsp;EAX,address</code> &ndash; в обоих случаях используется мнемоника MOV. Для BAL для подобных случаев используются разные мнемоники, <code class=code>LR&nbsp;0,1</code> и <code class=code>L&nbsp;0,address</code>, т.&nbsp;е. LR и L соответственно. Однако подобные разные мнемоники позволяют использовать числа для именования регистров, хотя обычно макросы R0, R1, ... вместо чисел 0, 1, ... &ndash; это первое, что определяется в макропакетах для удобства программирования. Другой архаизм &ndash; это использование переходов по метке в конструкциях условной компиляции, хотя по моему скромному мнению &ndash; это часто удобнее блочных структур. Но самый известный архаизм &ndash; это использование кодировки EBCDIC для работы с символьной информацией. В этой странной даже для вчерашнего дня кодировке буквы английского алфавита кодируются не подряд, например, буква I имеет код 201, а следующая за ней J &ndash; 209! Система 360 на аппаратном уровне поддерживает и кодировку ASCII, но в её древнем и давно забытом варианте, где символ для цифры 0 имеет код 80, а не 48 как сейчас. Насколько мне известно, ASCII с мейнфреймами IBM лучше даже и не пытаться использовать. Кроме того, некоторые мнемоники BAL поражают своей краткостью и даже немнемоничностью, например, N значит AND, O &ndash; OR, X &ndash; XOR, A &ndash; ADD, S &ndash; SUBTRACT, M &ndash; MULTIPLY, ...

<p>Ассемблер BAL позволяет работать с тремя основными типами данных: двоичными, десятичными и вещественными числами. Инструкции для работы с каждым типом образуют особый и довольно изолированный класс инструкций. Как правило, за очень редкими исключениями все системы, совместимые с 360, поддерживают инструкции десятичной и вещественной арифметики. Как известно, для архитектур x86 или 68k поддержка работы с вещественными числами появилась не сразу и долгое время была необязательной опцией, а работа с десятичными числами не была чем-то совершенно отдельным от двоичной арифметики &ndash; это было скорее расширение.

<p>Для работы с вещественными и двоичными числами используют разные наборы регистров, а для работы с десятичными числами регистры не используются вообще. Система 360 предоставляет 16 32-разрядных регистра общего назначения для целых двоичных чисел, причем счетчик команд &ndash; это особый регистр. Отдельного стека нет, его можно организовать, используя любой регистр, &ndash; так впоследствие реализовали работу со стеком и в ARM. Вызов подпрограмм также сделан как и в ARM, через регистр связи. Практически всегда все регистры взаимозаменяемые, исключения очень редки. Если сравнивать систему двоичных регистров 360 с конкурентной архитектурой VAX, то можно заметить, что у VAX, как минимум, на один регистр меньше.

<p>Структура операндов в инструкциях покажется довольно знакомой тем, кто знает ассемблер x86. Для двоичных чисел операнды имеют структуру "регистр-регистр" или "регистр-память", причем для последнего случая из памяти можно загружать как 32-битные, так и 16-битные, расширяемые знаково, величины. Например, аналогом x86-инструкции <code class=code>ADD&nbsp;EAX,EBX</code> будет <code class=code>AR&nbsp;0,1</code>, <code class=code>ADD&nbsp;EAX,address</code> &ndash; <code class=code>A&nbsp;0,address</code>, <code class=code>ADD&nbsp;EAX,address[EBX]</code> &ndash; <code class=code>A&nbsp;0,address(1)</code>, <code class=code>ADD&nbsp;EAX,address[EBX][EDX]</code> &ndash; <code class=code>A&nbsp;0,address(1,3)</code>. Однако системы 360 и даже их поздние развитие не умеют работать с масштабированием, например, <code class=code>ADD&nbsp;EAX,address[8*EBX]</code> на BAL одной командой не запишешь. С другой стороны, x86 не умеет работать с 16-битными знаковыми расширениями, например, команда BAL <code class=code>AH&nbsp;0,address(1,3)</code>, которая означает взять 16-битное знаковое число из памяти и добавить его к содержимому регистра 0, на x86 потребует двух команд для своей реализации.

<p>Редкая особенность BAL в наличие отдельных команд для сложения и вычитания для знаковых и беззнаковых чисел, причем беззнаковые операции в BAL называются логическими. Такая странность вызвана отсутствием в архитектуре 360 привычных для большинства других архитектур флагов. Вместо них используется только два бита, которые устанавливаются по-разному разными инструкциями! Разница между знаковыми и беззнаковыми операциями только в том, что они по-разному устанавливают упомянутые два бита признаков. Для знаковых операций по ним можно узнать был ли результат равен нулю, был ли он положительный или отрицательный, произошло ли переполнение, а для безнаковых &ndash; был ли результат равен нулю и случился ли перенос или заем. Команды условных переходов позволяют учитывать все 16 подмножеств случаев, которые возможны при использовании 2 бит. По причине такой необычной сегодня работы с признаками операций, инструкции условных переходов получаются трудными для быстрого понимания. Хотя в расширения BAL обычно добавляют довольно удобные для восприятия макросы для условных переходов, где не нужно заниматься разбором каждого из 4-х бит. Тут для справедливости можно заметить, что отдельные команды для знакового и беззнакового сложения и вычитания есть, например, в архитектуре MIPS, где вообще нет флагов!

<p>Другая редкая особенность &ndash; в отдельных командах для знакового и беззнакового сравнения. Подобные встречал не только у MIPS, но и на MicroBlaze.

<p>В системах, совместимых с IBM 360, нет флага переноса, поэтому если нам нужно работать с двоичными числами, например, в 64-разряда, то мы должны для организации их сложения или вычитания проверять признак переноса, после выполнения первой 32-битной операции и делать при необходимости переход. Это, конечно, очень громоздко по сравнению с x86, ARM, 68k или даже 6502, но на гораздо более позднем MIPS &ndash; это ещё более громоздко.

<p>В BAL нет циклических сдвигов, зато нециклические, как и в x86, могут быть как одинарными, так и двойными. Однако, BAL имеет отдельные инструкции для беззнаковых и знаковых чисел, только последние из них устанавливают флаги признаков. Очевидно, что результаты сдвигов влево для обоих случаев различаются только флагами. Среди команд загрузки регистров в BAL есть возможно уникальные. Можно загружать модуль целого числа, отрицание этого модуля или число с измененным знаком &ndash; нечто отдаленно похожее я встречал только в архитектуре ARM. Тут стоит отметить, что вся архитектура 360 тяготеет к знаковой арифметике, а беззнаковая арифметика в этой архитектуре скорее вторична. В BAL нет беззнаковых деления и умножения. При загрузке регистра флаги, также как и в x86, не меняются, но есть специальная команда загрузки, которая ставит флаги &ndash; это опять напоминает ARM, где установкой флагов можно управлять.

<p>Все знаковые арифметические операций, включая сдвиги, могут генерировать исключение при переполнении. Генерировать ли исключение или нет определяется специальным флагом в регистре состояния. Интересно, что двоичные деление и умножение в BAL вообще не влияют на флаги &ndash; тут можно вспомнить x86, где деление лишь портит флаги. 

<p>Поразрядные логические операции в BAL представленны обычным набором операций И, ИЛИ, исключающее ИЛИ, т.&nbsp;е. отдельной операции отрицания нет. Логические операции могут иметь не только структуру "регистр-регистр" или "регистр-память", но и "память-константа" или "память-память" &ndash; последний способ адресации похож на тот, что используется для десятичных чисел. Адресация типа "память-константа" возможна только для работы с байтами. Очевидно, для логических операции, в отличие от арифметических, использование 16-битных чисел невозможно. Для адресации типа "память-память" можно работать с данными длиной до 256 байт! Получается, что мы имеем  три типа данных для работы с логическими операциями: байты, 32-битные слова, последовательности байт &ndash; и специальные инструкции для каждого такого типа, что скорее как-то неуниверсально.

<p>К логическим операциям в BAL примыкают операции для пересылки байт. Помимо обычной пересылки до 256 байт одной командой, есть ещё уникальные пересылки тетрад байтов. Можно пересылать только старшие или младшие половинки байт и при этом другие половинки при копировании сохраняют своё значение! Такие странные операции нужны для поддержки особенностей BAL при работе с символьной и десятичной информацией. Есть ещё появившиеся для систем 370 команды пересылки и сравнения для до более 16 миллионов байт за один раз, которые могут прерываться. Удивительно, но также небыстрые команды по работе с блоками длиной до 256 байт прерываться не могут, что может создать неприятную своей длительностью задержку реакции на запрос на прерывание. Команды для пересылки можно использовать и для заполнения памяти заданным байтом. Помимо пересылки из памяти в память, можно ещё и устанавливать заданным значением отдельные байты. Очевидно, что команды для пересылки байт для x86 реализованы более продвинуто.

<p>В регистр можно загружать не только значение по заданому адресу, но и сам адрес, как в командах LEA для x86 или 68k. В регистр можно загружать и отдельные байты и даже группы байт, например, только первый и третий &ndash; последнее для всех известных мне архитектур возможно только через серию из 4-х команд. Аналогичным образом BAL позволяет выгружать в память только части регистра.

<p>Ряд BAL инструкций очень громоздки &ndash; в других архитектурах такие реализуются серией более простых команд. Например, инструкцию TR позволяет провести перекодировку строки символов &ndash; одним аргументом задаётся строка для перекодировки, а другим адрес перекодировочной таблицы. Особый вариант этой инструкции, TRT, можно использовать для сканирования заданной строки и пропуска пустых символов &ndash; это функциональность стандартного вызова strpos языка C. Инструкции ED и EDMK абсолютно уникальны &ndash; они имеют функциональность примитивного варианта sprintf!

<p>В BAL из-за отсутствия команд вращения или команд типа SWAP очень трудно работать с 16-битными беззнаковыми величинами. Некоторые инструкции BAL объявлены устаревшими, например, инструкция для полубайтовых сдвигов MVO была вытеснена гораздо более удобной SRP. Для блочных пересылок и сравнений лучше использовать новые инструкции, хотя из-за того, что они используют другой способ адресации, это может быть в некоторых редких случаях неоптимальным. В BAL можно делить только 64-битные величины, задаваемые двумя регистрами, что иногда слишком громоздко &ndash; хотелось бы иметь возможность делить и 32-битные величины.

<p>Как уже отмечалось, BAL имеет только четыре основных режима адресации, к которым только в систем Z добавили ещё один. Такие режимы, как характерные для VAX, 68k, PDP-11 или даже 6809 режимы с авто инкрементом или декрементом в BAL отсутствуют. Также нет режимов с двойным косвенным обращением к памяти, которые есть для VAX, 68020 или PDP-11. И, конечно, BAL &ndash; это в отличие от VAX или PDP-11 совершенно неортогонален. Ближе всего BAL к ассемблерам x86 и ARM &mdash; самым успешным современным архитектурам. Порядок операндов в BAL справа-налево, также как и в x86 или ARM и, соответственно, не так как у VAX, PDP-11 или 68k.

<p>Операции с десятичными числами реализуются в BAL только через адресацию типа "память-память". Десятичные числа могут задаваться участками памяти длиной до 16 байт, что позволяет использовать числа, имеющие до 31 десятичного разряда. Это соответствует точности двоичного числа со 107 разрядами! Таким образом, только самые современные системы программирования, использующие целые двоичные числа, могут работать с более высокой точностью, чем системы 360 почти 60 лет назад!

<p>Как уже отмечалось, десятичные числа на BAL представляются уникально, они должны хранить знак &ndash; такого нет для VAX, x86, 68k, ... Причем знак хранится в последнем байте представления числа. Для десятичных чисел в BAL есть непосредственная поддержка для всех основных операций: сложения, вычитания, умножения и даже деления &ndash; такого также нет ни в одной другой известной мне архитектуре. Кроме того в BAL есть ещё инструкции для копирования, сравнения и сдвигов десятичных чисел. Упоминавшаяся инструкции MVO и SRP предназначены именно для таких сдвигов &ndash; они могут работать только с правильно заданными десятичными данными, хотя теоретически они могли бы работать с любыми двоичными данными. Операции могут выполняться только над упакованными десятичными числами, но для их распечатки их надо распаковать, причем и для представления распаковынных EBCDIC или ASCII цифр в BAL также необходим знак, который в этом случае не занимет места, так как помещается в старшую тетраду, что требует особой работы с этой тетрадой перед печатью. Странно, что операции для паковки и распаковки могут работать только с не более чем 16 байтами распакованного десятичного числа, что позволяет использовать с ними только не более, чем 15-разрядные числа. Эта неприятная проблема может быть решена использованием для распаковки инструкций ED или EDMK, а вот упаковку большого неупакованного числа придётся делать через не совсем простую последовательность инструкций. Любопытно, что инструкции для упаковки и распаковки работают с любыми двоичными данными, а не только с десятичными.

<p>В BAL есть специальные инструкции, позволяющие за раз конвертировать двоичное число в упакованное десятичное и наоборот. Для десятичного числа всегда выделяется 8 байт, т.&nbsp;е. 15 цифр и знак. Однако, 32-битного регистра хватает только для представления знакового числа соответствующего 9-значному десятичному числу, поэтому не всякое десятичное число в правильном формате BAL можно преобразовать в двоичное одной командой.

<br><hr>
клоны СССР, драгметаллы
сеть moshix

<br>
<hr>
<p>Cтатья опубликована на <a href=https://geektimes.ru/post/>geektimes</a>, а также переведена на <a href=https://litwr.livejournal.com/>английский</a>.
</body>

