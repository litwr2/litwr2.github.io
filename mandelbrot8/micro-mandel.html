<head>
<title>Fast Mandelbrot for Micros</title>
<style type=text/css>
td {text-align: right}
table, th, td {
   border-width:thin;
   border-style:solid;
   border-color:green;
   border-spacing:0px;
}
</style>
</head>
<body bgcolor=lightgreen>
<div align=center>
<h1 align=center>Superfast Mandelbrot benchmark results</h1>

<p>Visualizations of the 8th generations of this Mandelbrot are available <a href=https://litwr2.github.io/mandelbrot8/mandelbrot.html>here</a>.

<p>All systems use the same algorithm that calculates 128x256 dots of Mandelbrot.  They also use almost the same ways to visualize it.  Every dot is encoded with 4 bits.  So all systems have to output exactly 16 KB of graphical data for every picture.  Detailed information about graphic modes used is in the next table (the number in parentheses is the effective CPU frequency).

<table border=1>
<tr><th>#
<th>System
<th>Video mode
<th>Window
<th>Comments
<tr><th>1<td style=text-align:center>&#x411;K0010, K1801BM1@3(2) MHz<td>512x256, monochrome<td>512x256x1 <td>4x1 texture/pixel
<tr><th>2<td style=text-align:center>"<td>256x256, 4 colors<td>256x256x4 <td>2x1 texture/pixel
<tr><th>3<td style=text-align:center>&#x411;K0011, K1801BM1@4(2.3) MHz<td>256x256x4 <td>"<td>"
<tr><th>4<td style=text-align:center>Amstrad CPC 4, Z80@4(3.2) MHz<td>"<td>"<td>"
<tr><th>5<td style=text-align:center>"<td>128x256, 16 colors<td>128x256x16<td>
<tr><th>6<td style=text-align:center>BBC Micro, 6502@2 MHz<td>256x256, 4 colors<td>256x256x4 <td>2x1 texture/pixel
<tr><th>7<td style=text-align:center>"<td>128x256, 16 colors<td>128x256x16 <td>
<tr><th>8<td style=text-align:center>Commodore +4 (PAL), 6502@1.7 (1) MHz<td>160x256, 4 colors<td>128x256x4 <td>2 flashing dots/pixel
<tr><th>9<td style=text-align:center>IBM PC (EGA), 8088@4.8 MHz<td>640x350, 16 colors<td>128x256x16<td>
<tr><th>10<td style=text-align:center>Amiga 500 (PAL), 68000@7.1 MHz<td>320x256, 16 colors<td>128x256x16 <td>
<tr><th>11<td style=text-align:center>Acorn Archimedes 305, ARM2@8 MHz<td>"<td>"<td>
<tr><th>12<td style=text-align:center>Sinclair QL, 68008@7.5 MHz<td>256x256, 16 colors<td>128x256x16 <td>
<tr><th>13<td style=text-align:center>Corvette, 8080@2.5 MHz<td>512x256, 8 colors<td>256x256x4 <td>2x1 texture/pixel
<tr><th>14<td style=text-align:center>"<td>"<td>256x256x8 <td>"
</table>

<p>The Mandelbrot algorithm uses the next parameters for the first 16 visualizations.
<table border=1>
<tr><th>#
<th>iterations
<th>x-interval
<th>y-interval
<tr><td>1 <td>7 <td>[-4.64062, 4.28906] <td>[-4.5, 4.5]
<tr><td>2 <td>8 <td>[-4.09375, 3.5957] <td>[-3.75, 3.75]
<tr><td>3 <td>9 <td>[-3.69336, 3.00391] <td>[-3.25, 3.25]
<tr><td>4 <td>10<td>[-3.20508, 2.5] <td>[-2.75, 2.75]
<tr><td>5 <td>11<td>[-2.89258, 2.06836] <td>[-2.5, 2.5]
<tr><td>6 <td>12<td>[-2.76562, 1.69922] <td>[-2, 2]
<tr><td>7 <td>13<td>[-2.83203, 1.38477] <td>[-1.5, 1.5]
<tr><td>8 <td>14<td>[-2.60352, 1.11719] <td>[-1, 1]
<tr><td>9 <td>15<td>[-2.33594, 0.888672] <td>[-0.75, 0.75]
<tr><td>10<td>16<td>[-2.0332, 0.695312] <td>[-0.75, 0.75]
<tr><td>11<td>17<td>[-1.95117, 0.529297] <td>[-0.75, 0.75]
<tr><td>12<td>18<td>[-2.09766, 0.382812] <td>[-0.75, 0.75]
<tr><td>13<td>19<td>[-2.22266, 0.257812] <td>[-0.75, 0.75]
<tr><td>14<td>20<td>[-2.33203, 0.148438] <td>[-0.75, 0.75]
<tr><td>15<td>21<td>[-2.42578, 0.0546875] <td>[-0.75, 0.75]
<tr><td>16<td>22<td>[-2.50586, -0.0253906] <td>[-0.75, 0.75]
</table>

<p>All systems also provide timing information.  The next table shows timings for drawing of pictures #1-16.
<table border=1>
<tr><th rowspan=2>#
<th>C+4
<th>&#x411;K<br>0010
<th>CPC 16<br>colors
<th>CPC 4<br>colors
<th>BBC<br>Micro<br> 16 colors
<th>BBC<br>Micro<br> 4 colors
<th>Corvette<br>8 colors<br>color mode
<th>Corvette<br>4 colors<br>planar mode
<tr><th>v3<th colspan=5>v2<th colspan=2>v1
<tr><td> 1<td> 4.70<td> 3.63<td> 2.55<td> 2.76<td> 2.24<td> 2.35<td> 5.00<td> 5.38
<tr><td> 2<td> 5.40<td> 3.89<td> 2.86<td> 3.06<td> 2.60<td> 2.70<td> 5.54<td> 5.92
<tr><td> 3<td> 6.24<td> 4.20<td> 3.22<td> 3.43<td> 3.03<td> 3.13<td> 6.22<td> 6.60
<tr><td> 4<td> 7.64<td> 4.70<td> 3.82<td> 4.03<td> 3.73<td> 3.84<td> 7.32<td> 7.66
<tr><td> 5<td> 9.08<td> 5.22<td> 4.44<td> 4.65<td> 4.46<td> 4.56<td> 8.44<td> 8.82
<tr><td> 6<td>11.62<td> 6.15<td> 5.54<td> 5.75<td> 5.75<td> 5.86<td>10.46<td>10.84
<tr><td> 7<td>14.90<td> 7.34<td> 6.95<td> 7.16<td> 7.41<td> 7.51<td>13.04<td>13.42
<tr><td> 8<td>21.68<td> 9.81<td> 9.89<td>10.10<td>10.85<td>10.96<td>18.42<td>18.78
<tr><td> 9<td>29.12<td>12.51<td>13.10<td>13.31<td>14.64<td>14.74<td>24.30<td>24.66
<tr><td>10<td>34.82<td>14.59<td>15.56<td>15.77<td>17.52<td>17.63<td>28.72<td>29.16
<tr><td>11<td>38.94<td>16.09<td>17.34<td>17.55<td>19.62<td>19.72<td>32.06<td>32.42
<tr><td>12<td>39.44<td>16.27<td>17.56<td>17.77<td>19.87<td>19.98<td>32.46<td>32.82
<tr><td>13<td>38.40<td>15.89<td>17.11<td>17.32<td>19.34<td>19.44<td>31.62<td>32.02
<tr><td>14<td>37.22<td>15.46<td>16.60<td>16.81<td>18.74<td>18.84<td>30.70<td>31.06
<tr><td>15<td>36.04<td>15.04<td>16.09<td>16.30<td>18.13<td>18.24<td>29.76<td>30.12
<tr><td>16<td>34.80<td>14.59<td>15.56<td>15.77<td>17.51<td>17.62<td>28.78<td>29.16
<tr><td>total
        <td>370.04<td>165.38<td>168.19<td>171.54<td>185.44<td>187.12<td>312.84<td>318.84
</table>

<p>The color writing mode for the Corvette writes data for all 3 graphic planes simultaneously, so it actually updates 24 KB of video RAM on each screen in this mode.

<p>The next table shows the timings for faster computers.
<table border=1>
<tr><th rowspan=2>#
<th>&#x411;K<br>0011
<th>Amiga<br>500
<th>IBM PC<br>5160 EGA<br>mode 0
<th>IBM PC<br>5160 EGA<br>mode 2
<th>Acorn<br>Archimedes<br>305
<th>QL
<th>QL<br>external<br>RAM
<tr><th colspan=5> v2<th colspan=2> v1
<tr><th> 1<td> 3.40<td> 0.94<td> 1.87<td> 1.59<td> 0.12<td> 1.94<td> 1.14
<tr><th> 2<td> 3.63<td> 1.00<td> 1.98<td> 1.76<td> 0.14<td> 2.16<td> 1.26
<tr><th> 3<td> 3.91<td> 1.06<td> 2.08<td> 1.93<td> 0.17<td> 2.39<td> 1.38
<tr><th> 4<td> 4.37<td> 1.20<td> 2.36<td> 2.14<td> 0.21<td> 2.61<td> 1.50
<tr><th> 5<td> 4.84<td> 1.30<td> 2.64<td> 2.42<td> 0.25<td> 3.18<td> 1.83
<tr><th> 6<td> 5.68<td> 1.52<td> 3.07<td> 2.85<td> 0.32<td> 3.91<td> 2.23
<tr><th> 7<td> 6.76<td> 1.82<td> 3.68<td> 3.46<td> 0.41<td> 4.83<td> 2.77
<tr><th> 8<td> 8.99<td> 2.36<td> 4.89<td> 4.72<td> 0.59<td> 6.75<td> 3.86
<tr><th> 9<td>11.45<td> 3.00<td> 6.20<td> 6.04<td> 0.80<td> 8.82<td> 5.03
<tr><th>10<td>13.32<td> 3.48<td> 7.25<td> 7.08<td> 0.96<td>10.42<td> 5.96
<tr><th>11<td>14.69<td> 3.82<td> 8.08<td> 7.80<td> 1.07<td>11.60<td> 6.63
<tr><th>12<td>14.85<td> 3.86<td> 8.13<td> 7.91<td> 1.09<td>11.75<td> 6.71
<tr><th>13<td>14.51<td> 3.78<td> 7.96<td> 7.69<td> 1.06<td>11.45<td> 6.54
<tr><th>14<td>14.12<td> 3.70<td> 7.69<td> 7.53<td> 1.03<td>11.13<td> 6.37
<tr><th>15<td>13.73<td> 3.58<td> 7.52<td> 7.30<td> 0.99<td>10.79<td> 6.16
<tr><th>16<td>13.33<td> 3.48<td> 7.30<td> 7.09<td> 0.96<td>10.45<td> 5.97
<tr><th>total<td>151.58<td>39.90<td>82.70<td>79.31<td>10.17<td>114.17<td>65.35
</table>

<p>Writing modes 0 and 2 were used for the EGA.  Both produce the same picture.  I can think that for the VGA results will be the same.  The results for the Amiga 500 with fast RAM are only about 1% faster so I haven't included them.

<p>Emulators were used to get these results.

<p><table>
<tr><th>Machine <th>Emulator
<tr><td style=text-align:left>&#x411;K0010 <td>BK2010 v0.5
<tr><td style=text-align:left>&#x411;K0011M <td>GID v3.10
<tr><td style=text-align:left>Commodore+4 <td>plus4emu v1.2.10
<tr><td style=text-align:left>Amstrad CPC<td>ep128emu v2.0.11
<tr><td style=text-align:left>BBC Master <td>b-em v-ec63538
<tr><td style=text-align:left>Amiga 500 <td>FS-UAE 3.0.5
<tr><td style=text-align:left>IBM PC XT EGA <td>pcem 17
<tr><td style=text-align:left>Acorn Archimedes 305 <td>Arculator v2.1
<tr><td style=text-align:left>Sinclair QL <td>QemuLator 3.4
<tr><td style=text-align:left>Corvette <td>emu80 v4.0.396
</table>

<p>Qemulator appears to be about 7% faster than real hardware.  So the unexpanded QL results are adjusted with this 7%.  Real QL results have been provided by mk79.  A lot of thanks to him.  The data is also used for the QL with external memory.  It seems that pcem is also about 7% faster than the real IBM PC but I have only indirect information about this so I didn't apply any correction to data from pcem.

<p>The Commodore +4 results can be about 5% faster if we turn on the NTSC mode during vertical retrace time.

<p>The next table contains approximate values of efficiency reciprocals (ER) for the tested CPUs.  These values are calculated by multiplication of the total time of the calculation of 16 first Mandelbrot pictures by the effective CPU frequency.  The ER value reflects the efficiency of CPU electronics, it gives the reciprocal of the CPU performance at 1 MHz.

<table border=1>
<tr align=center><th>Rank <th>Processor <th>The effective<br>frequency <th>ER
<tr align=center><th>1 <td>ARM2 <td>8 <td>82
<tr align=center><th>2 <td>68000 <td>7.1 <td>282
<tr align=center><th>3 <td>K1801BM1 <td>2 <td>330
<tr align=center><th>4 <td>6502 <td>2 <td>371
<tr align=center><th>5 <td>8088 <td>4.8 <td>378
<tr align=center><th>6 <td>68008 <td>7.5 <td>490
<tr align=center><th>7 <td>Z80 <td>3.2 <td>538
<tr align=center><th>8 <td>8080 <td>2.5 <td>782
</table>

<p>It is also interesting to compare the code density for this task.  Two values are provided for this: the total program size and the size of the main loop.

<table border=1>
<tr>
<th rowspan=2>Rank
<th rowspan=2>Platform
<th rowspan=2>CPU
<th rowspan=2>Program size
<th colspan=2>Main loop size<tr><th>bytes<th>LOC
<tr align=center><th>1 <td style=text-align:center>&#x411;K <td>T-11 <td>806 <td>32 <td>13
<tr align=center><th>2 <td style=text-align:center>IBM PC <td>8088 <td>879 <td>46 <td>20
<tr align=center><th>3 <td style=text-align:center>QL <td>68008 <td>2029 <td>" <td>"
<tr align=center><th>4 <td style=text-align:center>Amiga <td>68000 <td>2384 <td>" <td>"
<tr align=center><th>5 <td style=text-align:center>Amstrad, 16c <td>Z80 <td>979 <td>54 <td>37
<tr align=center><th>6 <td style=text-align:center>Amstrad, 4c <td>Z80 <td>1016 <td>" <td>"
<tr align=center><th>7 <td style=text-align:center>Corvette, color<td>8080 <td>1057 <td>84 <td>66
<tr align=center><th>8 <td style=text-align:center>Corvette, planar<td>8080 <td>1102 <td>" <td>"
<tr align=center><th>9 <td style=text-align:center>Archimedes<td>ARM2 <td>1342 <td>100 <td>25
<tr align=center><th>10 <td style=text-align:center>BBC Micro, 16c <td>6502 <td>1266 <td>131 <td>81
<tr align=center><th>11 <td style=text-align:center>BBC Micro, 4c <td>6502 <td>1298 <td>" <td>"
<tr align=center><th>12 <td style=text-align:center>Plus4 <td>6502 <td>1627 <td>"<td>"
</table>

<p>The QL code consists of two Basic programs which generate and use ML code.

<p>Sources for all these programs are available at <a href=https://github.com/litwr2/rosetta-mandelbrot>github</a>. You also can download their executables there.

<p>If anybody finds a way to speed up these implementations of Mandelbrot calculations, or just creates new implementations, please inform me and I should update this page.  Send your reports to zliztwr@yzandex.ru but remove all z from the address.

</div>
</body>
