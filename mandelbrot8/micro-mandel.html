<head>
<title>Fast Mandelbrot for Micros</title>
<style type=text/css>
td {text-align: right}
table, th, td {
   border-width:thin;
   border-style:solid;
   border-color:green;
   border-spacing:0px;
}
</style>
</head>
<body bgcolor=lightgreen>
<div align=center>
<h1 align=center>Superfast Mandelbrot benchmark results</h1>

<p>Visualizations of the 8th generations of this Mandelbrot are available <a href=https://litwr2.github.io/mandelbrot8/mandelbrot.html>here</a>.

<p>All systems use the same algorithm that calculates 128x256 dots of Mandelbrot.  They also use almost the same ways to visualize it.  Every dot is encoded with 4 bits.  So all systems have to output exactly 16 KB of graphical data for every picture.  Detailed information about graphic modes used is in the next table (the number in paratheses is the effective CPU frequency).

<table border=1>
<tr><th>#
<th>System
<th>Video mode
<th>Comments
<tr><th>1<td style=text-align:center>&#x411;K0010, K1801BM1@3(2) MHz<td>512x256, monochrome<td>4x1 texture/pixel
<tr><th>2<td style=text-align:center>"<td>256x256, 4 colors<td>2x1 texture/pixel
<tr><th>3<td style=text-align:center>&#x411;K0011, K1801BM1@4(2.3) MHz<td>"<td>"
<tr><th>4<td style=text-align:center>Amstrad CPC 4, Z80@4(3.2) MHz<td>"<td>2x1 texture/pixel
<tr><th>5<td style=text-align:center>"<td>128x256, 16 colors<td>
<tr><th>6<td style=text-align:center>BBC Micro, 6502@2 MHz<td>256x256, 4 colors<td>2x1 texture/pixel
<tr><th>7<td style=text-align:center>"<td>128x256, 16 colors<td>
<tr><th>8<td style=text-align:center>Commodore +4 (PAL), 6502@1.7 (1) MHz<td>128x256, 4 colors<td>2 flashing dots/pixel
<tr><th>9<td style=text-align:center>IBM PC (EGA), 8088@4.8 MHz<td>128x256, 16 colors<td>
<tr><th>10<td style=text-align:center>Amiga 500 (PAL), 68000@7.1 MHz<td>"<td>
</table>

<p>The Mandelbrot algorithm uses the next parameters for the first 16 visualizations.
<table border=1>
<tr><th>#
<th>iterations
<th>x-interval
<th>y-interval
<tr><td>1 <td>7 <td>[-4.64062, 4.28906] <td>[-4.5, 4.5]
<tr><td>2 <td>8 <td>[-4.09375, 3.5957] <td>[-2.25, 2.25]
<tr><td>3 <td>9 <td>[-3.69336, 3.00391] <td>[-1.875, 1.875]
<tr><td>4 <td>10<td>[-3.20508, 2.5] <td>[-1.625, 1.625]
<tr><td>5 <td>11<td>[-2.89258, 2.06836] <td>[-1.375, 1.375]
<tr><td>6 <td>12<td>[-2.76562, 1.69922] <td>[-1.25, 1.25]
<tr><td>7 <td>13<td>[-2.83203, 1.38477] <td>[-1, 1]
<tr><td>8 <td>14<td>[-2.60352, 1.11719] <td>[-0.75, 0.75]
<tr><td>9 <td>15<td>[-2.33594, 0.888672] <td>[-0.5, 0.5]
<tr><td>10<td>16<td>[-2.0332, 0.695312] <td>[-0.375, 0.375]
<tr><td>11<td>17<td>[-1.95117, 0.529297] <td>[-0.375, 0.375]
<tr><td>12<td>18<td>[-2.09766, 0.382812] <td>[-0.375, 0.375]
<tr><td>13<td>19<td>[-2.22266, 0.257812] <td>[-0.375, 0.375]
<tr><td>14<td>20<td>[-2.33203, 0.148438] <td>[-0.375, 0.375]
<tr><td>15<td>21<td>[-2.42578, 0.0546875] <td>[-0.375, 0.375]
<tr><td>16<td>22<td>[-2.50586, -0.0253906] <td>[-0.375, 0.375]
</table>

<p>All systems also provide timing information.  The next table shows timings for drawing of pictures #1-16.
<table border=1>
<tr><th rowspan=2>#
<th>C+4
<th>&#x411;K<br>0010
<th>CPC 16<br>colors
<th>CPC 4<br>colors
<th>BBC<br>Micro 16<br>colors
<th>BBC<br>Micro 4<br>colors
<tr><th colspan=6>v2
<tr><td> 1<td> 4.72<td> 3.63<td> 2.55<td> 2.76<td> 2.23<td> 2.34
<tr><td> 2<td> 5.42<td> 3.89<td> 2.86<td> 3.06<td> 2.58<td> 2.69
<tr><td> 3<td> 6.27<td> 4.20<td> 3.22<td> 3.43<td> 3.02<td> 3.12
<tr><td> 4<td> 7.66<td> 4.70<td> 3.82<td> 4.03<td> 3.72<td> 3.82
<tr><td> 5<td> 9.08<td> 5.22<td> 4.44<td> 4.65<td> 4.44<td> 4.54
<tr><td> 6<td>11.64<td> 6.15<td> 5.54<td> 5.75<td> 5.73<td> 5.83
<tr><td> 7<td>14.92<td> 7.34<td> 6.95<td> 7.16<td> 7.38<td> 7.48
<tr><td> 8<td>21.68<td> 9.81<td> 9.89<td>10.10<td>10.81<td>10.91
<tr><td> 9<td>29.13<td>12.51<td>13.10<td>13.31<td>14.57<td>14.68
<tr><td>10<td>34.82<td>14.59<td>15.56<td>15.77<td>17.44<td>17.54
<tr><td>11<td>38.94<td>16.09<td>17.34<td>17.55<td>19.53<td>19.63
<tr><td>12<td>39.44<td>16.27<td>17.56<td>17.77<td>19.78<td>19.88
<tr><td>13<td>39.40<td>15.89<td>17.11<td>17.32<td>19.25<td>19.35
<tr><td>14<td>37.22<td>15.46<td>16.60<td>16.81<td>18.65<td>18.75
<tr><td>15<td>36.20<td>15.04<td>16.09<td>16.30<td>18.05<td>18.15
<tr><td>16<td>34.80<td>14.59<td>15.56<td>15.77<td>17.43<td>17.53
<tr><td>total
        <td>371.34<td>165.38<td>168.19<td>171.54<td>184.61<td>186.24
</table>

<p>The next table shows the timings for faster computers.
<table border=1>
<tr><th rowspan=2>#
<th>&#x411;K<br>0011
<th>Amiga<br>500
<th>IBM PC<br>5160 EGA
<tr><th colspan=3>v2
<tr><th> 1<td> 3.40<td> 0.94<td> 1.44
<tr><th> 2<td> 3.63<td> 1.00<td> 1.54
<tr><th> 3<td> 3.91<td> 1.06<td> 1.65
<tr><th> 4<td> 4.37<td> 1.20<td> 1.87
<tr><th> 5<td> 4.84<td> 1.30<td> 2.08
<tr><th> 6<td> 5.68<td> 1.52<td> 2.46
<tr><th> 7<td> 6.76<td> 1.82<td> 2.95
<tr><th> 8<td> 8.99<td> 2.36<td> 3.93
<tr><th> 9<td>11.45<td> 3.00<td> 4.95
<tr><th>10<td>13.32<td> 3.48<td> 5.77
<tr><th>11<td>14.69<td> 3.82<td> 6.37
<tr><th>12<td>14.85<td> 3.86<td> 6.43
<tr><th>13<td>14.51<td> 3.78<td> 6.32
<tr><th>14<td>14.12<td> 3.70<td> 6.09
<tr><th>15<td>13.73<td> 3.58<td> 5.98
<tr><th>16<td>13.33<td> 3.48<td> 5.77
<tr><th>total<td>151.58<td>39.90<td>65.60
</table>

<p>Emulators were used to get these results: BK2010 v0.5 for the BK0010, GID v3.10 for the BK0011M, plus4emu v1.2.10 for the Commodore+4, ep128emu v2.0.11 for the Amstrad CPC, mess 0.229 for the BBC Master, FS-UAE 3.0.5 for the Amiga 500, pce-ibmpc version 20140222-4b05f0c for the IBM PC 5160 EGA.  The emulators are quite accurate for timings, the only exception is the emulator for the IBM PC which appears to be about 20-25% faster than real hardware.  So all the speed results for the IBM PC may be degraded by this 20-25%.

<p>The Commodore +4 results can be about 5% faster if we turn on the NTSC mode during vertical retrace time.

<p>The next table contains approximate values of efficiency reciprocals (ER) for the tested CPUs.  These values are calculated by multiplication of the total time of the calculation of 16 first Mandelbrot pictures by the effective CPU frequency.  The ER value reflects the efficiency of CPU electronics, it gives the reciprocal of the CPU performance at 1 MHz.

<table border=1>
<tr align=center><th>Rank <th>Processor <th>The effective<br>frequency <th>ER
<tr align=center><th>1 <td>68000 <td>7.1 <td>283
<tr align=center><th>2 <td>8088 <td>4.8 <td>315
<tr align=center><th>3 <td>K1801BM1 <td>2 <td>330
<tr align=center><th>4 <td>6502 <td>2 <td>369
<tr align=center><th>5 <td>Z80 <td>3.2 <td>538
</table>

<p>It is also interesting to compare the code density for this task.  Two values are provided for this: the total program size and the size of the main loop.

<table border=1>
<tr>
<th rowspan=2>Rank
<th rowspan=2>Platform
<th rowspan=2>CPU
<th rowspan=2>Program size
<th colspan=2>Main loop size<tr><th>bytes<th>LOC
<tr align=center><th>1 <td style=text-align:center>&#x411;K <td>T-11 <td>806 <td>32 <td>13
<tr align=center><th>2 <td style=text-align:center>IBM PC <td>8088 <td>979 <td>46 <td>20
<tr align=center><th>3 <td style=text-align:center>Amiga <td>68000 <td>2384 <td>46 <td>20
<tr align=center><th>4 <td style=text-align:center>Amstrad, 16c <td>Z80 <td>979 <td>54 <td>37
<tr align=center><th>5 <td style=text-align:center>Amstrad, 4c <td>Z80 <td>1016 <td>" <td>"
<tr align=center><th>6 <td style=text-align:center>BBC Micro, 16c <td>6502 <td>1266 <td>131 <td>81
<tr align=center><th>7 <td style=text-align:center>BBC Micro, 4c <td>6502 <td>1298 <td>" <td>"
<tr align=center><th>8 <td style=text-align:center>Plus4 <td>6502 <td>1684 <td>"<td>"
</table>

<p>Sources for all these programs are available at <a href=https://github.com/litwr2/rosetta-mandelbrot>github</a>. You also can download their executables there.

<p>If anybody finds a way to speed up these implementations of Mandelbrot calculations, or just creates new implementations, please inform me and I should update this page.  Send your reports to zliztwr@yzandex.ru but remove all z from the address.

</div>
</body>
