<head>
<meta charset=utf-8>
<title>Оптимизация быстрой сортировки</title>
<meta name=keywords content="C++, sorting algorithm, insertion sort, shell sort, quick sort, introspective sort, heap sort,benchmarks,программирование,алгоритмы сортировки,stl,bsd,строки,структуры данных,тестирование производительности,сортировка вставками, сортировка шелла, быстрая сортировка, сортировка кучей, интросорт, интроспективная сортировка, std::sort, std::qsort, lomuto sort, dualpivot sort">
<style type=text/css>
pre, textarea {
    background-color: lightgreen;
}
table, th, td {
   border-width:thin;
   border-style:solid;
   border-color:green;
   border-spacing:0px;
}
</style>
</head>
<body>
<h1>Оптимизация быстрой сортировки</h1>

<p>Быстрая сортировка, открытая на рубеже 60-х Хоаром, известна своей простотой в реализации и универсальностью. Однако, главное, что делает её привлекательной &ndash; это её высокая эффективность. В абсолютном большинстве случаев скорость её работы близка к рекордным показателям: время её работы в таких случаях определяется формулой N*Log(N), где N &ndash; это число сортируемых элементов. Поэтому долгое время быстрая сортировка считалась наиболее стандартным методом сортировки. Последнее нашло отражение в том, что в стандартной библиотеке языка C существует функция qsort (std::qsort в C++), которая, как правило, является реализацией быстрой сортировки. Более современная стандартная сортировка std::sort реализует интроспективную сортировку, которая основана на быстрой сортировке. В языке Java в качестве стандартной для сортировки необъектных данных также используется современный вариант быстрой сортировки.

<p>Другая привлекательная особенность быстрой сортировке в том, что ей не требуется выделять дополнительную память при сортировке данных. Этим она выгодно отличается от многих методов сортировки, например, сортировок слиянием или популярной ныне сортировки Тима. Но быстрая сортировка рекурсивна и поэтому интенсивно использует стек, в котором должно быть достаточно место для её работы. В абсолютном большинстве случаев для быстрой сортировки нужен сравнительно небольшой объем стека, пропорциональный двоичному логарифму от числа сортируемых элементов.

<p>Весь алгоритм быстрой сортировки можно описать несколькими предложениями. Сортируемая последовательность делится на две части таким образом, что в первой части все сортируемые элементы меньше (или больше), чем во второй части. С каждой частью процесс повторяется. Вот и весь алгоритм! Такое разделение обычно делается на основании выбранного опорного элемента &ndash; в одну часть идут элементы большие него, а в другую меньшие. Хоар предложил выбирать опорный элемент из середины сортируемой последовательности, но его можно выбирать и другими способами.

<p>Однако, у быстрой сортировки есть два серьёзных недостатка. Самый главный из них состоит в том, что на некоторых хотя и чрезвычайно редких, почти статистически невозможных последовательностях данных быстрая сортировка работает очень медленно, на уровне самых простейших и медленных алгоритмов сортировки, по квадратичному закону. В таких редких случаях, например, вместо ожидаемых долей секунды сортировка может длиться часами, что может поломать систему, где такое случится. Второй недостаток в том, что на таких очень редких последовательностях данных быстрая сортировка может использовать объем стека, сравнимый с числом сортируемых элементов, и в этом случае стандартного стека, выделяемого задаче, может не хватить, что приведет исполнение такой задачи к краху. Например, на современных системах сортировка Ломуто почти гарантированно ломается, если сортирует миллион упорядоченных или почти упорядоченных единиц данных. Поэтому, в частности, быстрая сортировка не может быть использована в режиме ядра ОС, где объем стека невелик.

<p>Учитывая привлекательные особенности быстрой сортировки её постоянно пытаются улучшать. Почти все улучшения можно разбить на две основные категории. В первой относятся попытки более оптимально выбирать опорный элемент. Ко второй &ndash; минимизировать использование стека.

<p>Было предложено несколько типичных способов выбора опорного элемента. В идеале опорный элемент должен разбивать данные на две примерно равные части, но чтобы точно найти такой элемент нужно сделать обработку почти всех сортируемых данных (в идеале их нужно отсортировать), что недопустимо замедлит работу. Кроме того, выбор опорного элемента должен быть сделан максимально быстро. Поэтому мы получаем два взаимно-противоречивых требования и должны искать оптимальный вариант. Для простоты и максимальной быстроты можно выбирать один из крайних элементов. Так делается в популярном <a>варианте</a> быстрой сортировки, предложенным Ломуто, которая поэтому на случайных данных в среднем чуть быстрее классического варианта Хоара. Но простой метод выбора делает сортировку более уязвимой, например, сортировку Ломуто гарантированно делают квадратичной простые упорядоченные или почти упорядоченные данные. Сортировку Хоара уже так просто не сломать, для неё нужно конструировать специальные нетривиальные ломающие последовательности. Для тестов использовал две такие последовательности, которые тормозят сортировку Хоара выбором одноэлементных разделов справа и слева. Более продвинутый, по сравнению со способом Хоара, способ состоит в выборе лучшего из трех выбранных элементов, их медианы. Обычно берут медиану первого, среднего и последнего элементов. Тестирование методом Монте-Карло показало, что среднестатистический опорный элемент при использовании медианы трёх примерно на треть ближе к идеальной медиане, чем при использовании просто среднего элемента. Найдены довольно быстрые способы расчета медианы трёх (удивительно, но выбрать из трех элементов средний &ndash; это не совсем тривиальная задача). Поэтому именно медиана трех используется в стандартных методах std::sort и std::qsort (gcc). Мои тесты подтверждают, что такой выбор опорного элемента в среднем лучше способа Хоара, но совсем незначительно &ndash; издержки на вычисление медианы почти равны преимуществу от её использования. Вариант с выбором опорного элемента медианой из пяти (семи и более) элементов данных слишком медленный и также не гарантирует защиты от плохой последовательности. Для гарантии ухода от возможности квадратичной обработки используют выбор медианы медиан для опорного элемента: сортируемая последовательность делится на обычно пять частей, в которых рекурсивно находится медиана, и потом берется медиана выбранных пяти медиан. Такой метод гарантирует, что в худшем случае опорный элемент разобьёт исходную последовательность на части приблизительно в пропорции 30% к 70%, что гарантирует невозможность квадратичного случая. Но само вычисление медины медиан делает быструю сортировку в несколько раз медленнее, поэтому вычисление опорного элемента таким сравнительно медленным методом лучше делать только в случае, если число рекурсивных вызовов стало большим установленного предела. Другим подходом в выборе опорного элемента является его рандомизация, что позволяет эффективно бороться со случаями специально сконструированных последовательностей, которые ломают быструю сортировку.

<p>Минимизировать использование стека можно двумя способами. Можно гарантировать логарифмический объем требуемой стековой памяти, помещая обработку меньшей части последовательности впереди большей и затем проводя оптимизацию хвостового вызова, оставив из двух рекурсивных вызовов только один, что для некоторых последовательностей вообще не потребует рекурсивных вызовов. Оптимизация хвостового вызова делает код чуть-чуть быстрее. Можно полностью отказаться от рекурсии, сохраняя данные в специально для них созданном стеке, что снизит нагрузку на такой стек на треть. Так делают в текущей реализации std::qsort (gcc).

<p>Давайте теперь разберёмся какие оптимизации стоит использовать, а какие скорее нет. Не стоит мудрить с выбором опорного элемента, так как более сложный выбор требует дополнительных расчетов, которые поглотят выигрыш от такого более лучшего выбора. Тесты быстродействия показывают, что простые способы выбора опорного элемента обеспечивают большую скорость работы на типичных случайных данных. Снизить вероятность случая очень медленной, квадратичной обработки можно только анализом большего объема данных при выборе опорной точки. Рандомизация этого выбора только скроет проблему, вероятность она не понизит. Таким образом, невозможно избавиться от возможности случая квадратичной временной зависимости при использовании алгоритма быстрой сортировки, без обработки значительной части данных, которая превратит сортировку в сравнительно медленную.

<p>При оптимизации использования стека нужно иметь в виду, что это не защищает от случаев квадратичного времени работы. Например, у меня получилось убить std::qsort. Устранение второго рекурсивного вызова приводит к невозможности обнаружения всех ситуаций, когда сортировка показывает тенденцию к квадратичной обработке, анализом значения указателя стека. Хотя прямая работа с указателем стека нормальна только разве для системных программ; для обычных, прикладных проще использовать специальную переменную для хранения глубины рекурсивного вызова &ndash; именно так, через переменную, глубина рекурсивных вызовов отслеживается в std::sort. Для устранения возможности квадратичной обработки std::sort проверяет значение этой переменной и если она превышает допустимую, то происходит переключение на сортировку кучей. Кстати, на современной аппаратуре сортировка Шелла на скалярных данных оказывается заметно быстрее сортировки кучей, поэтому возможно, что для чисел лучше переключаться на сортировку методом Шелла.

<p>Идея с переключением на другую сортировку подкупает своей надежностью и простой. Однако, она кажется также и несколько громоздкой. В качестве её альтернативы можно предложить просто перезапускать быструю сортировку. Это сработает, так как в процессе выполнения рекурсивных вызовов данные частично упорядочиваются. Конечно, схема Ломуто тут не подойдёт, а вот изначальная схема Хоара со средним опорным элементом или типичной медианой трёх работает в таком случае отлично.

<p>Особая категория оптимизации быстрой сортировки &ndash; это её замена на более более эффективную при маленьком числе сортируемых элементов. Обычно для этого используют сортировку вставкой. Это заметно повышает быстродействие.

<p>Самые интересные оптимизации связаны с чем-то совершенно новыми. Так Владимир Ярославский предложил в 2009 использовать разделения не на две, а на три части, что потребовало использования двух опорных элементов. Это реально дало прирост быстродействия. Его сортировку, как уже об этом писал, уже используют в Java. Если её интегрировать в интроспективную сортировку, то это последнюю также должно ускорить. Почему-то в GCC с этим пока тормозят. Интересно, что можно данные можно разбивать на две части, вообще не используя опорный элемент. <a>Такой вариант</a> быстрой сортировки достаточно давно известен, его характеристики близки к варианту Ломуто.

<p>Современные компиляторы могут преподнести сюрпризы со своей иногда труднопредсказуемой оптимизацией. Нередко может получится так, что код, который с трудом вручную был оптимизирован, работает медленнее исходного. Например, обнаружилось, что ручная оптимизация хвостовой рекурсии часто работает медленнее, чем автоматическая! Неожиданно оказалось, что вызовы (только вызовы!) std::sort после компиляции с оптимизацией и без &ndash; это совершенно разные вещи, причем первый вызов работает в примерно 10 раз быстрее! Можно даже предположить, что код std::sort как-то специально подогнан под оптимизатор &ndash; там, например, даже вызов сортировки кучей идет не напрямую, а через специальную функцию, доступную разработчикам, но отсутствующую в документации по стандартной библиотеке.

<p>В заключении привожу <a>код</a> надежной быстрой сортировки. Она основана на классической быстрой сортировке Хоара, но на маленьких массивах она переключается на сортировку вставками, а если глубина рекурсивных вызовов становится больше указанной, то она просто перезапускается. При компиляции без оптимизации она обгоняет std::sort, а std::qsort на числах она обгоняет почти всегда. Она даже может обогнать сортировку с двумя опорными элементами, если сортируются записи по значению одного из их полей. Надежную быструю сортировку можно использовать и в ядре ОС, явно указав максимальное число для рекурсивных вызовов. Она всё-таки заметно быстрее сортировки Шелла, которую по умолчанию используют в ядрах некоторых ОС. Очевидно, что подобным образом можно превратить в надежную и сортировку В. Ярославского. В Java вместо прямолинейных setjmp и longjmp можно использовать catch и throw.

<p>Конечно возникает вопрос, а насколько надёжен такой метод? Нет ли здесь какой-нибудь лазейки для возможности работы по квадратичному закону? Массивным тестированием мне почти ни разу не удалось заставить эту сортировку работать медленнее сортировки кучей: сортировка кучей оказалась быстрее только в случаях работы со строками, расположенными в порядке, ломающем сортировку Хоара. Нужно, однако, иметь в виду, что надежную быструю сортировку можно реально зациклить, если указать число рекурсивных вызовов меньше двоичного логарифма размера данных. Пока поставил значением по умолчанию число примерно в 10 раз большее.

<p>Данные по скорости работы надежной быстрой сортировки можно найти в следующей интерактивной <a>таблице</a>.

<p>Возможно что-то упустил. Буду рад замечаниям и дополнительной информации.

<br>
<br>
<hr>
Вариант статьи опубликован на <a href=https://habr.com/ru/post/>habrahabr</a>
<br>
<br>
